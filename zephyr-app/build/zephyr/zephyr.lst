
zephyr.elf:     file format elf32-littleriscv


Disassembly of section vector:

40000000 <__start>:

	/*
	 * Set mtvec (Machine Trap-Vector Base-Address Register)
	 * to __irq_wrapper.
	 */
	la t0, __irq_wrapper
40000000:	00000297          	auipc	t0,0x0
40000004:	01028293          	addi	t0,t0,16 # 40000010 <__irq_wrapper>
	csrw mtvec, t0
40000008:	30529073          	csrw	mtvec,t0

	/* Jump to __initialize */
	tail __initialize
4000000c:	7340206f          	j	40002740 <__initialize>

Disassembly of section exceptions:

40000010 <__irq_wrapper>:
	 * Save caller-saved registers on current thread stack.
	 * NOTE: need to be updated to account for floating-point registers
	 * floating-point registers should be accounted for when corresponding
	 * config variable is set
	 */
	STORE_CALLER_SAVED()
40000010:	fb010113          	addi	sp,sp,-80
40000014:	00112023          	sw	ra,0(sp)
40000018:	00312223          	sw	gp,4(sp)
4000001c:	00412423          	sw	tp,8(sp)
40000020:	00512623          	sw	t0,12(sp)
40000024:	00612823          	sw	t1,16(sp)
40000028:	00712a23          	sw	t2,20(sp)
4000002c:	01c12c23          	sw	t3,24(sp)
40000030:	01d12e23          	sw	t4,28(sp)
40000034:	03e12023          	sw	t5,32(sp)
40000038:	03f12223          	sw	t6,36(sp)
4000003c:	02a12423          	sw	a0,40(sp)
40000040:	02b12623          	sw	a1,44(sp)
40000044:	02c12823          	sw	a2,48(sp)
40000048:	02d12a23          	sw	a3,52(sp)
4000004c:	02e12c23          	sw	a4,56(sp)
40000050:	02f12e23          	sw	a5,60(sp)
40000054:	05012023          	sw	a6,64(sp)
40000058:	05112223          	sw	a7,68(sp)

skip_store_fp_caller_saved:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Save MEPC register */
	csrr t0, mepc
4000005c:	341022f3          	csrr	t0,mepc
	RV_OP_STOREREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
40000060:	04512423          	sw	t0,72(sp)

	/* Save SOC-specific MSTATUS register */
	csrr t0, mstatus
40000064:	300022f3          	csrr	t0,mstatus
	RV_OP_STOREREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
40000068:	04512623          	sw	t0,76(sp)
	 * SOCs (like pulpino or riscv-qemu), the MSB is never set to indicate
	 * interrupt. Hence, check for interrupt/exception via the __soc_is_irq
	 * function (that needs to be implemented by each SOC). The result is
	 * returned via register a0 (1: interrupt, 0 exception)
	 */
	jal ra, __soc_is_irq
4000006c:	21c000ef          	jal	ra,40000288 <__soc_is_irq>

	/* If a0 != 0, jump to is_interrupt */
	addi t1, x0, 0
40000070:	00000313          	li	t1,0
	bnez a0, is_interrupt
40000074:	02051e63          	bnez	a0,400000b0 <is_interrupt>
	/*
	 * If the exception is the result of an ECALL, check whether to
	 * perform a context-switch or an IRQ offload. Otherwise call _Fault
	 * to report the exception.
	 */
	csrr t0, mcause
40000078:	342022f3          	csrr	t0,mcause
	li t2, SOC_MCAUSE_EXP_MASK
4000007c:	800003b7          	lui	t2,0x80000
40000080:	fff38393          	addi	t2,t2,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and t0, t0, t2
40000084:	0072f2b3          	and	t0,t0,t2
	li t1, SOC_MCAUSE_ECALL_EXP
40000088:	00b00313          	li	t1,11

	/*
	 * If mcause == SOC_MCAUSE_ECALL_EXP, handle system call from
	 * kernel thread.
	 */
	beq t0, t1, is_kernel_syscall
4000008c:	00628a63          	beq	t0,t1,400000a0 <is_kernel_syscall>
	 * Stack pointer is pointing to a z_arch_esf_t structure, pass it
	 * to _Fault (via register a0).
	 * If _Fault shall return, set return address to
	 * no_reschedule to restore stack.
	 */
	addi a0, sp, 0
40000090:	00010513          	mv	a0,sp
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
	RV_OP_LOADREG t0, _thread_offset_to_priv_stack_start(t1)
	RV_OP_STOREREG sp, _thread_offset_to_user_sp(t1) /* Update user SP */
	addi sp, t0, CONFIG_PRIVILEGED_STACK_SIZE
#else
	la ra, no_reschedule
40000094:	00000097          	auipc	ra,0x0
40000098:	18408093          	addi	ra,ra,388 # 40000218 <no_reschedule>
#endif /* CONFIG_USERSPACE */

	tail _Fault
4000009c:	6640206f          	j	40002700 <_Fault>

400000a0 <is_kernel_syscall>:
	 * again upon exiting the ISR.
	 *
	 * It's safe to always increment by 4, even with compressed
	 * instructions, because the ecall instruction is always 4 bytes.
	 */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
400000a0:	04812283          	lw	t0,72(sp)
	addi t0, t0, 4
400000a4:	00428293          	addi	t0,t0,4
	RV_OP_STOREREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
400000a8:	04512423          	sw	t0,72(sp)
	j z_riscv_user_mode_enter_syscall
#endif /* CONFIG_USERSPACE */
	/*
	 * Go to reschedule to handle context-switch
	 */
	j reschedule
400000ac:	0800006f          	j	4000012c <reschedule>

400000b0 <is_interrupt>:
	 * Save current thread stack pointer and switch
	 * stack pointer to interrupt stack.
	 */

	/* Save thread stack pointer to temp register t0 */
	addi t0, sp, 0
400000b0:	00010293          	mv	t0,sp

	/* Switch to interrupt stack */
	la t2, _kernel
400000b4:	00004397          	auipc	t2,0x4
400000b8:	6c438393          	addi	t2,t2,1732 # 40004778 <_kernel>
	RV_OP_LOADREG sp, _kernel_offset_to_irq_stack(t2)
400000bc:	0043a103          	lw	sp,4(t2)

	/*
	 * Save thread stack pointer on interrupt stack
	 * In RISC-V, stack pointer needs to be 16-byte aligned
	 */
	addi sp, sp, -16
400000c0:	ff010113          	addi	sp,sp,-16
	RV_OP_STOREREG t0, 0x00(sp)
400000c4:	00512023          	sw	t0,0(sp)

400000c8 <on_irq_stack>:
	la t2, _kernel
#endif /* !CONFIG_USERSPACE && !CONFIG_PMP_STACK_GUARD */

on_irq_stack:
	/* Increment _kernel.cpus[0].nested variable */
	lw t3, _kernel_offset_to_nested(t2)
400000c8:	0003ae03          	lw	t3,0(t2)
	addi t3, t3, 1
400000cc:	001e0e13          	addi	t3,t3,1
	sw t3, _kernel_offset_to_nested(t2)
400000d0:	01c3a023          	sw	t3,0(t2)
#ifdef CONFIG_TRACING_ISR
	call sys_trace_isr_enter
#endif

	/* Get IRQ causing interrupt */
	csrr a0, mcause
400000d4:	34202573          	csrr	a0,mcause
	li t0, SOC_MCAUSE_EXP_MASK
400000d8:	800002b7          	lui	t0,0x80000
400000dc:	fff28293          	addi	t0,t0,-1 # 7fffffff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000000>
	and a0, a0, t0
400000e0:	00557533          	and	a0,a0,t0

	/*
	 * Clear pending IRQ generating the interrupt at SOC level
	 * Pass IRQ number to __soc_handle_irq via register a0
	 */
	jal ra, __soc_handle_irq
400000e4:	194000ef          	jal	ra,40000278 <__soc_handle_irq>

	/*
	 * Call corresponding registered function in _sw_isr_table.
	 * (table is 2-word wide, we should shift index accordingly)
	 */
	la t0, _sw_isr_table
400000e8:	00004297          	auipc	t0,0x4
400000ec:	14c28293          	addi	t0,t0,332 # 40004234 <_sw_isr_table>
	slli a0, a0, (RV_REGSHIFT + 1)
400000f0:	00351513          	slli	a0,a0,0x3
	add t0, t0, a0
400000f4:	00a282b3          	add	t0,t0,a0

	/* Load argument in a0 register */
	RV_OP_LOADREG a0, 0x00(t0)
400000f8:	0002a503          	lw	a0,0(t0)

	/* Load ISR function address in register t1 */
	RV_OP_LOADREG t1, RV_REGSIZE(t0)
400000fc:	0042a303          	lw	t1,4(t0)

	/* Call ISR function */
	jalr ra, t1
40000100:	000300e7          	jalr	t1

40000104 <on_thread_stack>:

on_thread_stack:
	/* Get reference to _kernel */
	la t1, _kernel
40000104:	00004317          	auipc	t1,0x4
40000108:	67430313          	addi	t1,t1,1652 # 40004778 <_kernel>

	/* Decrement _kernel.cpus[0].nested variable */
	lw t2, _kernel_offset_to_nested(t1)
4000010c:	00032383          	lw	t2,0(t1)
	addi t2, t2, -1
40000110:	fff38393          	addi	t2,t2,-1
	sw t2, _kernel_offset_to_nested(t1)
40000114:	00732023          	sw	t2,0(t1)

#if !defined(CONFIG_USERSPACE) && !defined(CONFIG_PMP_STACK_GUARD)
	/* Restore thread stack pointer */
	RV_OP_LOADREG t0, 0x00(sp)
40000118:	00012283          	lw	t0,0(sp)
	addi sp, t0, 0
4000011c:	00028113          	mv	sp,t0
	/*
	 * Check if we need to perform a reschedule
	 */

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t2, _kernel_offset_to_current(t1)
40000120:	00832383          	lw	t2,8(t1)

	/*
	 * Check if next thread to schedule is current thread.
	 * If yes do not perform a reschedule
	 */
	RV_OP_LOADREG t3, _kernel_offset_to_ready_q_cache(t1)
40000124:	02432e03          	lw	t3,36(t1)
	beq t3, t2, no_reschedule
40000128:	0e7e0863          	beq	t3,t2,40000218 <no_reschedule>

4000012c <reschedule>:

#if CONFIG_INSTRUMENT_THREAD_SWITCHING
	call z_thread_mark_switched_out
#endif
	/* Get reference to _kernel */
	la t0, _kernel
4000012c:	00004297          	auipc	t0,0x4
40000130:	64c28293          	addi	t0,t0,1612 # 40004778 <_kernel>

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
40000134:	0082a303          	lw	t1,8(t0)

	/*
	 * Save callee-saved registers of current kernel thread
	 * prior to handle context-switching
	 */
	STORE_CALLEE_SAVED(t1)
40000138:	02832e23          	sw	s0,60(t1)
4000013c:	04932023          	sw	s1,64(t1)
40000140:	05232223          	sw	s2,68(t1)
40000144:	05332423          	sw	s3,72(t1)
40000148:	05432623          	sw	s4,76(t1)
4000014c:	05532823          	sw	s5,80(t1)
40000150:	05632a23          	sw	s6,84(t1)
40000154:	05732c23          	sw	s7,88(t1)
40000158:	05832e23          	sw	s8,92(t1)
4000015c:	07932023          	sw	s9,96(t1)
40000160:	07a32223          	sw	s10,100(t1)
40000164:	07b32423          	sw	s11,104(t1)

40000168 <skip_callee_saved_reg>:

	/*
	 * Save stack pointer of current thread and set the default return value
	 * of z_swap to _k_neg_eagain for the thread.
	 */
	RV_OP_STOREREG sp, _thread_offset_to_sp(t1)
40000168:	02232c23          	sw	sp,56(t1)
	la t2, _k_neg_eagain
4000016c:	00004397          	auipc	t2,0x4
40000170:	13438393          	addi	t2,t2,308 # 400042a0 <_k_neg_eagain>
	lw t3, 0x00(t2)
40000174:	0003ae03          	lw	t3,0(t2)
	sw t3, _thread_offset_to_swap_return_value(t1)
40000178:	07c32e23          	sw	t3,124(t1)

	/* Get next thread to schedule. */
	RV_OP_LOADREG t1, _kernel_offset_to_ready_q_cache(t0)
4000017c:	0242a303          	lw	t1,36(t0)

	/*
	 * Set _kernel.current to new thread loaded in t1
	 */
	RV_OP_STOREREG t1, _kernel_offset_to_current(t0)
40000180:	0062a423          	sw	t1,8(t0)

	/* Switch to new thread stack */
	RV_OP_LOADREG sp, _thread_offset_to_sp(t1)
40000184:	03832103          	lw	sp,56(t1)

	/* Restore callee-saved registers of new thread */
	LOAD_CALLER_SAVED(t1)
40000188:	03c32403          	lw	s0,60(t1)
4000018c:	04032483          	lw	s1,64(t1)
40000190:	04432903          	lw	s2,68(t1)
40000194:	04832983          	lw	s3,72(t1)
40000198:	04c32a03          	lw	s4,76(t1)
4000019c:	05032a83          	lw	s5,80(t1)
400001a0:	05432b03          	lw	s6,84(t1)
400001a4:	05832b83          	lw	s7,88(t1)
400001a8:	05c32c03          	lw	s8,92(t1)
400001ac:	06032c83          	lw	s9,96(t1)
400001b0:	06432d03          	lw	s10,100(t1)
400001b4:	06832d83          	lw	s11,104(t1)
	addi a0, sp, __z_arch_esf_t_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
400001b8:	04812283          	lw	t0,72(sp)
	csrw mepc, t0
400001bc:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
400001c0:	04c12283          	lw	t0,76(sp)
	csrw mstatus, t0
400001c4:	30029073          	csrw	mstatus,t0

skip_load_fp_caller_saved_resched:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Restore caller-saved registers from thread stack */
	LOAD_CALLEE_SAVED()
400001c8:	00012083          	lw	ra,0(sp)
400001cc:	00412183          	lw	gp,4(sp)
400001d0:	00812203          	lw	tp,8(sp)
400001d4:	00c12283          	lw	t0,12(sp)
400001d8:	01012303          	lw	t1,16(sp)
400001dc:	01412383          	lw	t2,20(sp)
400001e0:	01812e03          	lw	t3,24(sp)
400001e4:	01c12e83          	lw	t4,28(sp)
400001e8:	02012f03          	lw	t5,32(sp)
400001ec:	02412f83          	lw	t6,36(sp)
400001f0:	02812503          	lw	a0,40(sp)
400001f4:	02c12583          	lw	a1,44(sp)
400001f8:	03012603          	lw	a2,48(sp)
400001fc:	03412683          	lw	a3,52(sp)
40000200:	03812703          	lw	a4,56(sp)
40000204:	03c12783          	lw	a5,60(sp)
40000208:	04012803          	lw	a6,64(sp)
4000020c:	04412883          	lw	a7,68(sp)
40000210:	05010113          	addi	sp,sp,80

	/* Call SOC_ERET to exit ISR */
	SOC_ERET
40000214:	30200073          	mret

40000218 <no_reschedule>:
	addi a0, sp, __z_arch_esf_t_soc_context_OFFSET
	jal ra, __soc_restore_context
#endif /* CONFIG_RISCV_SOC_CONTEXT_SAVE */

	/* Restore MEPC register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mepc_OFFSET(sp)
40000218:	04812283          	lw	t0,72(sp)
	csrw mepc, t0
4000021c:	34129073          	csrw	mepc,t0

	/* Restore SOC-specific MSTATUS register */
	RV_OP_LOADREG t0, __z_arch_esf_t_mstatus_OFFSET(sp)
40000220:	04c12283          	lw	t0,76(sp)
	csrw mstatus, t0
40000224:	30029073          	csrw	mstatus,t0

skip_load_fp_caller_saved:
#endif /* CONFIG_FPU && CONFIG_FPU_SHARING */

	/* Restore caller-saved registers from thread stack */
	LOAD_CALLEE_SAVED()
40000228:	00012083          	lw	ra,0(sp)
4000022c:	00412183          	lw	gp,4(sp)
40000230:	00812203          	lw	tp,8(sp)
40000234:	00c12283          	lw	t0,12(sp)
40000238:	01012303          	lw	t1,16(sp)
4000023c:	01412383          	lw	t2,20(sp)
40000240:	01812e03          	lw	t3,24(sp)
40000244:	01c12e83          	lw	t4,28(sp)
40000248:	02012f03          	lw	t5,32(sp)
4000024c:	02412f83          	lw	t6,36(sp)
40000250:	02812503          	lw	a0,40(sp)
40000254:	02c12583          	lw	a1,44(sp)
40000258:	03012603          	lw	a2,48(sp)
4000025c:	03412683          	lw	a3,52(sp)
40000260:	03812703          	lw	a4,56(sp)
40000264:	03c12783          	lw	a5,60(sp)
40000268:	04012803          	lw	a6,64(sp)
4000026c:	04412883          	lw	a7,68(sp)
40000270:	05010113          	addi	sp,sp,80

#ifdef CONFIG_PMP_STACK_GUARD
	csrrw sp, mscratch, sp
#endif /* CONFIG_PMP_STACK_GUARD */
	/* Call SOC_ERET to exit ISR */
	SOC_ERET
40000274:	30200073          	mret

40000278 <__soc_handle_irq>:
 * SOC-specific function to handle pending IRQ number generating the interrupt.
 * Exception number is given as parameter via register a0.
 */
SECTION_FUNC(exception.other, __soc_handle_irq)
	/* Clear exception number from CSR mip register */
	li t1, 1
40000278:	00100313          	li	t1,1
	sll t0, t1, a0
4000027c:	00a312b3          	sll	t0,t1,a0
	csrrc t1, mip, t0
40000280:	3442b373          	csrrc	t1,mip,t0

	/* Return */
	jalr x0, ra
40000284:	00008067          	ret

40000288 <__soc_is_irq>:
 * return 1 (interrupt) or 0 (exception)
 *
 */
SECTION_FUNC(exception.other, __soc_is_irq)
	/* Read mcause and check if interrupt bit is set */
	csrr t0, mcause
40000288:	342022f3          	csrr	t0,mcause
	li t1, SOC_MCAUSE_IRQ_MASK
4000028c:	80000337          	lui	t1,0x80000
	and t0, t0, t1
40000290:	0062f2b3          	and	t0,t0,t1

	/* If interrupt bit is not set, return with 0 */
	addi a0, x0, 0
40000294:	00000513          	li	a0,0
	beqz t0, not_interrupt
40000298:	00028463          	beqz	t0,400002a0 <not_interrupt>
	addi a0, a0, 1
4000029c:	00150513          	addi	a0,a0,1

400002a0 <not_interrupt>:

not_interrupt:
	/* return */
	jalr x0, ra
400002a0:	00008067          	ret

400002a4 <arch_swap>:
 * key is stored in a0 register
 */
SECTION_FUNC(exception.other, arch_swap)

	/* Make a system call to perform context switch */
	ecall
400002a4:	00000073          	ecall
	 * Prior to unlocking irq, load return value of
	 * arch_swap to temp register t2 (from
	 * _thread_offset_to_swap_return_value). Normally, it should be -EAGAIN,
	 * unless someone has previously called arch_thread_return_value_set(..).
	 */
	la t0, _kernel
400002a8:	00004297          	auipc	t0,0x4
400002ac:	4d028293          	addi	t0,t0,1232 # 40004778 <_kernel>

	/* Get pointer to _kernel.current */
	RV_OP_LOADREG t1, _kernel_offset_to_current(t0)
400002b0:	0082a303          	lw	t1,8(t0)

	/* Load return value of arch_swap function in temp register t2 */
	lw t2, _thread_offset_to_swap_return_value(t1)
400002b4:	07c32383          	lw	t2,124(t1) # 8000007c <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x8000007d>

	/*
	 * Unlock irq, following IRQ lock state in a0 register.
	 * Use atomic instruction csrrs to do so.
	 */
	andi a0, a0, MSTATUS_IEN
400002b8:	00857513          	andi	a0,a0,8
	csrrs t0, mstatus, a0
400002bc:	300522f3          	csrrs	t0,mstatus,a0

	/* Set value of return register a0 to value of register t2 */
	addi a0, t2, 0
400002c0:	00038513          	mv	a0,t2

	/* Return */
	jalr x0, ra
400002c4:	00008067          	ret

Disassembly of section text:

400002c8 <__clzsi2>:
400002c8:	000107b7          	lui	a5,0x10
400002cc:	02f57463          	bgeu	a0,a5,400002f4 <__clzsi2+0x2c>
400002d0:	0ff00793          	li	a5,255
400002d4:	02000713          	li	a4,32
400002d8:	06a7e263          	bltu	a5,a0,4000033c <__clzsi2+0x74>
400002dc:	400047b7          	lui	a5,0x40004
400002e0:	2a478793          	addi	a5,a5,676 # 400042a4 <__clz_tab>
400002e4:	00a78533          	add	a0,a5,a0
400002e8:	00054503          	lbu	a0,0(a0)
400002ec:	40a70533          	sub	a0,a4,a0
400002f0:	00008067          	ret
400002f4:	010007b7          	lui	a5,0x1000
400002f8:	02f57263          	bgeu	a0,a5,4000031c <__clzsi2+0x54>
400002fc:	400047b7          	lui	a5,0x40004
40000300:	2a478793          	addi	a5,a5,676 # 400042a4 <__clz_tab>
40000304:	01055513          	srli	a0,a0,0x10
40000308:	00a78533          	add	a0,a5,a0
4000030c:	00054503          	lbu	a0,0(a0)
40000310:	01000713          	li	a4,16
40000314:	40a70533          	sub	a0,a4,a0
40000318:	00008067          	ret
4000031c:	400047b7          	lui	a5,0x40004
40000320:	2a478793          	addi	a5,a5,676 # 400042a4 <__clz_tab>
40000324:	01855513          	srli	a0,a0,0x18
40000328:	00a78533          	add	a0,a5,a0
4000032c:	00054503          	lbu	a0,0(a0)
40000330:	00800713          	li	a4,8
40000334:	40a70533          	sub	a0,a4,a0
40000338:	00008067          	ret
4000033c:	400047b7          	lui	a5,0x40004
40000340:	2a478793          	addi	a5,a5,676 # 400042a4 <__clz_tab>
40000344:	00855513          	srli	a0,a0,0x8
40000348:	00a78533          	add	a0,a5,a0
4000034c:	00054503          	lbu	a0,0(a0)
40000350:	01800713          	li	a4,24
40000354:	40a70533          	sub	a0,a4,a0
40000358:	00008067          	ret

4000035c <__udivdi3>:
4000035c:	00068e13          	mv	t3,a3
40000360:	00060893          	mv	a7,a2
40000364:	00050313          	mv	t1,a0
40000368:	00058813          	mv	a6,a1
4000036c:	0c069e63          	bnez	a3,40000448 <__udivdi3+0xec>
40000370:	12c5fa63          	bgeu	a1,a2,400004a4 <__udivdi3+0x148>
40000374:	000107b7          	lui	a5,0x10
40000378:	20f66a63          	bltu	a2,a5,4000058c <__udivdi3+0x230>
4000037c:	010007b7          	lui	a5,0x1000
40000380:	42f66663          	bltu	a2,a5,400007ac <__udivdi3+0x450>
40000384:	01865713          	srli	a4,a2,0x18
40000388:	01800e13          	li	t3,24
4000038c:	400047b7          	lui	a5,0x40004
40000390:	2a478793          	addi	a5,a5,676 # 400042a4 <__clz_tab>
40000394:	00e787b3          	add	a5,a5,a4
40000398:	0007c783          	lbu	a5,0(a5)
4000039c:	02000713          	li	a4,32
400003a0:	01c78e33          	add	t3,a5,t3
400003a4:	41c707b3          	sub	a5,a4,t3
400003a8:	01c70c63          	beq	a4,t3,400003c0 <__udivdi3+0x64>
400003ac:	00f59833          	sll	a6,a1,a5
400003b0:	01c55e33          	srl	t3,a0,t3
400003b4:	00f618b3          	sll	a7,a2,a5
400003b8:	010e6833          	or	a6,t3,a6
400003bc:	00f51333          	sll	t1,a0,a5
400003c0:	0108d593          	srli	a1,a7,0x10
400003c4:	02b85533          	divu	a0,a6,a1
400003c8:	01089693          	slli	a3,a7,0x10
400003cc:	0106d693          	srli	a3,a3,0x10
400003d0:	01035793          	srli	a5,t1,0x10
400003d4:	02b87733          	remu	a4,a6,a1
400003d8:	02a68633          	mul	a2,a3,a0
400003dc:	01071713          	slli	a4,a4,0x10
400003e0:	00f76833          	or	a6,a4,a5
400003e4:	00c87c63          	bgeu	a6,a2,400003fc <__udivdi3+0xa0>
400003e8:	01180833          	add	a6,a6,a7
400003ec:	fff50793          	addi	a5,a0,-1
400003f0:	01186463          	bltu	a6,a7,400003f8 <__udivdi3+0x9c>
400003f4:	3ec86863          	bltu	a6,a2,400007e4 <__udivdi3+0x488>
400003f8:	00078513          	mv	a0,a5
400003fc:	40c80833          	sub	a6,a6,a2
40000400:	02b85633          	divu	a2,a6,a1
40000404:	01031313          	slli	t1,t1,0x10
40000408:	01035313          	srli	t1,t1,0x10
4000040c:	02b87833          	remu	a6,a6,a1
40000410:	02c686b3          	mul	a3,a3,a2
40000414:	01081813          	slli	a6,a6,0x10
40000418:	00686833          	or	a6,a6,t1
4000041c:	00d87e63          	bgeu	a6,a3,40000438 <__udivdi3+0xdc>
40000420:	01088833          	add	a6,a7,a6
40000424:	fff60793          	addi	a5,a2,-1
40000428:	01186663          	bltu	a6,a7,40000434 <__udivdi3+0xd8>
4000042c:	ffe60613          	addi	a2,a2,-2
40000430:	00d86463          	bltu	a6,a3,40000438 <__udivdi3+0xdc>
40000434:	00078613          	mv	a2,a5
40000438:	01051513          	slli	a0,a0,0x10
4000043c:	00c56533          	or	a0,a0,a2
40000440:	00000593          	li	a1,0
40000444:	00008067          	ret
40000448:	00d5f863          	bgeu	a1,a3,40000458 <__udivdi3+0xfc>
4000044c:	00000593          	li	a1,0
40000450:	00000513          	li	a0,0
40000454:	00008067          	ret
40000458:	000107b7          	lui	a5,0x10
4000045c:	14f6e463          	bltu	a3,a5,400005a4 <__udivdi3+0x248>
40000460:	010007b7          	lui	a5,0x1000
40000464:	32f6e263          	bltu	a3,a5,40000788 <__udivdi3+0x42c>
40000468:	0186d813          	srli	a6,a3,0x18
4000046c:	01800713          	li	a4,24
40000470:	400047b7          	lui	a5,0x40004
40000474:	2a478793          	addi	a5,a5,676 # 400042a4 <__clz_tab>
40000478:	010787b3          	add	a5,a5,a6
4000047c:	0007ce03          	lbu	t3,0(a5)
40000480:	02000793          	li	a5,32
40000484:	00ee0e33          	add	t3,t3,a4
40000488:	41c78eb3          	sub	t4,a5,t3
4000048c:	1dc79863          	bne	a5,t3,4000065c <__udivdi3+0x300>
40000490:	32b6e463          	bltu	a3,a1,400007b8 <__udivdi3+0x45c>
40000494:	00c53633          	sltu	a2,a0,a2
40000498:	00164513          	xori	a0,a2,1
4000049c:	00000593          	li	a1,0
400004a0:	00008067          	ret
400004a4:	00061663          	bnez	a2,400004b0 <__udivdi3+0x154>
400004a8:	00100793          	li	a5,1
400004ac:	02c7d8b3          	divu	a7,a5,a2
400004b0:	000107b7          	lui	a5,0x10
400004b4:	0cf8e063          	bltu	a7,a5,40000574 <__udivdi3+0x218>
400004b8:	010007b7          	lui	a5,0x1000
400004bc:	2ef8e263          	bltu	a7,a5,400007a0 <__udivdi3+0x444>
400004c0:	0188d713          	srli	a4,a7,0x18
400004c4:	01800e13          	li	t3,24
400004c8:	400047b7          	lui	a5,0x40004
400004cc:	2a478793          	addi	a5,a5,676 # 400042a4 <__clz_tab>
400004d0:	00e787b3          	add	a5,a5,a4
400004d4:	0007c683          	lbu	a3,0(a5)
400004d8:	02000793          	li	a5,32
400004dc:	01c68e33          	add	t3,a3,t3
400004e0:	41c782b3          	sub	t0,a5,t3
400004e4:	0dc79a63          	bne	a5,t3,400005b8 <__udivdi3+0x25c>
400004e8:	01089f13          	slli	t5,a7,0x10
400004ec:	41158733          	sub	a4,a1,a7
400004f0:	0108df93          	srli	t6,a7,0x10
400004f4:	010f5f13          	srli	t5,t5,0x10
400004f8:	00100593          	li	a1,1
400004fc:	01035793          	srli	a5,t1,0x10
40000500:	03f75533          	divu	a0,a4,t6
40000504:	03f77733          	remu	a4,a4,t6
40000508:	03e506b3          	mul	a3,a0,t5
4000050c:	01071713          	slli	a4,a4,0x10
40000510:	00f767b3          	or	a5,a4,a5
40000514:	00d7fc63          	bgeu	a5,a3,4000052c <__udivdi3+0x1d0>
40000518:	011787b3          	add	a5,a5,a7
4000051c:	fff50713          	addi	a4,a0,-1
40000520:	0117e463          	bltu	a5,a7,40000528 <__udivdi3+0x1cc>
40000524:	2cd7e663          	bltu	a5,a3,400007f0 <__udivdi3+0x494>
40000528:	00070513          	mv	a0,a4
4000052c:	40d787b3          	sub	a5,a5,a3
40000530:	03f7d633          	divu	a2,a5,t6
40000534:	01031313          	slli	t1,t1,0x10
40000538:	01035313          	srli	t1,t1,0x10
4000053c:	03f7f7b3          	remu	a5,a5,t6
40000540:	03e60f33          	mul	t5,a2,t5
40000544:	01079793          	slli	a5,a5,0x10
40000548:	0067e7b3          	or	a5,a5,t1
4000054c:	01e7fe63          	bgeu	a5,t5,40000568 <__udivdi3+0x20c>
40000550:	00f887b3          	add	a5,a7,a5
40000554:	fff60713          	addi	a4,a2,-1
40000558:	0117e663          	bltu	a5,a7,40000564 <__udivdi3+0x208>
4000055c:	ffe60613          	addi	a2,a2,-2
40000560:	01e7e463          	bltu	a5,t5,40000568 <__udivdi3+0x20c>
40000564:	00070613          	mv	a2,a4
40000568:	01051513          	slli	a0,a0,0x10
4000056c:	00c56533          	or	a0,a0,a2
40000570:	00008067          	ret
40000574:	0ff00793          	li	a5,255
40000578:	00088713          	mv	a4,a7
4000057c:	f517f6e3          	bgeu	a5,a7,400004c8 <__udivdi3+0x16c>
40000580:	0088d713          	srli	a4,a7,0x8
40000584:	00800e13          	li	t3,8
40000588:	f41ff06f          	j	400004c8 <__udivdi3+0x16c>
4000058c:	0ff00793          	li	a5,255
40000590:	00060713          	mv	a4,a2
40000594:	dec7fce3          	bgeu	a5,a2,4000038c <__udivdi3+0x30>
40000598:	00865713          	srli	a4,a2,0x8
4000059c:	00800e13          	li	t3,8
400005a0:	dedff06f          	j	4000038c <__udivdi3+0x30>
400005a4:	0ff00793          	li	a5,255
400005a8:	1ed7f663          	bgeu	a5,a3,40000794 <__udivdi3+0x438>
400005ac:	0086d813          	srli	a6,a3,0x8
400005b0:	00800713          	li	a4,8
400005b4:	ebdff06f          	j	40000470 <__udivdi3+0x114>
400005b8:	005898b3          	sll	a7,a7,t0
400005bc:	01c5d633          	srl	a2,a1,t3
400005c0:	0108df93          	srli	t6,a7,0x10
400005c4:	03f65eb3          	divu	t4,a2,t6
400005c8:	01089f13          	slli	t5,a7,0x10
400005cc:	010f5f13          	srli	t5,t5,0x10
400005d0:	00559733          	sll	a4,a1,t0
400005d4:	01c55e33          	srl	t3,a0,t3
400005d8:	00ee6733          	or	a4,t3,a4
400005dc:	01075593          	srli	a1,a4,0x10
400005e0:	00551333          	sll	t1,a0,t0
400005e4:	03f676b3          	remu	a3,a2,t6
400005e8:	03df07b3          	mul	a5,t5,t4
400005ec:	01069693          	slli	a3,a3,0x10
400005f0:	00b6e6b3          	or	a3,a3,a1
400005f4:	00f6fe63          	bgeu	a3,a5,40000610 <__udivdi3+0x2b4>
400005f8:	011686b3          	add	a3,a3,a7
400005fc:	fffe8613          	addi	a2,t4,-1
40000600:	1d16ee63          	bltu	a3,a7,400007dc <__udivdi3+0x480>
40000604:	1cf6fc63          	bgeu	a3,a5,400007dc <__udivdi3+0x480>
40000608:	ffee8e93          	addi	t4,t4,-2
4000060c:	011686b3          	add	a3,a3,a7
40000610:	40f686b3          	sub	a3,a3,a5
40000614:	03f6d7b3          	divu	a5,a3,t6
40000618:	01071e13          	slli	t3,a4,0x10
4000061c:	010e5e13          	srli	t3,t3,0x10
40000620:	03f6f6b3          	remu	a3,a3,t6
40000624:	02ff0633          	mul	a2,t5,a5
40000628:	01069713          	slli	a4,a3,0x10
4000062c:	01c76733          	or	a4,a4,t3
40000630:	00c77e63          	bgeu	a4,a2,4000064c <__udivdi3+0x2f0>
40000634:	01170733          	add	a4,a4,a7
40000638:	fff78693          	addi	a3,a5,-1
4000063c:	19176863          	bltu	a4,a7,400007cc <__udivdi3+0x470>
40000640:	18c77663          	bgeu	a4,a2,400007cc <__udivdi3+0x470>
40000644:	ffe78793          	addi	a5,a5,-2
40000648:	01170733          	add	a4,a4,a7
4000064c:	010e9593          	slli	a1,t4,0x10
40000650:	40c70733          	sub	a4,a4,a2
40000654:	00f5e5b3          	or	a1,a1,a5
40000658:	ea5ff06f          	j	400004fc <__udivdi3+0x1a0>
4000065c:	01c657b3          	srl	a5,a2,t3
40000660:	01d696b3          	sll	a3,a3,t4
40000664:	00d7e6b3          	or	a3,a5,a3
40000668:	01c5d333          	srl	t1,a1,t3
4000066c:	0106df13          	srli	t5,a3,0x10
40000670:	03e358b3          	divu	a7,t1,t5
40000674:	01069713          	slli	a4,a3,0x10
40000678:	01075713          	srli	a4,a4,0x10
4000067c:	01d59833          	sll	a6,a1,t4
40000680:	01c55e33          	srl	t3,a0,t3
40000684:	010e6833          	or	a6,t3,a6
40000688:	01085793          	srli	a5,a6,0x10
4000068c:	01d61633          	sll	a2,a2,t4
40000690:	03e37333          	remu	t1,t1,t5
40000694:	031705b3          	mul	a1,a4,a7
40000698:	01031313          	slli	t1,t1,0x10
4000069c:	00f367b3          	or	a5,t1,a5
400006a0:	00b7fe63          	bgeu	a5,a1,400006bc <__udivdi3+0x360>
400006a4:	00d787b3          	add	a5,a5,a3
400006a8:	fff88313          	addi	t1,a7,-1
400006ac:	12d7e463          	bltu	a5,a3,400007d4 <__udivdi3+0x478>
400006b0:	12b7f263          	bgeu	a5,a1,400007d4 <__udivdi3+0x478>
400006b4:	ffe88893          	addi	a7,a7,-2
400006b8:	00d787b3          	add	a5,a5,a3
400006bc:	40b787b3          	sub	a5,a5,a1
400006c0:	03e7d333          	divu	t1,a5,t5
400006c4:	01081813          	slli	a6,a6,0x10
400006c8:	01085813          	srli	a6,a6,0x10
400006cc:	03e7f7b3          	remu	a5,a5,t5
400006d0:	026705b3          	mul	a1,a4,t1
400006d4:	01079793          	slli	a5,a5,0x10
400006d8:	0107e833          	or	a6,a5,a6
400006dc:	00b87e63          	bgeu	a6,a1,400006f8 <__udivdi3+0x39c>
400006e0:	00d80833          	add	a6,a6,a3
400006e4:	fff30793          	addi	a5,t1,-1
400006e8:	0cd86e63          	bltu	a6,a3,400007c4 <__udivdi3+0x468>
400006ec:	0cb87c63          	bgeu	a6,a1,400007c4 <__udivdi3+0x468>
400006f0:	ffe30313          	addi	t1,t1,-2
400006f4:	00d80833          	add	a6,a6,a3
400006f8:	01089893          	slli	a7,a7,0x10
400006fc:	00010f37          	lui	t5,0x10
40000700:	0068e8b3          	or	a7,a7,t1
40000704:	ffff0793          	addi	a5,t5,-1 # ffff <__kernel_ram_size+0xe75f>
40000708:	00f8f733          	and	a4,a7,a5
4000070c:	0108d313          	srli	t1,a7,0x10
40000710:	00f677b3          	and	a5,a2,a5
40000714:	01065613          	srli	a2,a2,0x10
40000718:	02f70e33          	mul	t3,a4,a5
4000071c:	40b80833          	sub	a6,a6,a1
40000720:	02c70733          	mul	a4,a4,a2
40000724:	010e5693          	srli	a3,t3,0x10
40000728:	02f307b3          	mul	a5,t1,a5
4000072c:	00f70733          	add	a4,a4,a5
40000730:	00e68733          	add	a4,a3,a4
40000734:	02c30633          	mul	a2,t1,a2
40000738:	00f77463          	bgeu	a4,a5,40000740 <__udivdi3+0x3e4>
4000073c:	01e60633          	add	a2,a2,t5
40000740:	01075313          	srli	t1,a4,0x10
40000744:	00c30633          	add	a2,t1,a2
40000748:	02c86a63          	bltu	a6,a2,4000077c <__udivdi3+0x420>
4000074c:	00c80863          	beq	a6,a2,4000075c <__udivdi3+0x400>
40000750:	00088513          	mv	a0,a7
40000754:	00000593          	li	a1,0
40000758:	00008067          	ret
4000075c:	000106b7          	lui	a3,0x10
40000760:	fff68693          	addi	a3,a3,-1 # ffff <__kernel_ram_size+0xe75f>
40000764:	00d77733          	and	a4,a4,a3
40000768:	01071793          	slli	a5,a4,0x10
4000076c:	00de7e33          	and	t3,t3,a3
40000770:	01d51533          	sll	a0,a0,t4
40000774:	01c787b3          	add	a5,a5,t3
40000778:	fcf57ce3          	bgeu	a0,a5,40000750 <__udivdi3+0x3f4>
4000077c:	fff88513          	addi	a0,a7,-1
40000780:	00000593          	li	a1,0
40000784:	00008067          	ret
40000788:	0106d813          	srli	a6,a3,0x10
4000078c:	01000713          	li	a4,16
40000790:	ce1ff06f          	j	40000470 <__udivdi3+0x114>
40000794:	00068813          	mv	a6,a3
40000798:	00000713          	li	a4,0
4000079c:	cd5ff06f          	j	40000470 <__udivdi3+0x114>
400007a0:	0108d713          	srli	a4,a7,0x10
400007a4:	01000e13          	li	t3,16
400007a8:	d21ff06f          	j	400004c8 <__udivdi3+0x16c>
400007ac:	01065713          	srli	a4,a2,0x10
400007b0:	01000e13          	li	t3,16
400007b4:	bd9ff06f          	j	4000038c <__udivdi3+0x30>
400007b8:	00000593          	li	a1,0
400007bc:	00100513          	li	a0,1
400007c0:	00008067          	ret
400007c4:	00078313          	mv	t1,a5
400007c8:	f31ff06f          	j	400006f8 <__udivdi3+0x39c>
400007cc:	00068793          	mv	a5,a3
400007d0:	e7dff06f          	j	4000064c <__udivdi3+0x2f0>
400007d4:	00030893          	mv	a7,t1
400007d8:	ee5ff06f          	j	400006bc <__udivdi3+0x360>
400007dc:	00060e93          	mv	t4,a2
400007e0:	e31ff06f          	j	40000610 <__udivdi3+0x2b4>
400007e4:	ffe50513          	addi	a0,a0,-2
400007e8:	01180833          	add	a6,a6,a7
400007ec:	c11ff06f          	j	400003fc <__udivdi3+0xa0>
400007f0:	ffe50513          	addi	a0,a0,-2
400007f4:	011787b3          	add	a5,a5,a7
400007f8:	d35ff06f          	j	4000052c <__udivdi3+0x1d0>

400007fc <__umoddi3>:
400007fc:	00068793          	mv	a5,a3
40000800:	00060813          	mv	a6,a2
40000804:	00050893          	mv	a7,a0
40000808:	00058713          	mv	a4,a1
4000080c:	00058e13          	mv	t3,a1
40000810:	0c069063          	bnez	a3,400008d0 <__umoddi3+0xd4>
40000814:	12c5f063          	bgeu	a1,a2,40000934 <__umoddi3+0x138>
40000818:	00010737          	lui	a4,0x10
4000081c:	1ee66863          	bltu	a2,a4,40000a0c <__umoddi3+0x210>
40000820:	010007b7          	lui	a5,0x1000
40000824:	40f66463          	bltu	a2,a5,40000c2c <__umoddi3+0x430>
40000828:	01865693          	srli	a3,a2,0x18
4000082c:	01800793          	li	a5,24
40000830:	40004737          	lui	a4,0x40004
40000834:	2a470713          	addi	a4,a4,676 # 400042a4 <__clz_tab>
40000838:	00d70733          	add	a4,a4,a3
4000083c:	00074703          	lbu	a4,0(a4)
40000840:	02000693          	li	a3,32
40000844:	00f707b3          	add	a5,a4,a5
40000848:	40f68333          	sub	t1,a3,a5
4000084c:	00f68c63          	beq	a3,a5,40000864 <__umoddi3+0x68>
40000850:	006595b3          	sll	a1,a1,t1
40000854:	00f557b3          	srl	a5,a0,a5
40000858:	00661833          	sll	a6,a2,t1
4000085c:	00b7ee33          	or	t3,a5,a1
40000860:	006518b3          	sll	a7,a0,t1
40000864:	01085613          	srli	a2,a6,0x10
40000868:	02ce57b3          	divu	a5,t3,a2
4000086c:	01081513          	slli	a0,a6,0x10
40000870:	01055513          	srli	a0,a0,0x10
40000874:	0108d693          	srli	a3,a7,0x10
40000878:	02ce7e33          	remu	t3,t3,a2
4000087c:	02f507b3          	mul	a5,a0,a5
40000880:	010e1e13          	slli	t3,t3,0x10
40000884:	00de6733          	or	a4,t3,a3
40000888:	00f77a63          	bgeu	a4,a5,4000089c <__umoddi3+0xa0>
4000088c:	01070733          	add	a4,a4,a6
40000890:	01076663          	bltu	a4,a6,4000089c <__umoddi3+0xa0>
40000894:	00f77463          	bgeu	a4,a5,4000089c <__umoddi3+0xa0>
40000898:	01070733          	add	a4,a4,a6
4000089c:	40f70733          	sub	a4,a4,a5
400008a0:	02c756b3          	divu	a3,a4,a2
400008a4:	01089793          	slli	a5,a7,0x10
400008a8:	0107d793          	srli	a5,a5,0x10
400008ac:	02c77733          	remu	a4,a4,a2
400008b0:	02d50533          	mul	a0,a0,a3
400008b4:	01071713          	slli	a4,a4,0x10
400008b8:	00f767b3          	or	a5,a4,a5
400008bc:	10a7ec63          	bltu	a5,a0,400009d4 <__umoddi3+0x1d8>
400008c0:	40a78533          	sub	a0,a5,a0
400008c4:	00655533          	srl	a0,a0,t1
400008c8:	00000593          	li	a1,0
400008cc:	00008067          	ret
400008d0:	00050813          	mv	a6,a0
400008d4:	fed5ece3          	bltu	a1,a3,400008cc <__umoddi3+0xd0>
400008d8:	000107b7          	lui	a5,0x10
400008dc:	14f6e463          	bltu	a3,a5,40000a24 <__umoddi3+0x228>
400008e0:	010007b7          	lui	a5,0x1000
400008e4:	32f6ee63          	bltu	a3,a5,40000c20 <__umoddi3+0x424>
400008e8:	0186d313          	srli	t1,a3,0x18
400008ec:	01800893          	li	a7,24
400008f0:	400047b7          	lui	a5,0x40004
400008f4:	2a478793          	addi	a5,a5,676 # 400042a4 <__clz_tab>
400008f8:	006787b3          	add	a5,a5,t1
400008fc:	0007ce03          	lbu	t3,0(a5)
40000900:	02000793          	li	a5,32
40000904:	011e0e33          	add	t3,t3,a7
40000908:	41c78333          	sub	t1,a5,t3
4000090c:	1bc79c63          	bne	a5,t3,40000ac4 <__umoddi3+0x2c8>
40000910:	00b6e463          	bltu	a3,a1,40000918 <__umoddi3+0x11c>
40000914:	00c56a63          	bltu	a0,a2,40000928 <__umoddi3+0x12c>
40000918:	40c50833          	sub	a6,a0,a2
4000091c:	40d585b3          	sub	a1,a1,a3
40000920:	01053733          	sltu	a4,a0,a6
40000924:	40e58733          	sub	a4,a1,a4
40000928:	00080513          	mv	a0,a6
4000092c:	00070593          	mv	a1,a4
40000930:	00008067          	ret
40000934:	00061663          	bnez	a2,40000940 <__umoddi3+0x144>
40000938:	00100713          	li	a4,1
4000093c:	02c75833          	divu	a6,a4,a2
40000940:	00010737          	lui	a4,0x10
40000944:	0ae86863          	bltu	a6,a4,400009f4 <__umoddi3+0x1f8>
40000948:	010007b7          	lui	a5,0x1000
4000094c:	2cf86463          	bltu	a6,a5,40000c14 <__umoddi3+0x418>
40000950:	01885693          	srli	a3,a6,0x18
40000954:	01800793          	li	a5,24
40000958:	40004737          	lui	a4,0x40004
4000095c:	2a470713          	addi	a4,a4,676 # 400042a4 <__clz_tab>
40000960:	00d70733          	add	a4,a4,a3
40000964:	00074703          	lbu	a4,0(a4)
40000968:	02000693          	li	a3,32
4000096c:	00f707b3          	add	a5,a4,a5
40000970:	40f68333          	sub	t1,a3,a5
40000974:	0cf69263          	bne	a3,a5,40000a38 <__umoddi3+0x23c>
40000978:	01081e13          	slli	t3,a6,0x10
4000097c:	410585b3          	sub	a1,a1,a6
40000980:	01085613          	srli	a2,a6,0x10
40000984:	010e5e13          	srli	t3,t3,0x10
40000988:	0108d713          	srli	a4,a7,0x10
4000098c:	02c5d6b3          	divu	a3,a1,a2
40000990:	02c5f5b3          	remu	a1,a1,a2
40000994:	03c686b3          	mul	a3,a3,t3
40000998:	01059593          	slli	a1,a1,0x10
4000099c:	00e5e733          	or	a4,a1,a4
400009a0:	00d77863          	bgeu	a4,a3,400009b0 <__umoddi3+0x1b4>
400009a4:	01070733          	add	a4,a4,a6
400009a8:	01076463          	bltu	a4,a6,400009b0 <__umoddi3+0x1b4>
400009ac:	2ad76463          	bltu	a4,a3,40000c54 <__umoddi3+0x458>
400009b0:	40d70733          	sub	a4,a4,a3
400009b4:	02c75533          	divu	a0,a4,a2
400009b8:	01089893          	slli	a7,a7,0x10
400009bc:	0108d893          	srli	a7,a7,0x10
400009c0:	02c77733          	remu	a4,a4,a2
400009c4:	03c50533          	mul	a0,a0,t3
400009c8:	01071713          	slli	a4,a4,0x10
400009cc:	011767b3          	or	a5,a4,a7
400009d0:	00a7fa63          	bgeu	a5,a0,400009e4 <__umoddi3+0x1e8>
400009d4:	010787b3          	add	a5,a5,a6
400009d8:	0107e663          	bltu	a5,a6,400009e4 <__umoddi3+0x1e8>
400009dc:	00a7f463          	bgeu	a5,a0,400009e4 <__umoddi3+0x1e8>
400009e0:	010787b3          	add	a5,a5,a6
400009e4:	40a78533          	sub	a0,a5,a0
400009e8:	00655533          	srl	a0,a0,t1
400009ec:	00000593          	li	a1,0
400009f0:	00008067          	ret
400009f4:	0ff00713          	li	a4,255
400009f8:	00080693          	mv	a3,a6
400009fc:	f5077ee3          	bgeu	a4,a6,40000958 <__umoddi3+0x15c>
40000a00:	00885693          	srli	a3,a6,0x8
40000a04:	00800793          	li	a5,8
40000a08:	f51ff06f          	j	40000958 <__umoddi3+0x15c>
40000a0c:	0ff00713          	li	a4,255
40000a10:	00060693          	mv	a3,a2
40000a14:	e0c77ee3          	bgeu	a4,a2,40000830 <__umoddi3+0x34>
40000a18:	00865693          	srli	a3,a2,0x8
40000a1c:	00800793          	li	a5,8
40000a20:	e11ff06f          	j	40000830 <__umoddi3+0x34>
40000a24:	0ff00793          	li	a5,255
40000a28:	20d7f863          	bgeu	a5,a3,40000c38 <__umoddi3+0x43c>
40000a2c:	0086d313          	srli	t1,a3,0x8
40000a30:	00800893          	li	a7,8
40000a34:	ebdff06f          	j	400008f0 <__umoddi3+0xf4>
40000a38:	00681833          	sll	a6,a6,t1
40000a3c:	00f5d733          	srl	a4,a1,a5
40000a40:	01085613          	srli	a2,a6,0x10
40000a44:	02c756b3          	divu	a3,a4,a2
40000a48:	01081e13          	slli	t3,a6,0x10
40000a4c:	00f557b3          	srl	a5,a0,a5
40000a50:	010e5e13          	srli	t3,t3,0x10
40000a54:	006595b3          	sll	a1,a1,t1
40000a58:	00b7e5b3          	or	a1,a5,a1
40000a5c:	0105de93          	srli	t4,a1,0x10
40000a60:	006518b3          	sll	a7,a0,t1
40000a64:	02c77733          	remu	a4,a4,a2
40000a68:	02de07b3          	mul	a5,t3,a3
40000a6c:	01071693          	slli	a3,a4,0x10
40000a70:	01d6e6b3          	or	a3,a3,t4
40000a74:	00f6fa63          	bgeu	a3,a5,40000a88 <__umoddi3+0x28c>
40000a78:	010686b3          	add	a3,a3,a6
40000a7c:	0106e663          	bltu	a3,a6,40000a88 <__umoddi3+0x28c>
40000a80:	00f6f463          	bgeu	a3,a5,40000a88 <__umoddi3+0x28c>
40000a84:	010686b3          	add	a3,a3,a6
40000a88:	40f686b3          	sub	a3,a3,a5
40000a8c:	02c6d733          	divu	a4,a3,a2
40000a90:	01059793          	slli	a5,a1,0x10
40000a94:	0107d793          	srli	a5,a5,0x10
40000a98:	02c6f6b3          	remu	a3,a3,a2
40000a9c:	02ee0733          	mul	a4,t3,a4
40000aa0:	01069593          	slli	a1,a3,0x10
40000aa4:	00f5e5b3          	or	a1,a1,a5
40000aa8:	00e5fa63          	bgeu	a1,a4,40000abc <__umoddi3+0x2c0>
40000aac:	010585b3          	add	a1,a1,a6
40000ab0:	0105e663          	bltu	a1,a6,40000abc <__umoddi3+0x2c0>
40000ab4:	00e5f463          	bgeu	a1,a4,40000abc <__umoddi3+0x2c0>
40000ab8:	010585b3          	add	a1,a1,a6
40000abc:	40e585b3          	sub	a1,a1,a4
40000ac0:	ec9ff06f          	j	40000988 <__umoddi3+0x18c>
40000ac4:	01c657b3          	srl	a5,a2,t3
40000ac8:	006696b3          	sll	a3,a3,t1
40000acc:	00d7e6b3          	or	a3,a5,a3
40000ad0:	01c5d8b3          	srl	a7,a1,t3
40000ad4:	0106d713          	srli	a4,a3,0x10
40000ad8:	02e8deb3          	divu	t4,a7,a4
40000adc:	01069f13          	slli	t5,a3,0x10
40000ae0:	01c557b3          	srl	a5,a0,t3
40000ae4:	010f5f13          	srli	t5,t5,0x10
40000ae8:	006595b3          	sll	a1,a1,t1
40000aec:	00b7e5b3          	or	a1,a5,a1
40000af0:	0105d813          	srli	a6,a1,0x10
40000af4:	00661633          	sll	a2,a2,t1
40000af8:	00651533          	sll	a0,a0,t1
40000afc:	02e8f8b3          	remu	a7,a7,a4
40000b00:	03df07b3          	mul	a5,t5,t4
40000b04:	01089893          	slli	a7,a7,0x10
40000b08:	0108e833          	or	a6,a7,a6
40000b0c:	00f87e63          	bgeu	a6,a5,40000b28 <__umoddi3+0x32c>
40000b10:	00d80833          	add	a6,a6,a3
40000b14:	fffe8893          	addi	a7,t4,-1
40000b18:	12d86a63          	bltu	a6,a3,40000c4c <__umoddi3+0x450>
40000b1c:	12f87863          	bgeu	a6,a5,40000c4c <__umoddi3+0x450>
40000b20:	ffee8e93          	addi	t4,t4,-2
40000b24:	00d80833          	add	a6,a6,a3
40000b28:	40f80833          	sub	a6,a6,a5
40000b2c:	02e857b3          	divu	a5,a6,a4
40000b30:	01059593          	slli	a1,a1,0x10
40000b34:	0105d593          	srli	a1,a1,0x10
40000b38:	02e87833          	remu	a6,a6,a4
40000b3c:	02ff0f33          	mul	t5,t5,a5
40000b40:	01081713          	slli	a4,a6,0x10
40000b44:	00b76733          	or	a4,a4,a1
40000b48:	01e77e63          	bgeu	a4,t5,40000b64 <__umoddi3+0x368>
40000b4c:	00d70733          	add	a4,a4,a3
40000b50:	fff78593          	addi	a1,a5,-1 # ffffff <CONFIG_SRAM_SIZE+0xfbffff>
40000b54:	0ed76863          	bltu	a4,a3,40000c44 <__umoddi3+0x448>
40000b58:	0fe77663          	bgeu	a4,t5,40000c44 <__umoddi3+0x448>
40000b5c:	ffe78793          	addi	a5,a5,-2
40000b60:	00d70733          	add	a4,a4,a3
40000b64:	010e9e93          	slli	t4,t4,0x10
40000b68:	000102b7          	lui	t0,0x10
40000b6c:	00feeeb3          	or	t4,t4,a5
40000b70:	fff28813          	addi	a6,t0,-1 # ffff <__kernel_ram_size+0xe75f>
40000b74:	010ef8b3          	and	a7,t4,a6
40000b78:	01065593          	srli	a1,a2,0x10
40000b7c:	010ede93          	srli	t4,t4,0x10
40000b80:	01067833          	and	a6,a2,a6
40000b84:	03088fb3          	mul	t6,a7,a6
40000b88:	41e70733          	sub	a4,a4,t5
40000b8c:	030e8833          	mul	a6,t4,a6
40000b90:	010fd793          	srli	a5,t6,0x10
40000b94:	02b888b3          	mul	a7,a7,a1
40000b98:	010888b3          	add	a7,a7,a6
40000b9c:	011787b3          	add	a5,a5,a7
40000ba0:	02be8eb3          	mul	t4,t4,a1
40000ba4:	0107f463          	bgeu	a5,a6,40000bac <__umoddi3+0x3b0>
40000ba8:	005e8eb3          	add	t4,t4,t0
40000bac:	00010837          	lui	a6,0x10
40000bb0:	fff80813          	addi	a6,a6,-1 # ffff <__kernel_ram_size+0xe75f>
40000bb4:	0107d593          	srli	a1,a5,0x10
40000bb8:	0107f7b3          	and	a5,a5,a6
40000bbc:	01079793          	slli	a5,a5,0x10
40000bc0:	010fffb3          	and	t6,t6,a6
40000bc4:	01d585b3          	add	a1,a1,t4
40000bc8:	01f787b3          	add	a5,a5,t6
40000bcc:	02b76863          	bltu	a4,a1,40000bfc <__umoddi3+0x400>
40000bd0:	02b70463          	beq	a4,a1,40000bf8 <__umoddi3+0x3fc>
40000bd4:	40f507b3          	sub	a5,a0,a5
40000bd8:	00f53533          	sltu	a0,a0,a5
40000bdc:	40b705b3          	sub	a1,a4,a1
40000be0:	40a585b3          	sub	a1,a1,a0
40000be4:	01c59e33          	sll	t3,a1,t3
40000be8:	0067d533          	srl	a0,a5,t1
40000bec:	00ae6533          	or	a0,t3,a0
40000bf0:	0065d5b3          	srl	a1,a1,t1
40000bf4:	00008067          	ret
40000bf8:	fcf57ee3          	bgeu	a0,a5,40000bd4 <__umoddi3+0x3d8>
40000bfc:	40c78633          	sub	a2,a5,a2
40000c00:	00c7b7b3          	sltu	a5,a5,a2
40000c04:	00d787b3          	add	a5,a5,a3
40000c08:	40f585b3          	sub	a1,a1,a5
40000c0c:	00060793          	mv	a5,a2
40000c10:	fc5ff06f          	j	40000bd4 <__umoddi3+0x3d8>
40000c14:	01085693          	srli	a3,a6,0x10
40000c18:	01000793          	li	a5,16
40000c1c:	d3dff06f          	j	40000958 <__umoddi3+0x15c>
40000c20:	0106d313          	srli	t1,a3,0x10
40000c24:	01000893          	li	a7,16
40000c28:	cc9ff06f          	j	400008f0 <__umoddi3+0xf4>
40000c2c:	01065693          	srli	a3,a2,0x10
40000c30:	01000793          	li	a5,16
40000c34:	bfdff06f          	j	40000830 <__umoddi3+0x34>
40000c38:	00068313          	mv	t1,a3
40000c3c:	00000893          	li	a7,0
40000c40:	cb1ff06f          	j	400008f0 <__umoddi3+0xf4>
40000c44:	00058793          	mv	a5,a1
40000c48:	f1dff06f          	j	40000b64 <__umoddi3+0x368>
40000c4c:	00088e93          	mv	t4,a7
40000c50:	ed9ff06f          	j	40000b28 <__umoddi3+0x32c>
40000c54:	01070733          	add	a4,a4,a6
40000c58:	d59ff06f          	j	400009b0 <__umoddi3+0x1b4>

40000c5c <_ZN13cpp_semaphoreD1Ev>:
class cpp_semaphore: public semaphore {
protected:
	struct k_sem _sema_internal;
public:
	cpp_semaphore();
	virtual ~cpp_semaphore() {}
40000c5c:	00008067          	ret

40000c60 <_ZN13cpp_semaphore4waitEv>:
 * count is greater than zero, it is decremented.
 *
 * @return 1 when semaphore is available
 */
int cpp_semaphore::wait(void)
{
40000c60:	ff010113          	addi	sp,sp,-16
40000c64:	00112623          	sw	ra,12(sp)
		parm0.val = timeout;
		return (int) arch_syscall_invoke3(*(uintptr_t *)&sem, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_SEM_TAKE);
	}
#endif
	compiler_barrier();
	return z_impl_k_sem_take(sem, timeout);
40000c68:	fff00593          	li	a1,-1
40000c6c:	fff00613          	li	a2,-1
40000c70:	00450513          	addi	a0,a0,4
40000c74:	2d5020ef          	jal	ra,40003748 <z_impl_k_sem_take>
	k_sem_take(&_sema_internal, K_FOREVER);
	return 1;
}
40000c78:	00c12083          	lw	ra,12(sp)
40000c7c:	00100513          	li	a0,1
40000c80:	01010113          	addi	sp,sp,16
40000c84:	00008067          	ret

40000c88 <_ZN13cpp_semaphore4giveEv>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
40000c88:	00450513          	addi	a0,a0,4
40000c8c:	2510206f          	j	400036dc <z_impl_k_sem_give>

40000c90 <_ZN13cpp_semaphoreD0Ev>:
	virtual ~cpp_semaphore() {}
40000c90:	69c0106f          	j	4000232c <_ZdlPv>

40000c94 <_ZN13cpp_semaphore4waitEi>:
 *
 * @return 1 if semaphore is available, 0 if timed out
 */
int cpp_semaphore::wait(int timeout)
{
	return k_sem_take(&_sema_internal, K_MSEC(timeout));
40000c94:	0005d463          	bgez	a1,40000c9c <_ZN13cpp_semaphore4waitEi+0x8>
40000c98:	00000593          	li	a1,0
40000c9c:	41f5d613          	srai	a2,a1,0x1f
	return z_impl_k_sem_take(sem, timeout);
40000ca0:	00450513          	addi	a0,a0,4
40000ca4:	2a50206f          	j	40003748 <z_impl_k_sem_take>

40000ca8 <_Z17coop_thread_entryv>:

cpp_semaphore sem_main;
cpp_semaphore sem_coop;

void coop_thread_entry(void)
{
40000ca8:	fa010113          	addi	sp,sp,-96
40000cac:	04812c23          	sw	s0,88(sp)
40000cb0:	05212823          	sw	s2,80(sp)
	struct k_timer timer;

	k_timer_init(&timer, NULL, NULL);
40000cb4:	00000613          	li	a2,0
40000cb8:	00000593          	li	a1,0
40000cbc:	00810513          	addi	a0,sp,8
	z_impl_k_timer_start(timer, duration, period);
40000cc0:	00001937          	lui	s2,0x1
	z_impl_k_sem_give(sem);
40000cc4:	40004437          	lui	s0,0x40004
{
40000cc8:	04912a23          	sw	s1,84(sp)
40000ccc:	05312623          	sw	s3,76(sp)
40000cd0:	05412423          	sw	s4,72(sp)
40000cd4:	05512223          	sw	s5,68(sp)
40000cd8:	04112e23          	sw	ra,92(sp)

	while (1) {
		/* wait for main thread to let us have a turn */
		sem_coop.wait();
40000cdc:	40004ab7          	lui	s5,0x40004
	k_timer_init(&timer, NULL, NULL);
40000ce0:	2b8030ef          	jal	ra,40003f98 <k_timer_init>

		/* say "hello" */
		printk("%s: Hello World!\n", __FUNCTION__);
40000ce4:	40004a37          	lui	s4,0x40004
40000ce8:	400044b7          	lui	s1,0x40004
	z_impl_k_timer_start(timer, duration, period);
40000cec:	57c90913          	addi	s2,s2,1404 # 157c <CONFIG_HEAP_MEM_POOL_SIZE+0x57c>
40000cf0:	00000993          	li	s3,0
	z_impl_k_sem_give(sem);
40000cf4:	76840413          	addi	s0,s0,1896 # 40004768 <sem_main+0x4>
		sem_coop.wait();
40000cf8:	750a8513          	addi	a0,s5,1872 # 40004750 <sem_coop>
40000cfc:	f65ff0ef          	jal	ra,40000c60 <_ZN13cpp_semaphore4waitEv>
		printk("%s: Hello World!\n", __FUNCTION__);
40000d00:	3a4a0593          	addi	a1,s4,932 # 400043a4 <__clz_tab+0x100>
40000d04:	3b848513          	addi	a0,s1,952 # 400043b8 <__clz_tab+0x114>
40000d08:	218000ef          	jal	ra,40000f20 <printk>
	z_impl_k_timer_start(timer, duration, period);
40000d0c:	00000693          	li	a3,0
40000d10:	00000713          	li	a4,0
40000d14:	00090593          	mv	a1,s2
40000d18:	00098613          	mv	a2,s3
40000d1c:	00810513          	addi	a0,sp,8
40000d20:	2a0030ef          	jal	ra,40003fc0 <z_impl_k_timer_start>
	return z_impl_k_timer_status_sync(timer);
40000d24:	00810513          	addi	a0,sp,8
40000d28:	3a4030ef          	jal	ra,400040cc <z_impl_k_timer_status_sync>
	z_impl_k_sem_give(sem);
40000d2c:	00040513          	mv	a0,s0
40000d30:	1ad020ef          	jal	ra,400036dc <z_impl_k_sem_give>
40000d34:	fc5ff06f          	j	40000cf8 <_Z17coop_thread_entryv+0x50>

40000d38 <_ZN13cpp_semaphoreC1Ev>:
cpp_semaphore::cpp_semaphore()
40000d38:	ff010113          	addi	sp,sp,-16
40000d3c:	400047b7          	lui	a5,0x40004
40000d40:	00812423          	sw	s0,8(sp)
40000d44:	00112623          	sw	ra,12(sp)
40000d48:	3f478793          	addi	a5,a5,1012 # 400043f4 <_ZTV13cpp_semaphore+0x8>
40000d4c:	00f52023          	sw	a5,0(a0)
	printk("Create semaphore %p\n", this);
40000d50:	00050593          	mv	a1,a0
cpp_semaphore::cpp_semaphore()
40000d54:	00050413          	mv	s0,a0
	printk("Create semaphore %p\n", this);
40000d58:	40004537          	lui	a0,0x40004
40000d5c:	3cc50513          	addi	a0,a0,972 # 400043cc <__clz_tab+0x128>
40000d60:	1c0000ef          	jal	ra,40000f20 <printk>
	return z_impl_k_sem_init(sem, initial_count, limit);
40000d64:	00440513          	addi	a0,s0,4
}
40000d68:	00812403          	lw	s0,8(sp)
40000d6c:	00c12083          	lw	ra,12(sp)
40000d70:	fff00613          	li	a2,-1
40000d74:	00000593          	li	a1,0
40000d78:	01010113          	addi	sp,sp,16
40000d7c:	1350206f          	j	400036b0 <z_impl_k_sem_init>

40000d80 <main>:
		sem_main.give();
	}
}

void main(void)
{
40000d80:	f9010113          	addi	sp,sp,-112
40000d84:	06112623          	sw	ra,108(sp)
40000d88:	06812423          	sw	s0,104(sp)
40000d8c:	06912223          	sw	s1,100(sp)
40000d90:	07212023          	sw	s2,96(sp)
40000d94:	05312e23          	sw	s3,92(sp)
40000d98:	05412c23          	sw	s4,88(sp)
40000d9c:	05512a23          	sw	s5,84(sp)
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
40000da0:	00000793          	li	a5,0
40000da4:	00000813          	li	a6,0
40000da8:	400016b7          	lui	a3,0x40001
40000dac:	400045b7          	lui	a1,0x40004
40000db0:	40004537          	lui	a0,0x40004
40000db4:	00f12423          	sw	a5,8(sp)
40000db8:	01012623          	sw	a6,12(sp)
40000dbc:	ff700893          	li	a7,-9
40000dc0:	00000813          	li	a6,0
40000dc4:	00000713          	li	a4,0
40000dc8:	ca868693          	addi	a3,a3,-856 # 40000ca8 <_Z17coop_thread_entryv>
40000dcc:	7d000613          	li	a2,2000
40000dd0:	7b058593          	addi	a1,a1,1968 # 400047b0 <coop_stack>
40000dd4:	00012023          	sw	zero,0(sp)
40000dd8:	5d050513          	addi	a0,a0,1488 # 400045d0 <coop_thread>
40000ddc:	245020ef          	jal	ra,40003820 <z_impl_k_thread_create>
	struct k_timer timer;

	k_thread_create(&coop_thread, coop_stack, STACKSIZE,
			(k_thread_entry_t) coop_thread_entry,
			NULL, NULL, NULL, K_PRIO_COOP(7), 0, K_NO_WAIT);
	k_timer_init(&timer, NULL, NULL);
40000de0:	00000613          	li	a2,0
40000de4:	00000593          	li	a1,0
40000de8:	01810513          	addi	a0,sp,24
	z_impl_k_timer_start(timer, duration, period);
40000dec:	00001a37          	lui	s4,0x1
	z_impl_k_sem_give(sem);
40000df0:	40004437          	lui	s0,0x40004
40000df4:	1a4030ef          	jal	ra,40003f98 <k_timer_init>

	while (1) {
		/* say "hello" */
		printk("%s: Hello World!\n", __FUNCTION__);
40000df8:	40004937          	lui	s2,0x40004
40000dfc:	400044b7          	lui	s1,0x40004
	z_impl_k_timer_start(timer, duration, period);
40000e00:	57ca0a13          	addi	s4,s4,1404 # 157c <CONFIG_HEAP_MEM_POOL_SIZE+0x57c>
40000e04:	00000a93          	li	s5,0
	z_impl_k_sem_give(sem);
40000e08:	75440413          	addi	s0,s0,1876 # 40004754 <sem_coop+0x4>
		printk("%s: Hello World!\n", __FUNCTION__);
		k_timer_status_sync(&timer);
		sem_coop.give();

		/* Wait for coop thread to let us have a turn */
		sem_main.wait();
40000e0c:	400049b7          	lui	s3,0x40004
		printk("%s: Hello World!\n", __FUNCTION__);
40000e10:	3e490593          	addi	a1,s2,996 # 400043e4 <__clz_tab+0x140>
40000e14:	3b848513          	addi	a0,s1,952 # 400043b8 <__clz_tab+0x114>
40000e18:	108000ef          	jal	ra,40000f20 <printk>
	z_impl_k_timer_start(timer, duration, period);
40000e1c:	00000693          	li	a3,0
40000e20:	00000713          	li	a4,0
40000e24:	000a0593          	mv	a1,s4
40000e28:	000a8613          	mv	a2,s5
40000e2c:	01810513          	addi	a0,sp,24
40000e30:	190030ef          	jal	ra,40003fc0 <z_impl_k_timer_start>
		printk("%s: Hello World!\n", __FUNCTION__);
40000e34:	3e490593          	addi	a1,s2,996
40000e38:	3b848513          	addi	a0,s1,952
40000e3c:	0e4000ef          	jal	ra,40000f20 <printk>
	return z_impl_k_timer_status_sync(timer);
40000e40:	01810513          	addi	a0,sp,24
40000e44:	288030ef          	jal	ra,400040cc <z_impl_k_timer_status_sync>
	z_impl_k_sem_give(sem);
40000e48:	00040513          	mv	a0,s0
40000e4c:	091020ef          	jal	ra,400036dc <z_impl_k_sem_give>
		sem_main.wait();
40000e50:	76498513          	addi	a0,s3,1892 # 40004764 <sem_main>
40000e54:	e0dff0ef          	jal	ra,40000c60 <_ZN13cpp_semaphore4waitEv>
	while (1) {
40000e58:	fb9ff06f          	j	40000e10 <main+0x90>

40000e5c <_GLOBAL__sub_I_coop_thread>:
	}
}
40000e5c:	ff010113          	addi	sp,sp,-16
40000e60:	00812423          	sw	s0,8(sp)
cpp_semaphore sem_main;
40000e64:	40004437          	lui	s0,0x40004
40000e68:	76440513          	addi	a0,s0,1892 # 40004764 <sem_main>
}
40000e6c:	00112623          	sw	ra,12(sp)
40000e70:	00912223          	sw	s1,4(sp)
40000e74:	01212023          	sw	s2,0(sp)
cpp_semaphore sem_main;
40000e78:	ec1ff0ef          	jal	ra,40000d38 <_ZN13cpp_semaphoreC1Ev>
40000e7c:	76440593          	addi	a1,s0,1892
40000e80:	40004937          	lui	s2,0x40004
40000e84:	40001437          	lui	s0,0x40001
40000e88:	5b090613          	addi	a2,s2,1456 # 400045b0 <__dso_handle>
40000e8c:	c5c40513          	addi	a0,s0,-932 # 40000c5c <_ZN13cpp_semaphoreD1Ev>
40000e90:	494010ef          	jal	ra,40002324 <__cxa_atexit>
cpp_semaphore sem_coop;
40000e94:	400044b7          	lui	s1,0x40004
40000e98:	75048513          	addi	a0,s1,1872 # 40004750 <sem_coop>
40000e9c:	e9dff0ef          	jal	ra,40000d38 <_ZN13cpp_semaphoreC1Ev>
40000ea0:	c5c40513          	addi	a0,s0,-932
}
40000ea4:	00812403          	lw	s0,8(sp)
40000ea8:	00c12083          	lw	ra,12(sp)
cpp_semaphore sem_coop;
40000eac:	5b090613          	addi	a2,s2,1456
40000eb0:	75048593          	addi	a1,s1,1872
}
40000eb4:	00012903          	lw	s2,0(sp)
40000eb8:	00412483          	lw	s1,4(sp)
40000ebc:	01010113          	addi	sp,sp,16
cpp_semaphore sem_coop;
40000ec0:	4640106f          	j	40002324 <__cxa_atexit>

40000ec4 <arch_printk_char_out>:
{
	ARG_UNUSED(c);

	/* do nothing */
	return 0;
}
40000ec4:	00000513          	li	a0,0
40000ec8:	00008067          	ret

40000ecc <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
40000ecc:	0005a783          	lw	a5,0(a1)
40000ed0:	00178793          	addi	a5,a5,1
40000ed4:	00f5a023          	sw	a5,0(a1)
	return _char_out(c);
40000ed8:	400067b7          	lui	a5,0x40006
40000edc:	e0c7a783          	lw	a5,-500(a5) # 40005e0c <_char_out>
40000ee0:	00078067          	jr	a5

40000ee4 <__printk_hook_install>:
	_char_out = fn;
40000ee4:	400067b7          	lui	a5,0x40006
40000ee8:	e0a7a623          	sw	a0,-500(a5) # 40005e0c <_char_out>
}
40000eec:	00008067          	ret

40000ef0 <vprintk>:
#endif
	}
}
#else
void vprintk(const char *fmt, va_list ap)
{
40000ef0:	fe010113          	addi	sp,sp,-32
40000ef4:	00050613          	mv	a2,a0
	struct out_context ctx = { 0 };
#ifdef CONFIG_PRINTK_SYNC
	k_spinlock_key_t key = k_spin_lock(&lock);
#endif

	cbvprintf(char_out, &ctx, fmt, ap);
40000ef8:	40001537          	lui	a0,0x40001
{
40000efc:	00058693          	mv	a3,a1
	cbvprintf(char_out, &ctx, fmt, ap);
40000f00:	ecc50513          	addi	a0,a0,-308 # 40000ecc <char_out>
40000f04:	00c10593          	addi	a1,sp,12
{
40000f08:	00112e23          	sw	ra,28(sp)
	struct out_context ctx = { 0 };
40000f0c:	00012623          	sw	zero,12(sp)
	cbvprintf(char_out, &ctx, fmt, ap);
40000f10:	4ed000ef          	jal	ra,40001bfc <cbvprintf>

#ifdef CONFIG_PRINTK_SYNC
	k_spin_unlock(&lock, key);
#endif
}
40000f14:	01c12083          	lw	ra,28(sp)
40000f18:	02010113          	addi	sp,sp,32
40000f1c:	00008067          	ret

40000f20 <printk>:
 * @param fmt formatted string to output
 *
 * @return N/A
 */
void printk(const char *fmt, ...)
{
40000f20:	fc010113          	addi	sp,sp,-64
40000f24:	02b12223          	sw	a1,36(sp)
	va_list ap;

	va_start(ap, fmt);
40000f28:	02410593          	addi	a1,sp,36
{
40000f2c:	00112e23          	sw	ra,28(sp)
40000f30:	02c12423          	sw	a2,40(sp)
40000f34:	02d12623          	sw	a3,44(sp)
40000f38:	02e12823          	sw	a4,48(sp)
40000f3c:	02f12a23          	sw	a5,52(sp)
40000f40:	03012c23          	sw	a6,56(sp)
40000f44:	03112e23          	sw	a7,60(sp)
	va_start(ap, fmt);
40000f48:	00b12623          	sw	a1,12(sp)

	if (IS_ENABLED(CONFIG_LOG_PRINTK)) {
		log_printk(fmt, ap);
	} else {
		vprintk(fmt, ap);
40000f4c:	fa5ff0ef          	jal	ra,40000ef0 <vprintk>
	}
	va_end(ap);
}
40000f50:	01c12083          	lw	ra,28(sp)
40000f54:	04010113          	addi	sp,sp,64
40000f58:	00008067          	ret

40000f5c <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
40000f5c:	ff010113          	addi	sp,sp,-16
40000f60:	00050793          	mv	a5,a0
40000f64:	00058513          	mv	a0,a1
40000f68:	00060593          	mv	a1,a2
	entry(p1, p2, p3);
40000f6c:	00068613          	mv	a2,a3
{
40000f70:	00112623          	sw	ra,12(sp)
	entry(p1, p2, p3);
40000f74:	000780e7          	jalr	a5
	return z_impl_k_current_get();
40000f78:	72c020ef          	jal	ra,400036a4 <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
40000f7c:	22d020ef          	jal	ra,400039a8 <z_impl_k_thread_abort>

40000f80 <chunk_field>:
				 enum chunk_fields f)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
40000f80:	00852703          	lw	a4,8(a0)
	void *cmem = &buf[c];
40000f84:	00359593          	slli	a1,a1,0x3
	if (big_heap(h)) {
40000f88:	000087b7          	lui	a5,0x8
	void *cmem = &buf[c];
40000f8c:	00b505b3          	add	a1,a0,a1
	if (big_heap(h)) {
40000f90:	00f76a63          	bltu	a4,a5,40000fa4 <chunk_field+0x24>
		return ((uint32_t *)cmem)[f];
40000f94:	00261613          	slli	a2,a2,0x2
40000f98:	00c585b3          	add	a1,a1,a2
40000f9c:	0005a503          	lw	a0,0(a1)
40000fa0:	00008067          	ret
	} else {
		return ((uint16_t *)cmem)[f];
40000fa4:	00161613          	slli	a2,a2,0x1
40000fa8:	00c585b3          	add	a1,a1,a2
40000fac:	0005d503          	lhu	a0,0(a1)
	}
}
40000fb0:	00008067          	ret

40000fb4 <chunk_set>:
	CHECK(c <= h->len);

	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
40000fb4:	00852703          	lw	a4,8(a0)
	void *cmem = &buf[c];
40000fb8:	00359593          	slli	a1,a1,0x3
	if (big_heap(h)) {
40000fbc:	000087b7          	lui	a5,0x8
	void *cmem = &buf[c];
40000fc0:	00b505b3          	add	a1,a0,a1
	if (big_heap(h)) {
40000fc4:	00f76a63          	bltu	a4,a5,40000fd8 <chunk_set+0x24>
		CHECK(val == (uint32_t)val);
		((uint32_t *)cmem)[f] = val;
40000fc8:	00261613          	slli	a2,a2,0x2
40000fcc:	00c585b3          	add	a1,a1,a2
40000fd0:	00d5a023          	sw	a3,0(a1)
40000fd4:	00008067          	ret
	} else {
		CHECK(val == (uint16_t)val);
		((uint16_t *)cmem)[f] = val;
40000fd8:	00161613          	slli	a2,a2,0x1
40000fdc:	00c585b3          	add	a1,a1,a2
40000fe0:	00d59023          	sh	a3,0(a1)
	}
}
40000fe4:	00008067          	ret

40000fe8 <chunk_size>:
{
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
}

static inline size_t chunk_size(struct z_heap *h, chunkid_t c)
{
40000fe8:	ff010113          	addi	sp,sp,-16
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
40000fec:	00100613          	li	a2,1
{
40000ff0:	00112623          	sw	ra,12(sp)
	return chunk_field(h, c, SIZE_AND_USED) >> 1;
40000ff4:	f8dff0ef          	jal	ra,40000f80 <chunk_field>
}
40000ff8:	00c12083          	lw	ra,12(sp)
40000ffc:	00155513          	srli	a0,a0,0x1
40001000:	01010113          	addi	sp,sp,16
40001004:	00008067          	ret

40001008 <set_chunk_used>:
static inline void set_chunk_used(struct z_heap *h, chunkid_t c, bool used)
{
	chunk_unit_t *buf = chunk_buf(h);
	void *cmem = &buf[c];

	if (big_heap(h)) {
40001008:	00852703          	lw	a4,8(a0)
	void *cmem = &buf[c];
4000100c:	00359593          	slli	a1,a1,0x3
	if (big_heap(h)) {
40001010:	000087b7          	lui	a5,0x8
	void *cmem = &buf[c];
40001014:	00b505b3          	add	a1,a0,a1
	if (big_heap(h)) {
40001018:	02f76063          	bltu	a4,a5,40001038 <set_chunk_used+0x30>
		if (used) {
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
4000101c:	0045a783          	lw	a5,4(a1)
		if (used) {
40001020:	00060863          	beqz	a2,40001030 <set_chunk_used+0x28>
			((uint32_t *)cmem)[SIZE_AND_USED] |= 1U;
40001024:	0017e793          	ori	a5,a5,1
		} else {
			((uint32_t *)cmem)[SIZE_AND_USED] &= ~1U;
40001028:	00f5a223          	sw	a5,4(a1)
4000102c:	00008067          	ret
40001030:	ffe7f793          	andi	a5,a5,-2
40001034:	ff5ff06f          	j	40001028 <set_chunk_used+0x20>
		}
	} else {
		if (used) {
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
40001038:	0025d783          	lhu	a5,2(a1)
		if (used) {
4000103c:	00060863          	beqz	a2,4000104c <set_chunk_used+0x44>
			((uint16_t *)cmem)[SIZE_AND_USED] |= 1U;
40001040:	0017e793          	ori	a5,a5,1
		} else {
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
40001044:	00f59123          	sh	a5,2(a1)
		}
	}
}
40001048:	00008067          	ret
			((uint16_t *)cmem)[SIZE_AND_USED] &= ~1U;
4000104c:	ffe7f793          	andi	a5,a5,-2
40001050:	ff5ff06f          	j	40001044 <set_chunk_used+0x3c>

40001054 <set_chunk_size>:
 * when its size is modified, and potential set_chunk_used() is always
 * invoked after set_chunk_size().
 */
static inline void set_chunk_size(struct z_heap *h, chunkid_t c, size_t size)
{
	chunk_set(h, c, SIZE_AND_USED, size << 1);
40001054:	00161693          	slli	a3,a2,0x1
40001058:	00100613          	li	a2,1
4000105c:	f59ff06f          	j	40000fb4 <chunk_set>

40001060 <bucket_idx.isra.0>:
static inline int min_chunk_size(struct z_heap *h)
{
	return bytes_to_chunksz(h, 1);
}

static inline int bucket_idx(struct z_heap *h, size_t sz)
40001060:	ff010113          	addi	sp,sp,-16
40001064:	00112623          	sw	ra,12(sp)
	return big_heap(h) ? 8 : 4;
40001068:	000087b7          	lui	a5,0x8
4000106c:	02f57863          	bgeu	a0,a5,4000109c <bucket_idx.isra.0+0x3c>
40001070:	00400793          	li	a5,4
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
40001074:	00878793          	addi	a5,a5,8 # 8008 <__kernel_ram_size+0x6768>
40001078:	0037d793          	srli	a5,a5,0x3
{
	size_t usable_sz = sz - min_chunk_size(h) + 1;
4000107c:	00158593          	addi	a1,a1,1
	return 31 - __builtin_clz(usable_sz);
40001080:	40f58533          	sub	a0,a1,a5
40001084:	a44ff0ef          	jal	ra,400002c8 <__clzsi2>
}
40001088:	00c12083          	lw	ra,12(sp)
4000108c:	01f00793          	li	a5,31
40001090:	40a78533          	sub	a0,a5,a0
40001094:	01010113          	addi	sp,sp,16
40001098:	00008067          	ret
	return big_heap(h) ? 8 : 4;
4000109c:	00800793          	li	a5,8
400010a0:	fd5ff06f          	j	40001074 <bucket_idx.isra.0+0x14>

400010a4 <free_list_remove_bidx>:

	return ret;
}

static void free_list_remove_bidx(struct z_heap *h, chunkid_t c, int bidx)
{
400010a4:	fe010113          	addi	sp,sp,-32
400010a8:	01412423          	sw	s4,8(sp)
400010ac:	00060a13          	mv	s4,a2
	return chunk_field(h, c, FREE_NEXT);
400010b0:	00300613          	li	a2,3
400010b4:	00812c23          	sw	s0,24(sp)
400010b8:	00912a23          	sw	s1,20(sp)
400010bc:	01312623          	sw	s3,12(sp)
400010c0:	00112e23          	sw	ra,28(sp)
400010c4:	01212823          	sw	s2,16(sp)
400010c8:	00050413          	mv	s0,a0
400010cc:	00058993          	mv	s3,a1
400010d0:	eb1ff0ef          	jal	ra,40000f80 <chunk_field>
400010d4:	004a0493          	addi	s1,s4,4

	CHECK(!chunk_used(h, c));
	CHECK(b->next != 0);
	CHECK(h->avail_buckets & (1 << bidx));

	if (next_free_chunk(h, c) == c) {
400010d8:	04a99463          	bne	s3,a0,40001120 <free_list_remove_bidx+0x7c>
		/* this is the last chunk */
		h->avail_buckets &= ~(1 << bidx);
400010dc:	00100793          	li	a5,1
400010e0:	01479633          	sll	a2,a5,s4
400010e4:	00c42783          	lw	a5,12(s0)
400010e8:	fff64613          	not	a2,a2
		b->next = 0;
400010ec:	00249493          	slli	s1,s1,0x2
		h->avail_buckets &= ~(1 << bidx);
400010f0:	00c7f633          	and	a2,a5,a2
400010f4:	00c42623          	sw	a2,12(s0)
		b->next = 0;
400010f8:	00940433          	add	s0,s0,s1

		b->next = second;
		set_next_free_chunk(h, first, second);
		set_prev_free_chunk(h, second, first);
	}
}
400010fc:	01c12083          	lw	ra,28(sp)
		b->next = 0;
40001100:	00042023          	sw	zero,0(s0)
}
40001104:	01812403          	lw	s0,24(sp)
40001108:	01412483          	lw	s1,20(sp)
4000110c:	01012903          	lw	s2,16(sp)
40001110:	00c12983          	lw	s3,12(sp)
40001114:	00812a03          	lw	s4,8(sp)
40001118:	02010113          	addi	sp,sp,32
4000111c:	00008067          	ret
40001120:	00050913          	mv	s2,a0
	return chunk_field(h, c, FREE_PREV);
40001124:	00098593          	mv	a1,s3
40001128:	00200613          	li	a2,2
4000112c:	00040513          	mv	a0,s0
		b->next = second;
40001130:	00249493          	slli	s1,s1,0x2
40001134:	e4dff0ef          	jal	ra,40000f80 <chunk_field>
40001138:	009404b3          	add	s1,s0,s1
4000113c:	00050993          	mv	s3,a0
40001140:	0124a023          	sw	s2,0(s1)
	chunk_set(h, c, FREE_NEXT, next);
40001144:	00090693          	mv	a3,s2
40001148:	00050593          	mv	a1,a0
4000114c:	00300613          	li	a2,3
40001150:	00040513          	mv	a0,s0
40001154:	e61ff0ef          	jal	ra,40000fb4 <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
40001158:	00040513          	mv	a0,s0
}
4000115c:	01812403          	lw	s0,24(sp)
40001160:	01c12083          	lw	ra,28(sp)
40001164:	01412483          	lw	s1,20(sp)
40001168:	00812a03          	lw	s4,8(sp)
4000116c:	00098693          	mv	a3,s3
40001170:	00090593          	mv	a1,s2
40001174:	00c12983          	lw	s3,12(sp)
40001178:	01012903          	lw	s2,16(sp)
4000117c:	00200613          	li	a2,2
40001180:	02010113          	addi	sp,sp,32
40001184:	e31ff06f          	j	40000fb4 <chunk_set>

40001188 <free_list_remove>:

static void free_list_remove(struct z_heap *h, chunkid_t c)
{
40001188:	ff010113          	addi	sp,sp,-16
4000118c:	01212023          	sw	s2,0(sp)
	return big_heap_chunks(h->len);
40001190:	00852903          	lw	s2,8(a0)
40001194:	00812423          	sw	s0,8(sp)
40001198:	00912223          	sw	s1,4(sp)
4000119c:	00112623          	sw	ra,12(sp)
400011a0:	00058493          	mv	s1,a1
400011a4:	00050413          	mv	s0,a0
	return big_heap(h) && chunk_size(h, c) == 1U;
400011a8:	e41ff0ef          	jal	ra,40000fe8 <chunk_size>
400011ac:	000087b7          	lui	a5,0x8
400011b0:	00050593          	mv	a1,a0
400011b4:	00f96663          	bltu	s2,a5,400011c0 <free_list_remove+0x38>
	if (!solo_free_header(h, c)) {
400011b8:	00100793          	li	a5,1
400011bc:	02f50863          	beq	a0,a5,400011ec <free_list_remove+0x64>
		int bidx = bucket_idx(h, chunk_size(h, c));
400011c0:	00090513          	mv	a0,s2
400011c4:	e9dff0ef          	jal	ra,40001060 <bucket_idx.isra.0>
400011c8:	00050613          	mv	a2,a0
		free_list_remove_bidx(h, c, bidx);
400011cc:	00040513          	mv	a0,s0
	}
}
400011d0:	00812403          	lw	s0,8(sp)
400011d4:	00c12083          	lw	ra,12(sp)
400011d8:	00012903          	lw	s2,0(sp)
		free_list_remove_bidx(h, c, bidx);
400011dc:	00048593          	mv	a1,s1
}
400011e0:	00412483          	lw	s1,4(sp)
400011e4:	01010113          	addi	sp,sp,16
		free_list_remove_bidx(h, c, bidx);
400011e8:	ebdff06f          	j	400010a4 <free_list_remove_bidx>
}
400011ec:	00c12083          	lw	ra,12(sp)
400011f0:	00812403          	lw	s0,8(sp)
400011f4:	00412483          	lw	s1,4(sp)
400011f8:	00012903          	lw	s2,0(sp)
400011fc:	01010113          	addi	sp,sp,16
40001200:	00008067          	ret

40001204 <merge_chunks>:
	set_left_chunk_size(h, right_chunk(h, rc), rsz);
}

/* Does not modify free list */
static void merge_chunks(struct z_heap *h, chunkid_t lc, chunkid_t rc)
{
40001204:	fe010113          	addi	sp,sp,-32
40001208:	00112e23          	sw	ra,28(sp)
4000120c:	00812c23          	sw	s0,24(sp)
40001210:	00912a23          	sw	s1,20(sp)
40001214:	01212823          	sw	s2,16(sp)
40001218:	01312623          	sw	s3,12(sp)
4000121c:	00060913          	mv	s2,a2
40001220:	00050413          	mv	s0,a0
40001224:	00058993          	mv	s3,a1
	size_t newsz = chunk_size(h, lc) + chunk_size(h, rc);
40001228:	dc1ff0ef          	jal	ra,40000fe8 <chunk_size>
4000122c:	00090593          	mv	a1,s2
40001230:	00050493          	mv	s1,a0
40001234:	00040513          	mv	a0,s0
40001238:	db1ff0ef          	jal	ra,40000fe8 <chunk_size>
4000123c:	00a484b3          	add	s1,s1,a0

	set_chunk_size(h, lc, newsz);
40001240:	00048613          	mv	a2,s1
40001244:	00098593          	mv	a1,s3
40001248:	00040513          	mv	a0,s0
4000124c:	e09ff0ef          	jal	ra,40001054 <set_chunk_size>
	return c + chunk_size(h, c);
40001250:	00090593          	mv	a1,s2
40001254:	00040513          	mv	a0,s0
40001258:	d91ff0ef          	jal	ra,40000fe8 <chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
4000125c:	00a905b3          	add	a1,s2,a0
40001260:	00040513          	mv	a0,s0
	set_left_chunk_size(h, right_chunk(h, rc), newsz);
}
40001264:	01812403          	lw	s0,24(sp)
40001268:	01c12083          	lw	ra,28(sp)
4000126c:	01012903          	lw	s2,16(sp)
40001270:	00c12983          	lw	s3,12(sp)
40001274:	00048693          	mv	a3,s1
40001278:	01412483          	lw	s1,20(sp)
4000127c:	00000613          	li	a2,0
40001280:	02010113          	addi	sp,sp,32
40001284:	d31ff06f          	j	40000fb4 <chunk_set>

40001288 <free_list_add>:
{
40001288:	fe010113          	addi	sp,sp,-32
4000128c:	01212823          	sw	s2,16(sp)
	return big_heap_chunks(h->len);
40001290:	00852903          	lw	s2,8(a0)
40001294:	00812c23          	sw	s0,24(sp)
40001298:	00912a23          	sw	s1,20(sp)
4000129c:	00112e23          	sw	ra,28(sp)
400012a0:	00058493          	mv	s1,a1
400012a4:	01312623          	sw	s3,12(sp)
400012a8:	00050413          	mv	s0,a0
	return big_heap(h) && chunk_size(h, c) == 1U;
400012ac:	d3dff0ef          	jal	ra,40000fe8 <chunk_size>
400012b0:	000087b7          	lui	a5,0x8
400012b4:	00050593          	mv	a1,a0
400012b8:	00f96663          	bltu	s2,a5,400012c4 <free_list_add+0x3c>
	if (!solo_free_header(h, c)) {
400012bc:	00100793          	li	a5,1
400012c0:	0cf50a63          	beq	a0,a5,40001394 <free_list_add+0x10c>
		int bidx = bucket_idx(h, chunk_size(h, c));
400012c4:	00090513          	mv	a0,s2
400012c8:	d99ff0ef          	jal	ra,40001060 <bucket_idx.isra.0>
	if (b->next == 0U) {
400012cc:	00251793          	slli	a5,a0,0x2
400012d0:	00f407b3          	add	a5,s0,a5
400012d4:	0107a903          	lw	s2,16(a5) # 8010 <__kernel_ram_size+0x6770>
400012d8:	04091e63          	bnez	s2,40001334 <free_list_add+0xac>
		h->avail_buckets |= (1 << bidx);
400012dc:	00100713          	li	a4,1
400012e0:	00a71733          	sll	a4,a4,a0
400012e4:	00c42503          	lw	a0,12(s0)
	chunk_set(h, c, FREE_PREV, prev);
400012e8:	00048693          	mv	a3,s1
400012ec:	00200613          	li	a2,2
400012f0:	00e56533          	or	a0,a0,a4
400012f4:	00a42623          	sw	a0,12(s0)
400012f8:	00048593          	mv	a1,s1
		b->next = c;
400012fc:	0097a823          	sw	s1,16(a5)
40001300:	00040513          	mv	a0,s0
40001304:	cb1ff0ef          	jal	ra,40000fb4 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
40001308:	00048693          	mv	a3,s1
4000130c:	00300613          	li	a2,3
40001310:	00048593          	mv	a1,s1
	chunk_set(h, c, FREE_PREV, prev);
40001314:	00040513          	mv	a0,s0
}
40001318:	01812403          	lw	s0,24(sp)
4000131c:	01c12083          	lw	ra,28(sp)
40001320:	01412483          	lw	s1,20(sp)
40001324:	01012903          	lw	s2,16(sp)
40001328:	00c12983          	lw	s3,12(sp)
4000132c:	02010113          	addi	sp,sp,32
40001330:	c85ff06f          	j	40000fb4 <chunk_set>
	return chunk_field(h, c, FREE_PREV);
40001334:	00200613          	li	a2,2
40001338:	00090593          	mv	a1,s2
4000133c:	00040513          	mv	a0,s0
40001340:	c41ff0ef          	jal	ra,40000f80 <chunk_field>
	chunk_set(h, c, FREE_PREV, prev);
40001344:	00050693          	mv	a3,a0
	return chunk_field(h, c, FREE_PREV);
40001348:	00050993          	mv	s3,a0
	chunk_set(h, c, FREE_PREV, prev);
4000134c:	00200613          	li	a2,2
40001350:	00048593          	mv	a1,s1
40001354:	00040513          	mv	a0,s0
40001358:	c5dff0ef          	jal	ra,40000fb4 <chunk_set>
	chunk_set(h, c, FREE_NEXT, next);
4000135c:	00090693          	mv	a3,s2
40001360:	00300613          	li	a2,3
40001364:	00048593          	mv	a1,s1
40001368:	00040513          	mv	a0,s0
4000136c:	c49ff0ef          	jal	ra,40000fb4 <chunk_set>
40001370:	00048693          	mv	a3,s1
40001374:	00300613          	li	a2,3
40001378:	00098593          	mv	a1,s3
4000137c:	00040513          	mv	a0,s0
40001380:	c35ff0ef          	jal	ra,40000fb4 <chunk_set>
	chunk_set(h, c, FREE_PREV, prev);
40001384:	00048693          	mv	a3,s1
40001388:	00200613          	li	a2,2
4000138c:	00090593          	mv	a1,s2
40001390:	f85ff06f          	j	40001314 <free_list_add+0x8c>
40001394:	01c12083          	lw	ra,28(sp)
40001398:	01812403          	lw	s0,24(sp)
4000139c:	01412483          	lw	s1,20(sp)
400013a0:	01012903          	lw	s2,16(sp)
400013a4:	00c12983          	lw	s3,12(sp)
400013a8:	02010113          	addi	sp,sp,32
400013ac:	00008067          	ret

400013b0 <free_chunk>:

static void free_chunk(struct z_heap *h, chunkid_t c)
{
400013b0:	fe010113          	addi	sp,sp,-32
400013b4:	00112e23          	sw	ra,28(sp)
400013b8:	00812c23          	sw	s0,24(sp)
400013bc:	00912a23          	sw	s1,20(sp)
400013c0:	00058413          	mv	s0,a1
400013c4:	00050493          	mv	s1,a0
	return c + chunk_size(h, c);
400013c8:	c21ff0ef          	jal	ra,40000fe8 <chunk_size>
400013cc:	00a405b3          	add	a1,s0,a0
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
400013d0:	00100613          	li	a2,1
400013d4:	00048513          	mv	a0,s1
400013d8:	00b12623          	sw	a1,12(sp)
400013dc:	ba5ff0ef          	jal	ra,40000f80 <chunk_field>
	/* Merge with free right chunk? */
	if (!chunk_used(h, right_chunk(h, c))) {
400013e0:	00157513          	andi	a0,a0,1
400013e4:	00c12583          	lw	a1,12(sp)
400013e8:	02051463          	bnez	a0,40001410 <free_chunk+0x60>
		free_list_remove(h, right_chunk(h, c));
400013ec:	00048513          	mv	a0,s1
400013f0:	d99ff0ef          	jal	ra,40001188 <free_list_remove>
	return c + chunk_size(h, c);
400013f4:	00040593          	mv	a1,s0
400013f8:	00048513          	mv	a0,s1
400013fc:	bedff0ef          	jal	ra,40000fe8 <chunk_size>
		merge_chunks(h, c, right_chunk(h, c));
40001400:	00a40633          	add	a2,s0,a0
40001404:	00040593          	mv	a1,s0
40001408:	00048513          	mv	a0,s1
4000140c:	df9ff0ef          	jal	ra,40001204 <merge_chunks>
	return c - chunk_field(h, c, LEFT_SIZE);
40001410:	00000613          	li	a2,0
40001414:	00040593          	mv	a1,s0
40001418:	00048513          	mv	a0,s1
4000141c:	b65ff0ef          	jal	ra,40000f80 <chunk_field>
40001420:	40a405b3          	sub	a1,s0,a0
	return chunk_field(h, c, SIZE_AND_USED) & 1U;
40001424:	00100613          	li	a2,1
40001428:	00048513          	mv	a0,s1
4000142c:	00b12623          	sw	a1,12(sp)
40001430:	b51ff0ef          	jal	ra,40000f80 <chunk_field>
	}

	/* Merge with free left chunk? */
	if (!chunk_used(h, left_chunk(h, c))) {
40001434:	00157513          	andi	a0,a0,1
40001438:	00c12583          	lw	a1,12(sp)
4000143c:	04051063          	bnez	a0,4000147c <free_chunk+0xcc>
		free_list_remove(h, left_chunk(h, c));
40001440:	00048513          	mv	a0,s1
40001444:	d45ff0ef          	jal	ra,40001188 <free_list_remove>
	return c - chunk_field(h, c, LEFT_SIZE);
40001448:	00040593          	mv	a1,s0
4000144c:	00000613          	li	a2,0
40001450:	00048513          	mv	a0,s1
40001454:	b2dff0ef          	jal	ra,40000f80 <chunk_field>
		merge_chunks(h, left_chunk(h, c), c);
40001458:	40a405b3          	sub	a1,s0,a0
4000145c:	00040613          	mv	a2,s0
40001460:	00048513          	mv	a0,s1
40001464:	da1ff0ef          	jal	ra,40001204 <merge_chunks>
40001468:	00040593          	mv	a1,s0
4000146c:	00000613          	li	a2,0
40001470:	00048513          	mv	a0,s1
40001474:	b0dff0ef          	jal	ra,40000f80 <chunk_field>
40001478:	40a40433          	sub	s0,s0,a0
		c = left_chunk(h, c);
	}

	free_list_add(h, c);
4000147c:	00040593          	mv	a1,s0
}
40001480:	01812403          	lw	s0,24(sp)
40001484:	01c12083          	lw	ra,28(sp)
	free_list_add(h, c);
40001488:	00048513          	mv	a0,s1
}
4000148c:	01412483          	lw	s1,20(sp)
40001490:	02010113          	addi	sp,sp,32
	free_list_add(h, c);
40001494:	df5ff06f          	j	40001288 <free_list_add>

40001498 <sys_heap_free>:
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
}

void sys_heap_free(struct sys_heap *heap, void *mem)
{
	if (mem == NULL) {
40001498:	04058a63          	beqz	a1,400014ec <sys_heap_free+0x54>
4000149c:	00052503          	lw	a0,0(a0)
{
400014a0:	fe010113          	addi	sp,sp,-32
400014a4:	00112e23          	sw	ra,28(sp)
	return big_heap(h) ? 8 : 4;
400014a8:	00852683          	lw	a3,8(a0)
400014ac:	00008737          	lui	a4,0x8
400014b0:	00800793          	li	a5,8
400014b4:	00e6f463          	bgeu	a3,a4,400014bc <sys_heap_free+0x24>
400014b8:	00400793          	li	a5,4
	return (mem - chunk_header_bytes(h) - base) / CHUNK_UNIT;
400014bc:	40f585b3          	sub	a1,a1,a5
400014c0:	40a585b3          	sub	a1,a1,a0
400014c4:	0035d593          	srli	a1,a1,0x3
	 */
	__ASSERT(left_chunk(h, right_chunk(h, c)) == c,
		 "corrupted heap bounds (buffer overflow?) for memory at %p",
		 mem);

	set_chunk_used(h, c, false);
400014c8:	00000613          	li	a2,0
400014cc:	00b12623          	sw	a1,12(sp)
400014d0:	00a12423          	sw	a0,8(sp)
400014d4:	b35ff0ef          	jal	ra,40001008 <set_chunk_used>
	free_chunk(h, c);
400014d8:	00c12583          	lw	a1,12(sp)
400014dc:	00812503          	lw	a0,8(sp)
}
400014e0:	01c12083          	lw	ra,28(sp)
400014e4:	02010113          	addi	sp,sp,32
	free_chunk(h, c);
400014e8:	ec9ff06f          	j	400013b0 <free_chunk>
400014ec:	00008067          	ret

400014f0 <sys_heap_init>:
		return ptr2;
	}
}

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
400014f0:	fe010113          	addi	sp,sp,-32
400014f4:	00812c23          	sw	s0,24(sp)
400014f8:	00112e23          	sw	ra,28(sp)
400014fc:	00912a23          	sw	s1,20(sp)
40001500:	01212823          	sw	s2,16(sp)
40001504:	01312623          	sw	s3,12(sp)
	return big_heap_bytes(size) ? 8 : 4;
40001508:	000407b7          	lui	a5,0x40
4000150c:	00400413          	li	s0,4
40001510:	00f66463          	bltu	a2,a5,40001518 <sys_heap_init+0x28>
40001514:	00800413          	li	s0,8
	/* Must fit in a 32 bit count of HUNK_UNIT */
	__ASSERT(bytes / CHUNK_UNIT <= 0xffffffffU, "heap size is too big");

	/* Reserve the final marker chunk's header */
	__ASSERT(bytes > heap_footer_bytes(bytes), "heap size is too small");
	bytes -= heap_footer_bytes(bytes);
40001518:	40860433          	sub	s0,a2,s0

	/* Round the start up, the end down */
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
4000151c:	00758493          	addi	s1,a1,7
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
40001520:	00858433          	add	s0,a1,s0
	uintptr_t addr = ROUND_UP(mem, CHUNK_UNIT);
40001524:	ff84f493          	andi	s1,s1,-8
	uintptr_t end = ROUND_DOWN((uint8_t *)mem + bytes, CHUNK_UNIT);
40001528:	ff847413          	andi	s0,s0,-8
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
4000152c:	40940433          	sub	s0,s0,s1

	CHECK(end > addr);
	__ASSERT(buf_sz > chunksz(sizeof(struct z_heap)), "heap size is too small");

	struct z_heap *h = (struct z_heap *)addr;
	heap->heap = h;
40001530:	00952023          	sw	s1,0(a0)
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
40001534:	00345413          	srli	s0,s0,0x3
	h->chunk0_hdr_area = 0;
40001538:	00000793          	li	a5,0
4000153c:	00000813          	li	a6,0
40001540:	00f4a023          	sw	a5,0(s1)
40001544:	0104a223          	sw	a6,4(s1)
	h->len = buf_sz;
40001548:	0084a423          	sw	s0,8(s1)
	h->avail_buckets = 0;
4000154c:	0004a623          	sw	zero,12(s1)

	int nb_buckets = bucket_idx(h, buf_sz) + 1;
40001550:	00040593          	mv	a1,s0
40001554:	00040513          	mv	a0,s0
40001558:	b09ff0ef          	jal	ra,40001060 <bucket_idx.isra.0>
	size_t chunk0_size = chunksz(sizeof(struct z_heap) +
4000155c:	00251913          	slli	s2,a0,0x2
	return (bytes + CHUNK_UNIT - 1U) / CHUNK_UNIT;
40001560:	01b90913          	addi	s2,s2,27
	int nb_buckets = bucket_idx(h, buf_sz) + 1;
40001564:	00150693          	addi	a3,a0,1
40001568:	00395913          	srli	s2,s2,0x3
				     nb_buckets * sizeof(struct z_heap_bucket));

	__ASSERT(chunk0_size + min_chunk_size(h) < buf_sz, "heap size is too small");

	for (int i = 0; i < nb_buckets; i++) {
4000156c:	01048713          	addi	a4,s1,16
40001570:	00000793          	li	a5,0
40001574:	0ad7c263          	blt	a5,a3,40001618 <sys_heap_init+0x128>
		h->buckets[i].next = 0;
	}

	/* chunk containing our struct z_heap */
	set_chunk_size(h, 0, chunk0_size);
40001578:	00090613          	mv	a2,s2
4000157c:	00048513          	mv	a0,s1
40001580:	00000593          	li	a1,0
40001584:	ad1ff0ef          	jal	ra,40001054 <set_chunk_size>
	set_chunk_used(h, 0, true);
40001588:	00048513          	mv	a0,s1
4000158c:	00100613          	li	a2,1
40001590:	00000593          	li	a1,0
40001594:	a75ff0ef          	jal	ra,40001008 <set_chunk_used>

	/* chunk containing the free heap */
	set_chunk_size(h, chunk0_size, buf_sz - chunk0_size);
40001598:	412409b3          	sub	s3,s0,s2
4000159c:	00098613          	mv	a2,s3
400015a0:	00090593          	mv	a1,s2
400015a4:	00048513          	mv	a0,s1
400015a8:	aadff0ef          	jal	ra,40001054 <set_chunk_size>
	chunk_set(h, c, LEFT_SIZE, size);
400015ac:	00090693          	mv	a3,s2
400015b0:	00090593          	mv	a1,s2
400015b4:	00048513          	mv	a0,s1
400015b8:	00000613          	li	a2,0
400015bc:	9f9ff0ef          	jal	ra,40000fb4 <chunk_set>
	set_left_chunk_size(h, chunk0_size, chunk0_size);

	/* the end marker chunk */
	set_chunk_size(h, buf_sz, 0);
400015c0:	00040593          	mv	a1,s0
400015c4:	00048513          	mv	a0,s1
400015c8:	00000613          	li	a2,0
400015cc:	a89ff0ef          	jal	ra,40001054 <set_chunk_size>
400015d0:	00098693          	mv	a3,s3
400015d4:	00040593          	mv	a1,s0
400015d8:	00048513          	mv	a0,s1
400015dc:	00000613          	li	a2,0
400015e0:	9d5ff0ef          	jal	ra,40000fb4 <chunk_set>
	set_left_chunk_size(h, buf_sz, buf_sz - chunk0_size);
	set_chunk_used(h, buf_sz, true);
400015e4:	00040593          	mv	a1,s0
400015e8:	00048513          	mv	a0,s1
400015ec:	00100613          	li	a2,1
400015f0:	a19ff0ef          	jal	ra,40001008 <set_chunk_used>

	free_list_add(h, chunk0_size);
}
400015f4:	01812403          	lw	s0,24(sp)
400015f8:	01c12083          	lw	ra,28(sp)
400015fc:	00c12983          	lw	s3,12(sp)
	free_list_add(h, chunk0_size);
40001600:	00090593          	mv	a1,s2
40001604:	00048513          	mv	a0,s1
}
40001608:	01012903          	lw	s2,16(sp)
4000160c:	01412483          	lw	s1,20(sp)
40001610:	02010113          	addi	sp,sp,32
	free_list_add(h, chunk0_size);
40001614:	c75ff06f          	j	40001288 <free_list_add>
		h->buckets[i].next = 0;
40001618:	00072023          	sw	zero,0(a4) # 8000 <__kernel_ram_size+0x6760>
	for (int i = 0; i < nb_buckets; i++) {
4000161c:	00178793          	addi	a5,a5,1 # 40001 <CONFIG_SRAM_SIZE+0x1>
40001620:	00470713          	addi	a4,a4,4
40001624:	f51ff06f          	j	40001574 <sys_heap_init+0x84>

40001628 <encode_uint>:
 */
static char *encode_uint(uint_value_type value,
			 struct conversion *conv,
			 char *bps,
			 const char *bpe)
{
40001628:	fd010113          	addi	sp,sp,-48
4000162c:	02812423          	sw	s0,40(sp)
40001630:	02912223          	sw	s1,36(sp)
40001634:	03212023          	sw	s2,32(sp)
40001638:	01312e23          	sw	s3,28(sp)
4000163c:	01712623          	sw	s7,12(sp)
40001640:	01812423          	sw	s8,8(sp)
40001644:	01912223          	sw	s9,4(sp)
40001648:	02112623          	sw	ra,44(sp)
4000164c:	01412c23          	sw	s4,24(sp)
40001650:	01512a23          	sw	s5,20(sp)
40001654:	01612823          	sw	s6,16(sp)
	bool upcase = isupper((int)conv->specifier);
40001658:	00364783          	lbu	a5,3(a2)
{
4000165c:	00070413          	mv	s0,a4
	switch (specifier) {
40001660:	06f00713          	li	a4,111
{
40001664:	00050c13          	mv	s8,a0
40001668:	00058c93          	mv	s9,a1
4000166c:	00060b93          	mv	s7,a2
40001670:	00068913          	mv	s2,a3
extern "C" {
#endif

static inline int isupper(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'A') < 26U);
40001674:	fbf78993          	addi	s3,a5,-65
	switch (specifier) {
40001678:	00800493          	li	s1,8
4000167c:	00e78c63          	beq	a5,a4,40001694 <encode_uint+0x6c>
40001680:	0cf76263          	bltu	a4,a5,40001744 <encode_uint+0x11c>
40001684:	05800713          	li	a4,88
		return 10;
40001688:	00a00493          	li	s1,10
	switch (specifier) {
4000168c:	00e79463          	bne	a5,a4,40001694 <encode_uint+0x6c>
		return 16;
40001690:	01000493          	li	s1,16
	const unsigned int radix = conversion_radix(conv->specifier);
	char *bp = bps + (bpe - bps);

	do {
		unsigned int lsv = (unsigned int)(value % radix);
40001694:	00000a93          	li	s5,0

		*--bp = (lsv <= 9) ? ('0' + lsv)
40001698:	00900a13          	li	s4,9
4000169c:	01900b13          	li	s6,25
		unsigned int lsv = (unsigned int)(value % radix);
400016a0:	00048613          	mv	a2,s1
400016a4:	00000693          	li	a3,0
400016a8:	000c0513          	mv	a0,s8
400016ac:	000c8593          	mv	a1,s9
400016b0:	94cff0ef          	jal	ra,400007fc <__umoddi3>
		*--bp = (lsv <= 9) ? ('0' + lsv)
400016b4:	0ff57793          	andi	a5,a0,255
400016b8:	0aaa6263          	bltu	s4,a0,4000175c <encode_uint+0x134>
400016bc:	03078793          	addi	a5,a5,48
400016c0:	0ff7f793          	andi	a5,a5,255
			: upcase ? ('A' + lsv - 10) : ('a' + lsv - 10);
		value /= radix;
400016c4:	00048613          	mv	a2,s1
400016c8:	00000693          	li	a3,0
400016cc:	000c0513          	mv	a0,s8
400016d0:	000c8593          	mv	a1,s9
		*--bp = (lsv <= 9) ? ('0' + lsv)
400016d4:	fef40fa3          	sb	a5,-1(s0)
400016d8:	fff40413          	addi	s0,s0,-1
		value /= radix;
400016dc:	c81fe0ef          	jal	ra,4000035c <__udivdi3>
	} while ((value != 0) && (bps < bp));
400016e0:	019a9463          	bne	s5,s9,400016e8 <encode_uint+0xc0>
400016e4:	009c6463          	bltu	s8,s1,400016ec <encode_uint+0xc4>
400016e8:	06896463          	bltu	s2,s0,40001750 <encode_uint+0x128>

	/* Record required alternate forms.  This can be determined
	 * from the radix without re-checking specifier.
	 */
	if (conv->flag_hash) {
400016ec:	000bd783          	lhu	a5,0(s7)
400016f0:	0207f793          	andi	a5,a5,32
400016f4:	00078c63          	beqz	a5,4000170c <encode_uint+0xe4>
		if (radix == 8) {
400016f8:	00800793          	li	a5,8
400016fc:	06f49a63          	bne	s1,a5,40001770 <encode_uint+0x148>
			conv->altform_0 = true;
40001700:	002bc783          	lbu	a5,2(s7)
40001704:	0087e793          	ori	a5,a5,8
		} else if (radix == 16) {
			conv->altform_0c = true;
40001708:	00fb8123          	sb	a5,2(s7)
		}
	}

	return bp;
}
4000170c:	02c12083          	lw	ra,44(sp)
40001710:	00040513          	mv	a0,s0
40001714:	02812403          	lw	s0,40(sp)
40001718:	02412483          	lw	s1,36(sp)
4000171c:	02012903          	lw	s2,32(sp)
40001720:	01c12983          	lw	s3,28(sp)
40001724:	01812a03          	lw	s4,24(sp)
40001728:	01412a83          	lw	s5,20(sp)
4000172c:	01012b03          	lw	s6,16(sp)
40001730:	00c12b83          	lw	s7,12(sp)
40001734:	00812c03          	lw	s8,8(sp)
40001738:	00412c83          	lw	s9,4(sp)
4000173c:	03010113          	addi	sp,sp,48
40001740:	00008067          	ret
	switch (specifier) {
40001744:	0f77f793          	andi	a5,a5,247
40001748:	07000713          	li	a4,112
4000174c:	f3dff06f          	j	40001688 <encode_uint+0x60>
		value /= radix;
40001750:	00050c13          	mv	s8,a0
40001754:	00058c93          	mv	s9,a1
40001758:	f49ff06f          	j	400016a0 <encode_uint+0x78>
		*--bp = (lsv <= 9) ? ('0' + lsv)
4000175c:	013b6663          	bltu	s6,s3,40001768 <encode_uint+0x140>
40001760:	03778793          	addi	a5,a5,55
40001764:	f5dff06f          	j	400016c0 <encode_uint+0x98>
40001768:	05778793          	addi	a5,a5,87
4000176c:	f55ff06f          	j	400016c0 <encode_uint+0x98>
		} else if (radix == 16) {
40001770:	01000793          	li	a5,16
40001774:	f8f49ce3          	bne	s1,a5,4000170c <encode_uint+0xe4>
			conv->altform_0c = true;
40001778:	002bc783          	lbu	a5,2(s7)
4000177c:	0107e793          	ori	a5,a5,16
40001780:	f89ff06f          	j	40001708 <encode_uint+0xe0>

40001784 <outs>:
/* Outline function to emit all characters in [sp, ep). */
static int outs(cbprintf_cb out,
		void *ctx,
		const char *sp,
		const char *ep)
{
40001784:	fe010113          	addi	sp,sp,-32
40001788:	00812c23          	sw	s0,24(sp)
4000178c:	00912a23          	sw	s1,20(sp)
40001790:	01212823          	sw	s2,16(sp)
40001794:	01312623          	sw	s3,12(sp)
40001798:	01412423          	sw	s4,8(sp)
4000179c:	00112e23          	sw	ra,28(sp)
400017a0:	00050993          	mv	s3,a0
400017a4:	00058a13          	mv	s4,a1
400017a8:	00060493          	mv	s1,a2
400017ac:	00068913          	mv	s2,a3
	size_t count = 0;

	while ((sp < ep) || ((ep == NULL) && *sp)) {
400017b0:	00060413          	mv	s0,a2
400017b4:	40940533          	sub	a0,s0,s1
400017b8:	01246863          	bltu	s0,s2,400017c8 <outs+0x44>
400017bc:	02091063          	bnez	s2,400017dc <outs+0x58>
400017c0:	00044783          	lbu	a5,0(s0)
400017c4:	00078c63          	beqz	a5,400017dc <outs+0x58>
		int rc = out((int)*sp++, ctx);
400017c8:	00044503          	lbu	a0,0(s0)
400017cc:	000a0593          	mv	a1,s4
400017d0:	00140413          	addi	s0,s0,1
400017d4:	000980e7          	jalr	s3

		if (rc < 0) {
400017d8:	fc055ee3          	bgez	a0,400017b4 <outs+0x30>
		}
		++count;
	}

	return (int)count;
}
400017dc:	01c12083          	lw	ra,28(sp)
400017e0:	01812403          	lw	s0,24(sp)
400017e4:	01412483          	lw	s1,20(sp)
400017e8:	01012903          	lw	s2,16(sp)
400017ec:	00c12983          	lw	s3,12(sp)
400017f0:	00812a03          	lw	s4,8(sp)
400017f4:	02010113          	addi	sp,sp,32
400017f8:	00008067          	ret

400017fc <extract_conversion>:
	*conv = (struct conversion) {
400017fc:	00052023          	sw	zero,0(a0)
40001800:	00052223          	sw	zero,4(a0)
40001804:	00052423          	sw	zero,8(a0)
	if (*sp == '%') {
40001808:	0015c703          	lbu	a4,1(a1)
4000180c:	02500693          	li	a3,37
{
40001810:	00050793          	mv	a5,a0
	if (*sp == '%') {
40001814:	0cd70663          	beq	a4,a3,400018e0 <extract_conversion+0xe4>
	++sp;
40001818:	00158593          	addi	a1,a1,1
		switch (*sp) {
4000181c:	02b00613          	li	a2,43
40001820:	02d00513          	li	a0,45
40001824:	03000813          	li	a6,48
40001828:	02000893          	li	a7,32
4000182c:	02300313          	li	t1,35
40001830:	0005c683          	lbu	a3,0(a1)
40001834:	0007d703          	lhu	a4,0(a5)
40001838:	0cc68a63          	beq	a3,a2,4000190c <extract_conversion+0x110>
4000183c:	0ad66863          	bltu	a2,a3,400018ec <extract_conversion+0xf0>
40001840:	0d168a63          	beq	a3,a7,40001914 <extract_conversion+0x118>
40001844:	0c668c63          	beq	a3,t1,4000191c <extract_conversion+0x120>
	if (conv->flag_zero && conv->flag_dash) {
40001848:	0007a683          	lw	a3,0(a5)
4000184c:	04400613          	li	a2,68
40001850:	0446f693          	andi	a3,a3,68
40001854:	00c69663          	bne	a3,a2,40001860 <extract_conversion+0x64>
		conv->flag_zero = false;
40001858:	fbf77713          	andi	a4,a4,-65
4000185c:	00e79023          	sh	a4,0(a5)
	conv->width_present = true;
40001860:	0007d683          	lhu	a3,0(a5)
40001864:	0806e713          	ori	a4,a3,128
40001868:	00e79023          	sh	a4,0(a5)
	if (*sp == '*') {
4000186c:	0005c603          	lbu	a2,0(a1)
40001870:	02a00713          	li	a4,42
40001874:	0ce61e63          	bne	a2,a4,40001950 <extract_conversion+0x154>
		conv->width_star = true;
40001878:	1806e693          	ori	a3,a3,384
		return ++sp;
4000187c:	00158713          	addi	a4,a1,1
		conv->width_star = true;
40001880:	00d79023          	sh	a3,0(a5)
	conv->prec_present = (*sp == '.');
40001884:	00074583          	lbu	a1,0(a4)
40001888:	fd258693          	addi	a3,a1,-46
4000188c:	0016b693          	seqz	a3,a3
40001890:	00969613          	slli	a2,a3,0x9
40001894:	0007d683          	lhu	a3,0(a5)
40001898:	dff6f693          	andi	a3,a3,-513
4000189c:	00c6e6b3          	or	a3,a3,a2
400018a0:	00d79023          	sh	a3,0(a5)
	if (!conv->prec_present) {
400018a4:	02e00613          	li	a2,46
400018a8:	0cc59463          	bne	a1,a2,40001970 <extract_conversion+0x174>
	if (*sp == '*') {
400018ac:	00174583          	lbu	a1,1(a4)
400018b0:	02a00613          	li	a2,42
400018b4:	0ac58863          	beq	a1,a2,40001964 <extract_conversion+0x168>
	++sp;
400018b8:	00170713          	addi	a4,a4,1
	size_t val = 0;
400018bc:	00000693          	li	a3,0
	while (isdigit((int)(unsigned char)*sp)) {
400018c0:	00900593          	li	a1,9
		val = 10U * val + *sp++ - '0';
400018c4:	00a00893          	li	a7,10
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isdigit(int a)
{
	return (int)(((unsigned)(a)-(unsigned)'0') < 10U);
400018c8:	00074603          	lbu	a2,0(a4)
400018cc:	00170813          	addi	a6,a4,1
400018d0:	fd060513          	addi	a0,a2,-48
	while (isdigit((int)(unsigned char)*sp)) {
400018d4:	12a5fe63          	bgeu	a1,a0,40001a10 <extract_conversion+0x214>
	conv->prec_value = prec;
400018d8:	00d7a423          	sw	a3,8(a5)
	return sp;
400018dc:	0940006f          	j	40001970 <extract_conversion+0x174>
		conv->specifier = *sp++;
400018e0:	00258513          	addi	a0,a1,2
400018e4:	00e781a3          	sb	a4,3(a5)
		return sp;
400018e8:	00008067          	ret
		switch (*sp) {
400018ec:	00a68863          	beq	a3,a0,400018fc <extract_conversion+0x100>
400018f0:	f5069ce3          	bne	a3,a6,40001848 <extract_conversion+0x4c>
			conv->flag_zero = true;
400018f4:	04076713          	ori	a4,a4,64
400018f8:	0080006f          	j	40001900 <extract_conversion+0x104>
			conv->flag_dash = true;
400018fc:	00476713          	ori	a4,a4,4
			conv->flag_zero = true;
40001900:	00e79023          	sh	a4,0(a5)
			++sp;
40001904:	00158593          	addi	a1,a1,1
	} while (loop);
40001908:	f29ff06f          	j	40001830 <extract_conversion+0x34>
			conv->flag_plus = true;
4000190c:	00876713          	ori	a4,a4,8
40001910:	ff1ff06f          	j	40001900 <extract_conversion+0x104>
			conv->flag_space = true;
40001914:	01076713          	ori	a4,a4,16
40001918:	fe9ff06f          	j	40001900 <extract_conversion+0x104>
			conv->flag_hash = true;
4000191c:	02076713          	ori	a4,a4,32
40001920:	fe1ff06f          	j	40001900 <extract_conversion+0x104>
		val = 10U * val + *sp++ - '0';
40001924:	026686b3          	mul	a3,a3,t1
40001928:	00088713          	mv	a4,a7
4000192c:	fd068693          	addi	a3,a3,-48
40001930:	00d606b3          	add	a3,a2,a3
40001934:	00074603          	lbu	a2,0(a4)
40001938:	00170893          	addi	a7,a4,1
4000193c:	fd060813          	addi	a6,a2,-48
	while (isdigit((int)(unsigned char)*sp)) {
40001940:	ff0572e3          	bgeu	a0,a6,40001924 <extract_conversion+0x128>
	if (sp != wp) {
40001944:	f4e580e3          	beq	a1,a4,40001884 <extract_conversion+0x88>
		conv->width_value = width;
40001948:	00d7a223          	sw	a3,4(a5)
		if (width != conv->width_value) {
4000194c:	f39ff06f          	j	40001884 <extract_conversion+0x88>
40001950:	00058713          	mv	a4,a1
	size_t val = 0;
40001954:	00000693          	li	a3,0
	while (isdigit((int)(unsigned char)*sp)) {
40001958:	00900513          	li	a0,9
		val = 10U * val + *sp++ - '0';
4000195c:	00a00313          	li	t1,10
40001960:	fd5ff06f          	j	40001934 <extract_conversion+0x138>
		conv->prec_star = true;
40001964:	4006e693          	ori	a3,a3,1024
40001968:	00d79023          	sh	a3,0(a5)
		return ++sp;
4000196c:	00270713          	addi	a4,a4,2
	switch (*sp) {
40001970:	00074583          	lbu	a1,0(a4)
40001974:	06c00693          	li	a3,108
		if (*++sp == 'h') {
40001978:	00170813          	addi	a6,a4,1
	switch (*sp) {
4000197c:	10d58c63          	beq	a1,a3,40001a94 <extract_conversion+0x298>
40001980:	0ab6e263          	bltu	a3,a1,40001a24 <extract_conversion+0x228>
40001984:	06800693          	li	a3,104
40001988:	0cd58663          	beq	a1,a3,40001a54 <extract_conversion+0x258>
4000198c:	06a00693          	li	a3,106
40001990:	12d58863          	beq	a1,a3,40001ac0 <extract_conversion+0x2c4>
40001994:	04c00693          	li	a3,76
40001998:	14d58e63          	beq	a1,a3,40001af4 <extract_conversion+0x2f8>
4000199c:	00070813          	mv	a6,a4
	conv->specifier = *sp++;
400019a0:	00084683          	lbu	a3,0(a6)
	switch (conv->specifier) {
400019a4:	07800713          	li	a4,120
	conv->specifier = *sp++;
400019a8:	00180513          	addi	a0,a6,1
400019ac:	00d781a3          	sb	a3,3(a5)
	switch (conv->specifier) {
400019b0:	22d76c63          	bltu	a4,a3,40001be8 <extract_conversion+0x3ec>
400019b4:	05700713          	li	a4,87
400019b8:	14d76c63          	bltu	a4,a3,40001b10 <extract_conversion+0x314>
400019bc:	04100713          	li	a4,65
400019c0:	00e68a63          	beq	a3,a4,400019d4 <extract_conversion+0x1d8>
400019c4:	fbb68693          	addi	a3,a3,-69
400019c8:	0ff6f693          	andi	a3,a3,255
400019cc:	00200713          	li	a4,2
400019d0:	20d76c63          	bltu	a4,a3,40001be8 <extract_conversion+0x3ec>
		conv->specifier_cat = SPECIFIER_FP;
400019d4:	0027c703          	lbu	a4,2(a5)
400019d8:	ff877713          	andi	a4,a4,-8
400019dc:	00476713          	ori	a4,a4,4
400019e0:	00e78123          	sb	a4,2(a5)
			unsupported = true;
400019e4:	00100713          	li	a4,1
	conv->unsupported |= unsupported;
400019e8:	0007a683          	lw	a3,0(a5)
400019ec:	0016d693          	srli	a3,a3,0x1
400019f0:	0016f693          	andi	a3,a3,1
400019f4:	00d76733          	or	a4,a4,a3
400019f8:	0007d683          	lhu	a3,0(a5)
400019fc:	00171713          	slli	a4,a4,0x1
40001a00:	ffd6f693          	andi	a3,a3,-3
40001a04:	00e6e733          	or	a4,a3,a4
40001a08:	00e79023          	sh	a4,0(a5)
}
40001a0c:	00008067          	ret
		val = 10U * val + *sp++ - '0';
40001a10:	031686b3          	mul	a3,a3,a7
40001a14:	00080713          	mv	a4,a6
40001a18:	fd068693          	addi	a3,a3,-48
40001a1c:	00d606b3          	add	a3,a2,a3
40001a20:	ea9ff06f          	j	400018c8 <extract_conversion+0xcc>
	switch (*sp) {
40001a24:	07400693          	li	a3,116
40001a28:	0ad58a63          	beq	a1,a3,40001adc <extract_conversion+0x2e0>
40001a2c:	07a00693          	li	a3,122
40001a30:	f6d596e3          	bne	a1,a3,4000199c <extract_conversion+0x1a0>
		conv->length_mod = LENGTH_Z;
40001a34:	0007d703          	lhu	a4,0(a5)
40001a38:	ffff86b7          	lui	a3,0xffff8
40001a3c:	7ff68693          	addi	a3,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
40001a40:	00d77733          	and	a4,a4,a3
40001a44:	000036b7          	lui	a3,0x3
		conv->unsupported = true;
40001a48:	00d76733          	or	a4,a4,a3
40001a4c:	00e79023          	sh	a4,0(a5)
		break;
40001a50:	f51ff06f          	j	400019a0 <extract_conversion+0x1a4>
		if (*++sp == 'h') {
40001a54:	0007d503          	lhu	a0,0(a5)
40001a58:	00174883          	lbu	a7,1(a4)
40001a5c:	ffff8637          	lui	a2,0xffff8
40001a60:	7ff60693          	addi	a3,a2,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_HH;
40001a64:	00a6f6b3          	and	a3,a3,a0
		if (*++sp == 'h') {
40001a68:	00b89e63          	bne	a7,a1,40001a84 <extract_conversion+0x288>
			conv->length_mod = LENGTH_HH;
40001a6c:	00001637          	lui	a2,0x1
40001a70:	80060613          	addi	a2,a2,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
			conv->length_mod = LENGTH_LL;
40001a74:	00c6e6b3          	or	a3,a3,a2
40001a78:	00d79023          	sh	a3,0(a5)
			++sp;
40001a7c:	00270813          	addi	a6,a4,2
40001a80:	f21ff06f          	j	400019a0 <extract_conversion+0x1a4>
			conv->length_mod = LENGTH_H;
40001a84:	00001737          	lui	a4,0x1
			conv->length_mod = LENGTH_L;
40001a88:	00e6e6b3          	or	a3,a3,a4
40001a8c:	00d79023          	sh	a3,0(a5)
40001a90:	f11ff06f          	j	400019a0 <extract_conversion+0x1a4>
		if (*++sp == 'l') {
40001a94:	0007d503          	lhu	a0,0(a5)
40001a98:	00174883          	lbu	a7,1(a4) # 1001 <CONFIG_HEAP_MEM_POOL_SIZE+0x1>
40001a9c:	ffff8637          	lui	a2,0xffff8
40001aa0:	7ff60693          	addi	a3,a2,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
			conv->length_mod = LENGTH_LL;
40001aa4:	00a6f6b3          	and	a3,a3,a0
		if (*++sp == 'l') {
40001aa8:	00b89663          	bne	a7,a1,40001ab4 <extract_conversion+0x2b8>
			conv->length_mod = LENGTH_LL;
40001aac:	00002637          	lui	a2,0x2
40001ab0:	fc5ff06f          	j	40001a74 <extract_conversion+0x278>
			conv->length_mod = LENGTH_L;
40001ab4:	00002737          	lui	a4,0x2
40001ab8:	80070713          	addi	a4,a4,-2048 # 1800 <CONFIG_HEAP_MEM_POOL_SIZE+0x800>
40001abc:	fcdff06f          	j	40001a88 <extract_conversion+0x28c>
		conv->length_mod = LENGTH_J;
40001ac0:	0007d703          	lhu	a4,0(a5)
40001ac4:	ffff86b7          	lui	a3,0xffff8
40001ac8:	7ff68693          	addi	a3,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
40001acc:	00d77733          	and	a4,a4,a3
40001ad0:	000036b7          	lui	a3,0x3
		conv->length_mod = LENGTH_T;
40001ad4:	80068693          	addi	a3,a3,-2048 # 2800 <__kernel_ram_size+0xf60>
40001ad8:	f71ff06f          	j	40001a48 <extract_conversion+0x24c>
40001adc:	0007d703          	lhu	a4,0(a5)
40001ae0:	ffff86b7          	lui	a3,0xffff8
40001ae4:	7ff68693          	addi	a3,a3,2047 # ffff87ff <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff8800>
40001ae8:	00d77733          	and	a4,a4,a3
40001aec:	000046b7          	lui	a3,0x4
40001af0:	fe5ff06f          	j	40001ad4 <extract_conversion+0x2d8>
		conv->unsupported = true;
40001af4:	0007d703          	lhu	a4,0(a5)
40001af8:	ffff86b7          	lui	a3,0xffff8
40001afc:	7fd68693          	addi	a3,a3,2045 # ffff87fd <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffff87fe>
40001b00:	00d77733          	and	a4,a4,a3
40001b04:	000046b7          	lui	a3,0x4
40001b08:	00268693          	addi	a3,a3,2 # 4002 <__kernel_ram_size+0x2762>
40001b0c:	f3dff06f          	j	40001a48 <extract_conversion+0x24c>
40001b10:	fa868713          	addi	a4,a3,-88
40001b14:	0ff77713          	andi	a4,a4,255
40001b18:	02000613          	li	a2,32
40001b1c:	0ce66663          	bltu	a2,a4,40001be8 <extract_conversion+0x3ec>
40001b20:	40004637          	lui	a2,0x40004
40001b24:	00271713          	slli	a4,a4,0x2
40001b28:	40860613          	addi	a2,a2,1032 # 40004408 <_ZTV13cpp_semaphore+0x1c>
40001b2c:	00c70733          	add	a4,a4,a2
40001b30:	00072703          	lw	a4,0(a4)
40001b34:	00070067          	jr	a4
		conv->specifier_cat = SPECIFIER_SINT;
40001b38:	0027c703          	lbu	a4,2(a5)
40001b3c:	ff877713          	andi	a4,a4,-8
40001b40:	00176713          	ori	a4,a4,1
		if (conv->length_mod == LENGTH_UPPER_L) {
40001b44:	0007d603          	lhu	a2,0(a5)
		conv->specifier_cat = SPECIFIER_UINT;
40001b48:	00e78123          	sb	a4,2(a5)
		if (conv->length_mod == LENGTH_UPPER_L) {
40001b4c:	00008737          	lui	a4,0x8
40001b50:	80070713          	addi	a4,a4,-2048 # 7800 <__kernel_ram_size+0x5f60>
40001b54:	00e67733          	and	a4,a2,a4
40001b58:	01071713          	slli	a4,a4,0x10
40001b5c:	01075713          	srli	a4,a4,0x10
40001b60:	000045b7          	lui	a1,0x4
40001b64:	00b71663          	bne	a4,a1,40001b70 <extract_conversion+0x374>
			conv->invalid = true;
40001b68:	00166613          	ori	a2,a2,1
40001b6c:	00c79023          	sh	a2,0(a5)
		if (conv->specifier == 'c') {
40001b70:	06300613          	li	a2,99
	bool unsupported = false;
40001b74:	00000713          	li	a4,0
		if (conv->specifier == 'c') {
40001b78:	e6c698e3          	bne	a3,a2,400019e8 <extract_conversion+0x1ec>
		if (conv->length_mod != LENGTH_NONE) {
40001b7c:	0007d683          	lhu	a3,0(a5)
40001b80:	00008737          	lui	a4,0x8
40001b84:	80070713          	addi	a4,a4,-2048 # 7800 <__kernel_ram_size+0x5f60>
40001b88:	00d77733          	and	a4,a4,a3
40001b8c:	00e03733          	snez	a4,a4
40001b90:	e59ff06f          	j	400019e8 <extract_conversion+0x1ec>
		conv->specifier_cat = SPECIFIER_UINT;
40001b94:	0027c703          	lbu	a4,2(a5)
40001b98:	ff877713          	andi	a4,a4,-8
40001b9c:	00276713          	ori	a4,a4,2
40001ba0:	fa5ff06f          	j	40001b44 <extract_conversion+0x348>
		conv->specifier_cat = SPECIFIER_PTR;
40001ba4:	0027c703          	lbu	a4,2(a5)
		if (conv->length_mod == LENGTH_UPPER_L) {
40001ba8:	0007d683          	lhu	a3,0(a5)
		conv->specifier_cat = SPECIFIER_PTR;
40001bac:	ff877713          	andi	a4,a4,-8
40001bb0:	00376713          	ori	a4,a4,3
40001bb4:	00e78123          	sb	a4,2(a5)
		if (conv->length_mod == LENGTH_UPPER_L) {
40001bb8:	00008737          	lui	a4,0x8
40001bbc:	80070713          	addi	a4,a4,-2048 # 7800 <__kernel_ram_size+0x5f60>
40001bc0:	00d77733          	and	a4,a4,a3
40001bc4:	ffffc6b7          	lui	a3,0xffffc
40001bc8:	00d70733          	add	a4,a4,a3
40001bcc:	00173713          	seqz	a4,a4
40001bd0:	e19ff06f          	j	400019e8 <extract_conversion+0x1ec>
		conv->specifier_cat = SPECIFIER_PTR;
40001bd4:	0027c703          	lbu	a4,2(a5)
40001bd8:	ff877713          	andi	a4,a4,-8
40001bdc:	00376713          	ori	a4,a4,3
40001be0:	00e78123          	sb	a4,2(a5)
40001be4:	f99ff06f          	j	40001b7c <extract_conversion+0x380>
		conv->invalid = true;
40001be8:	0007d703          	lhu	a4,0(a5)
40001bec:	00176713          	ori	a4,a4,1
40001bf0:	00e79023          	sh	a4,0(a5)
	bool unsupported = false;
40001bf4:	00000713          	li	a4,0
		break;
40001bf8:	df1ff06f          	j	400019e8 <extract_conversion+0x1ec>

40001bfc <cbvprintf>:

int cbvprintf(cbprintf_cb out, void *ctx, const char *fp, va_list ap)
{
40001bfc:	f7010113          	addi	sp,sp,-144
40001c00:	07512a23          	sw	s5,116(sp)
40001c04:	40004ab7          	lui	s5,0x40004
40001c08:	494a8793          	addi	a5,s5,1172 # 40004494 <_ZTV13cpp_semaphore+0xa8>
40001c0c:	07612823          	sw	s6,112(sp)
40001c10:	40004b37          	lui	s6,0x40004
40001c14:	07712623          	sw	s7,108(sp)
40001c18:	07812423          	sw	s8,104(sp)
40001c1c:	00f12223          	sw	a5,4(sp)
				conv->specifier = 'x';

				goto prec_int_pad0;
			}

			bps = "(nil)";
40001c20:	40004bb7          	lui	s7,0x40004
40001c24:	4ecb0793          	addi	a5,s6,1260 # 400044ec <_ZTV13cpp_semaphore+0x100>
			bpe = bps + 5;
40001c28:	40004c37          	lui	s8,0x40004
{
40001c2c:	08812423          	sw	s0,136(sp)
40001c30:	09212023          	sw	s2,128(sp)
40001c34:	07312e23          	sw	s3,124(sp)
40001c38:	07912223          	sw	s9,100(sp)
40001c3c:	05b12e23          	sw	s11,92(sp)
40001c40:	08112623          	sw	ra,140(sp)
40001c44:	08912223          	sw	s1,132(sp)
40001c48:	07412c23          	sw	s4,120(sp)
40001c4c:	07a12023          	sw	s10,96(sp)
40001c50:	00050913          	mv	s2,a0
40001c54:	00058993          	mv	s3,a1
40001c58:	00060c93          	mv	s9,a2
40001c5c:	00068413          	mv	s0,a3
	size_t count = 0;
40001c60:	00000d93          	li	s11,0
40001c64:	00f12423          	sw	a5,8(sp)
			bps = "(nil)";
40001c68:	48cb8b93          	addi	s7,s7,1164 # 4000448c <_ZTV13cpp_semaphore+0xa0>
			bpe = bps + 5;
40001c6c:	491c0c13          	addi	s8,s8,1169 # 40004491 <_ZTV13cpp_semaphore+0xa5>
	while (*fp != 0) {
40001c70:	000cc503          	lbu	a0,0(s9)
40001c74:	00051663          	bnez	a0,40001c80 <cbvprintf+0x84>
			OUTC(' ');
			--width;
		}
	}

	return count;
40001c78:	000d8513          	mv	a0,s11
40001c7c:	2dc0006f          	j	40001f58 <cbvprintf+0x35c>
		if (*fp != '%') {
40001c80:	02500793          	li	a5,37
40001c84:	00f50e63          	beq	a0,a5,40001ca0 <cbvprintf+0xa4>
			OUTC(*fp++);
40001c88:	00098593          	mv	a1,s3
40001c8c:	000900e7          	jalr	s2
40001c90:	2c054463          	bltz	a0,40001f58 <cbvprintf+0x35c>
40001c94:	001c8a13          	addi	s4,s9,1
			OUTC('%');
40001c98:	001d8d93          	addi	s11,s11,1
			break;
40001c9c:	12c0006f          	j	40001dc8 <cbvprintf+0x1cc>
		} state = {
40001ca0:	02000613          	li	a2,32
40001ca4:	00000593          	li	a1,0
40001ca8:	03010513          	addi	a0,sp,48
40001cac:	3a1000ef          	jal	ra,4000284c <memset>
		fp = extract_conversion(conv, sp);
40001cb0:	000c8593          	mv	a1,s9
40001cb4:	04010513          	addi	a0,sp,64
40001cb8:	b45ff0ef          	jal	ra,400017fc <extract_conversion>
		if (conv->width_star) {
40001cbc:	04015783          	lhu	a5,64(sp)
		fp = extract_conversion(conv, sp);
40001cc0:	00050a13          	mv	s4,a0
		if (conv->width_star) {
40001cc4:	1007f713          	andi	a4,a5,256
40001cc8:	04070263          	beqz	a4,40001d0c <cbvprintf+0x110>
			width = va_arg(ap, int);
40001ccc:	00042483          	lw	s1,0(s0)
40001cd0:	00440693          	addi	a3,s0,4
			if (width < 0) {
40001cd4:	0004d863          	bgez	s1,40001ce4 <cbvprintf+0xe8>
				conv->flag_dash = true;
40001cd8:	0047e793          	ori	a5,a5,4
40001cdc:	04f11023          	sh	a5,64(sp)
				width = -width;
40001ce0:	409004b3          	neg	s1,s1
		if (conv->prec_star) {
40001ce4:	04015703          	lhu	a4,64(sp)
40001ce8:	40077793          	andi	a5,a4,1024
40001cec:	04078063          	beqz	a5,40001d2c <cbvprintf+0x130>
			int arg = va_arg(ap, int);
40001cf0:	0006aa83          	lw	s5,0(a3) # ffffc000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xffffc001>
40001cf4:	00468413          	addi	s0,a3,4
			if (arg < 0) {
40001cf8:	040ad263          	bgez	s5,40001d3c <cbvprintf+0x140>
				conv->prec_present = false;
40001cfc:	dff77713          	andi	a4,a4,-513
40001d00:	04e11023          	sh	a4,64(sp)
		int precision = -1;
40001d04:	fff00a93          	li	s5,-1
40001d08:	0340006f          	j	40001d3c <cbvprintf+0x140>
		} else if (conv->width_present) {
40001d0c:	0807f793          	andi	a5,a5,128
40001d10:	00078863          	beqz	a5,40001d20 <cbvprintf+0x124>
			width = conv->width_value;
40001d14:	04412483          	lw	s1,68(sp)
40001d18:	00040693          	mv	a3,s0
40001d1c:	fc9ff06f          	j	40001ce4 <cbvprintf+0xe8>
40001d20:	00040693          	mv	a3,s0
		int width = -1;
40001d24:	fff00493          	li	s1,-1
40001d28:	fbdff06f          	j	40001ce4 <cbvprintf+0xe8>
		} else if (conv->prec_present) {
40001d2c:	20077713          	andi	a4,a4,512
40001d30:	0a070063          	beqz	a4,40001dd0 <cbvprintf+0x1d4>
			precision = conv->prec_value;
40001d34:	04812a83          	lw	s5,72(sp)
40001d38:	00068413          	mv	s0,a3
			= (enum specifier_cat_enum)conv->specifier_cat;
40001d3c:	04012583          	lw	a1,64(sp)
		conv->pad0_value = 0;
40001d40:	04012223          	sw	zero,68(sp)
		conv->pad0_pre_exp = 0;
40001d44:	04012423          	sw	zero,72(sp)
			= (enum specifier_cat_enum)conv->specifier_cat;
40001d48:	0105d693          	srli	a3,a1,0x10
			= (enum length_mod_enum)conv->length_mod;
40001d4c:	00b5d713          	srli	a4,a1,0xb
		enum specifier_cat_enum specifier_cat
40001d50:	0076f693          	andi	a3,a3,7
		if (specifier_cat == SPECIFIER_SINT) {
40001d54:	00100613          	li	a2,1
			= (enum length_mod_enum)conv->length_mod;
40001d58:	00f77713          	andi	a4,a4,15
		if (specifier_cat == SPECIFIER_SINT) {
40001d5c:	0cc69863          	bne	a3,a2,40001e2c <cbvprintf+0x230>
			switch (length_mod) {
40001d60:	00500613          	li	a2,5
40001d64:	08c70863          	beq	a4,a2,40001df4 <cbvprintf+0x1f8>
40001d68:	00e66a63          	bltu	a2,a4,40001d7c <cbvprintf+0x180>
40001d6c:	00300693          	li	a3,3
40001d70:	06d70463          	beq	a4,a3,40001dd8 <cbvprintf+0x1dc>
40001d74:	00400693          	li	a3,4
40001d78:	06d70e63          	beq	a4,a3,40001df4 <cbvprintf+0x1f8>
					(sint_value_type)va_arg(ap, ptrdiff_t);
40001d7c:	00042683          	lw	a3,0(s0)
40001d80:	00440413          	addi	s0,s0,4
40001d84:	02d12823          	sw	a3,48(sp)
40001d88:	41f6d693          	srai	a3,a3,0x1f
40001d8c:	02d12a23          	sw	a3,52(sp)
			if (length_mod == LENGTH_HH) {
40001d90:	00100693          	li	a3,1
40001d94:	06d71e63          	bne	a4,a3,40001e10 <cbvprintf+0x214>
				value->uint = (unsigned char)value->uint;
40001d98:	03014683          	lbu	a3,48(sp)
				value->uint = (unsigned short)value->uint;
40001d9c:	02d12823          	sw	a3,48(sp)
40001da0:	02012a23          	sw	zero,52(sp)
		if (conv->invalid || conv->unsupported) {
40001da4:	0035f593          	andi	a1,a1,3
40001da8:	14058863          	beqz	a1,40001ef8 <cbvprintf+0x2fc>
			OUTS(sp, fp);
40001dac:	000a0693          	mv	a3,s4
40001db0:	000c8613          	mv	a2,s9
40001db4:	00098593          	mv	a1,s3
40001db8:	00090513          	mv	a0,s2
40001dbc:	9c9ff0ef          	jal	ra,40001784 <outs>
40001dc0:	18054c63          	bltz	a0,40001f58 <cbvprintf+0x35c>
40001dc4:	00ad8db3          	add	s11,s11,a0
			OUTS(bps, bpe);
40001dc8:	000a0c93          	mv	s9,s4
40001dcc:	ea5ff06f          	j	40001c70 <cbvprintf+0x74>
40001dd0:	00068413          	mv	s0,a3
40001dd4:	f31ff06f          	j	40001d04 <cbvprintf+0x108>
				value->sint = va_arg(ap, long);
40001dd8:	00042683          	lw	a3,0(s0)
40001ddc:	00440513          	addi	a0,s0,4
40001de0:	02d12823          	sw	a3,48(sp)
40001de4:	41f6d693          	srai	a3,a3,0x1f
				value->sint =
40001de8:	02d12a23          	sw	a3,52(sp)
					(uint_value_type)va_arg(ap, size_t);
40001dec:	00050413          	mv	s0,a0
40001df0:	fb5ff06f          	j	40001da4 <cbvprintf+0x1a8>
					(sint_value_type)va_arg(ap, long long);
40001df4:	00740413          	addi	s0,s0,7
40001df8:	ff847413          	andi	s0,s0,-8
				value->sint =
40001dfc:	00042603          	lw	a2,0(s0)
40001e00:	00442683          	lw	a3,4(s0)
					(sint_value_type)va_arg(ap, long long);
40001e04:	00840513          	addi	a0,s0,8
				value->sint =
40001e08:	02c12823          	sw	a2,48(sp)
40001e0c:	fddff06f          	j	40001de8 <cbvprintf+0x1ec>
			} else if (length_mod == LENGTH_H) {
40001e10:	00200693          	li	a3,2
40001e14:	f8d718e3          	bne	a4,a3,40001da4 <cbvprintf+0x1a8>
				value->sint = (short)value->sint;
40001e18:	03011683          	lh	a3,48(sp)
40001e1c:	02d12823          	sw	a3,48(sp)
40001e20:	41f6d693          	srai	a3,a3,0x1f
				value->dbl = va_arg(ap, double);
40001e24:	02d12a23          	sw	a3,52(sp)
40001e28:	f7dff06f          	j	40001da4 <cbvprintf+0x1a8>
		} else if (specifier_cat == SPECIFIER_UINT) {
40001e2c:	00200513          	li	a0,2
40001e30:	04a69e63          	bne	a3,a0,40001e8c <cbvprintf+0x290>
			switch (length_mod) {
40001e34:	00500693          	li	a3,5
40001e38:	fad70ee3          	beq	a4,a3,40001df4 <cbvprintf+0x1f8>
40001e3c:	00e6ea63          	bltu	a3,a4,40001e50 <cbvprintf+0x254>
40001e40:	00300693          	li	a3,3
40001e44:	02d70a63          	beq	a4,a3,40001e78 <cbvprintf+0x27c>
40001e48:	00400693          	li	a3,4
40001e4c:	fad704e3          	beq	a4,a3,40001df4 <cbvprintf+0x1f8>
					(uint_value_type)va_arg(ap, size_t);
40001e50:	00042683          	lw	a3,0(s0)
40001e54:	02012a23          	sw	zero,52(sp)
40001e58:	00440413          	addi	s0,s0,4
40001e5c:	02d12823          	sw	a3,48(sp)
			if (length_mod == LENGTH_HH) {
40001e60:	00100693          	li	a3,1
40001e64:	f2d70ae3          	beq	a4,a3,40001d98 <cbvprintf+0x19c>
			} else if (length_mod == LENGTH_H) {
40001e68:	00200693          	li	a3,2
40001e6c:	f2d71ce3          	bne	a4,a3,40001da4 <cbvprintf+0x1a8>
				value->uint = (unsigned short)value->uint;
40001e70:	03015683          	lhu	a3,48(sp)
40001e74:	f29ff06f          	j	40001d9c <cbvprintf+0x1a0>
				value->uint = va_arg(ap, unsigned long);
40001e78:	00042683          	lw	a3,0(s0)
40001e7c:	00440513          	addi	a0,s0,4
40001e80:	02012a23          	sw	zero,52(sp)
40001e84:	02d12823          	sw	a3,48(sp)
				break;
40001e88:	f65ff06f          	j	40001dec <cbvprintf+0x1f0>
		} else if (specifier_cat == SPECIFIER_FP) {
40001e8c:	00400613          	li	a2,4
40001e90:	04c69a63          	bne	a3,a2,40001ee4 <cbvprintf+0x2e8>
			if (length_mod == LENGTH_UPPER_L) {
40001e94:	00800693          	li	a3,8
40001e98:	02d71863          	bne	a4,a3,40001ec8 <cbvprintf+0x2cc>
				value->ldbl = va_arg(ap, long double);
40001e9c:	00042683          	lw	a3,0(s0)
40001ea0:	0006a803          	lw	a6,0(a3)
40001ea4:	0046a503          	lw	a0,4(a3)
40001ea8:	0086a603          	lw	a2,8(a3)
40001eac:	00c6a683          	lw	a3,12(a3)
40001eb0:	03012823          	sw	a6,48(sp)
40001eb4:	02a12a23          	sw	a0,52(sp)
40001eb8:	02c12c23          	sw	a2,56(sp)
40001ebc:	02d12e23          	sw	a3,60(sp)
			value->ptr = va_arg(ap, void *);
40001ec0:	00440413          	addi	s0,s0,4
40001ec4:	ee1ff06f          	j	40001da4 <cbvprintf+0x1a8>
				value->dbl = va_arg(ap, double);
40001ec8:	00740693          	addi	a3,s0,7
40001ecc:	ff86f693          	andi	a3,a3,-8
40001ed0:	0006a603          	lw	a2,0(a3)
40001ed4:	00868413          	addi	s0,a3,8
40001ed8:	0046a683          	lw	a3,4(a3)
40001edc:	02c12823          	sw	a2,48(sp)
40001ee0:	f45ff06f          	j	40001e24 <cbvprintf+0x228>
		} else if (specifier_cat == SPECIFIER_PTR) {
40001ee4:	00300613          	li	a2,3
40001ee8:	eac69ee3          	bne	a3,a2,40001da4 <cbvprintf+0x1a8>
			value->ptr = va_arg(ap, void *);
40001eec:	00042683          	lw	a3,0(s0)
40001ef0:	02d12823          	sw	a3,48(sp)
40001ef4:	fcdff06f          	j	40001ec0 <cbvprintf+0x2c4>
		switch (conv->specifier) {
40001ef8:	04314683          	lbu	a3,67(sp)
40001efc:	07800613          	li	a2,120
40001f00:	ecd664e3          	bltu	a2,a3,40001dc8 <cbvprintf+0x1cc>
40001f04:	06200613          	li	a2,98
40001f08:	00d66e63          	bltu	a2,a3,40001f24 <cbvprintf+0x328>
40001f0c:	02500713          	li	a4,37
40001f10:	02e68c63          	beq	a3,a4,40001f48 <cbvprintf+0x34c>
40001f14:	05800713          	li	a4,88
40001f18:	eae698e3          	bne	a3,a4,40001dc8 <cbvprintf+0x1cc>
40001f1c:	00000b13          	li	s6,0
40001f20:	1780006f          	j	40002098 <cbvprintf+0x49c>
40001f24:	f9d68693          	addi	a3,a3,-99
40001f28:	0ff6f693          	andi	a3,a3,255
40001f2c:	01500613          	li	a2,21
40001f30:	e8d66ce3          	bltu	a2,a3,40001dc8 <cbvprintf+0x1cc>
40001f34:	00412783          	lw	a5,4(sp)
40001f38:	00269693          	slli	a3,a3,0x2
40001f3c:	00f686b3          	add	a3,a3,a5
40001f40:	0006a683          	lw	a3,0(a3)
40001f44:	00068067          	jr	a3
			OUTC('%');
40001f48:	00098593          	mv	a1,s3
40001f4c:	02500513          	li	a0,37
40001f50:	000900e7          	jalr	s2
40001f54:	d40552e3          	bgez	a0,40001c98 <cbvprintf+0x9c>
#undef OUTS
#undef OUTC
}
40001f58:	08c12083          	lw	ra,140(sp)
40001f5c:	08812403          	lw	s0,136(sp)
40001f60:	08412483          	lw	s1,132(sp)
40001f64:	08012903          	lw	s2,128(sp)
40001f68:	07c12983          	lw	s3,124(sp)
40001f6c:	07812a03          	lw	s4,120(sp)
40001f70:	07412a83          	lw	s5,116(sp)
40001f74:	07012b03          	lw	s6,112(sp)
40001f78:	06c12b83          	lw	s7,108(sp)
40001f7c:	06812c03          	lw	s8,104(sp)
40001f80:	06412c83          	lw	s9,100(sp)
40001f84:	06012d03          	lw	s10,96(sp)
40001f88:	05c12d83          	lw	s11,92(sp)
40001f8c:	09010113          	addi	sp,sp,144
40001f90:	00008067          	ret
			bps = (const char *)value->ptr;
40001f94:	03012c83          	lw	s9,48(sp)
			if (precision >= 0) {
40001f98:	080ace63          	bltz	s5,40002034 <cbvprintf+0x438>
				len = strnlen(bps, precision);
40001f9c:	000a8593          	mv	a1,s5
40001fa0:	000c8513          	mv	a0,s9
40001fa4:	061000ef          	jal	ra,40002804 <strnlen>
			bpe = bps + len;
40001fa8:	00ac8d33          	add	s10,s9,a0
		char sign = 0;
40001fac:	00000b13          	li	s6,0
		if (bps == NULL) {
40001fb0:	e00c8ce3          	beqz	s9,40001dc8 <cbvprintf+0x1cc>
		size_t nj_len = (bpe - bps);
40001fb4:	419d07b3          	sub	a5,s10,s9
		if (sign != 0) {
40001fb8:	000b0463          	beqz	s6,40001fc0 <cbvprintf+0x3c4>
			nj_len += 1U;
40001fbc:	00178793          	addi	a5,a5,1
		if (conv->altform_0c) {
40001fc0:	04214703          	lbu	a4,66(sp)
40001fc4:	01077693          	andi	a3,a4,16
40001fc8:	1a068463          	beqz	a3,40002170 <cbvprintf+0x574>
			nj_len += 2U;
40001fcc:	00278793          	addi	a5,a5,2
		nj_len += conv->pad0_value;
40001fd0:	04412683          	lw	a3,68(sp)
		if (conv->pad_fp) {
40001fd4:	04077713          	andi	a4,a4,64
		nj_len += conv->pad0_value;
40001fd8:	00d787b3          	add	a5,a5,a3
		if (conv->pad_fp) {
40001fdc:	00070663          	beqz	a4,40001fe8 <cbvprintf+0x3ec>
			nj_len += conv->pad0_pre_exp;
40001fe0:	04812703          	lw	a4,72(sp)
40001fe4:	00e787b3          	add	a5,a5,a4
		if (width > 0) {
40001fe8:	1c905063          	blez	s1,400021a8 <cbvprintf+0x5ac>
			width -= (int)nj_len;
40001fec:	40f484b3          	sub	s1,s1,a5
			if (!conv->flag_dash) {
40001ff0:	04012783          	lw	a5,64(sp)
40001ff4:	0027d793          	srli	a5,a5,0x2
40001ff8:	0017f793          	andi	a5,a5,1
40001ffc:	1a079663          	bnez	a5,400021a8 <cbvprintf+0x5ac>
				if (conv->flag_zero) {
40002000:	04015783          	lhu	a5,64(sp)
40002004:	0407f793          	andi	a5,a5,64
40002008:	24078c63          	beqz	a5,40002260 <cbvprintf+0x664>
					if (sign != 0) {
4000200c:	240b0e63          	beqz	s6,40002268 <cbvprintf+0x66c>
						OUTC(sign);
40002010:	00098593          	mv	a1,s3
40002014:	000b0513          	mv	a0,s6
40002018:	000900e7          	jalr	s2
4000201c:	f2054ee3          	bltz	a0,40001f58 <cbvprintf+0x35c>
40002020:	001d8d93          	addi	s11,s11,1
					pad = '0';
40002024:	03000793          	li	a5,48
						sign = 0;
40002028:	00000b13          	li	s6,0
4000202c:	01b48ab3          	add	s5,s1,s11
40002030:	1680006f          	j	40002198 <cbvprintf+0x59c>
				len = strlen(bps);
40002034:	000c8513          	mv	a0,s9
40002038:	7ac000ef          	jal	ra,400027e4 <strlen>
4000203c:	f6dff06f          	j	40001fa8 <cbvprintf+0x3ac>
			buf[0] = value->uint;
40002040:	03012783          	lw	a5,48(sp)
			bps = buf;
40002044:	01810c93          	addi	s9,sp,24
			bpe = buf + 1;
40002048:	01910d13          	addi	s10,sp,25
			buf[0] = value->uint;
4000204c:	00f10c23          	sb	a5,24(sp)
			break;
40002050:	00000b13          	li	s6,0
40002054:	f61ff06f          	j	40001fb4 <cbvprintf+0x3b8>
			if (conv->flag_plus) {
40002058:	04015703          	lhu	a4,64(sp)
				sign = '+';
4000205c:	02b00b13          	li	s6,43
			if (conv->flag_plus) {
40002060:	00877693          	andi	a3,a4,8
40002064:	00069663          	bnez	a3,40002070 <cbvprintf+0x474>
				sign = ' ';
40002068:	00171b13          	slli	s6,a4,0x1
4000206c:	020b7b13          	andi	s6,s6,32
			if (value->sint < 0) {
40002070:	03412703          	lw	a4,52(sp)
40002074:	03012683          	lw	a3,48(sp)
40002078:	02075063          	bgez	a4,40002098 <cbvprintf+0x49c>
				value->uint = (uint_value_type)-value->sint;
4000207c:	40d00633          	neg	a2,a3
40002080:	40e00733          	neg	a4,a4
40002084:	00d036b3          	snez	a3,a3
40002088:	40d70733          	sub	a4,a4,a3
4000208c:	02c12823          	sw	a2,48(sp)
40002090:	02e12a23          	sw	a4,52(sp)
				sign = '-';
40002094:	02d00b13          	li	s6,45
			bps = encode_uint(value->uint, conv, buf, bpe);
40002098:	03012503          	lw	a0,48(sp)
4000209c:	03412583          	lw	a1,52(sp)
400020a0:	02e10713          	addi	a4,sp,46
400020a4:	01810693          	addi	a3,sp,24
400020a8:	04010613          	addi	a2,sp,64
400020ac:	d7cff0ef          	jal	ra,40001628 <encode_uint>
400020b0:	00050c93          	mv	s9,a0
			if (precision >= 0) {
400020b4:	02e10d13          	addi	s10,sp,46
400020b8:	ee0acce3          	bltz	s5,40001fb0 <cbvprintf+0x3b4>
				conv->flag_zero = false;
400020bc:	04015683          	lhu	a3,64(sp)
				size_t len = bpe - bps;
400020c0:	419d0733          	sub	a4,s10,s9
				conv->flag_zero = false;
400020c4:	fbf6f693          	andi	a3,a3,-65
400020c8:	04d11023          	sh	a3,64(sp)
				if (len < (size_t)precision) {
400020cc:	ef5772e3          	bgeu	a4,s5,40001fb0 <cbvprintf+0x3b4>
					conv->pad0_value = precision - (int)len;
400020d0:	40ea87b3          	sub	a5,s5,a4
400020d4:	04f12223          	sw	a5,68(sp)
400020d8:	ed9ff06f          	j	40001fb0 <cbvprintf+0x3b4>
			if (value->ptr != NULL) {
400020dc:	03012503          	lw	a0,48(sp)
400020e0:	08050263          	beqz	a0,40002164 <cbvprintf+0x568>
				bps = encode_uint((uintptr_t)value->ptr, conv,
400020e4:	02e10713          	addi	a4,sp,46
400020e8:	01810693          	addi	a3,sp,24
400020ec:	04010613          	addi	a2,sp,64
400020f0:	00000593          	li	a1,0
400020f4:	d34ff0ef          	jal	ra,40001628 <encode_uint>
				conv->altform_0c = true;
400020f8:	04215703          	lhu	a4,66(sp)
400020fc:	000086b7          	lui	a3,0x8
40002100:	81068693          	addi	a3,a3,-2032 # 7810 <__kernel_ram_size+0x5f70>
40002104:	0ef77713          	andi	a4,a4,239
40002108:	00d76733          	or	a4,a4,a3
				bps = encode_uint((uintptr_t)value->ptr, conv,
4000210c:	00050c93          	mv	s9,a0
				conv->altform_0c = true;
40002110:	04e11123          	sh	a4,66(sp)
		char sign = 0;
40002114:	00000b13          	li	s6,0
				goto prec_int_pad0;
40002118:	f9dff06f          	j	400020b4 <cbvprintf+0x4b8>
				store_count(conv, value->ptr, count);
4000211c:	00700693          	li	a3,7
40002120:	03012783          	lw	a5,48(sp)
	switch ((enum length_mod_enum)conv->length_mod) {
40002124:	cae6e2e3          	bltu	a3,a4,40001dc8 <cbvprintf+0x1cc>
40002128:	00812683          	lw	a3,8(sp)
4000212c:	00271713          	slli	a4,a4,0x2
40002130:	00d70733          	add	a4,a4,a3
40002134:	00072703          	lw	a4,0(a4)
40002138:	00070067          	jr	a4
		*(signed char *)dp = (signed char)count;
4000213c:	01b78023          	sb	s11,0(a5)
		break;
40002140:	c89ff06f          	j	40001dc8 <cbvprintf+0x1cc>
		*(short *)dp = (short)count;
40002144:	01b79023          	sh	s11,0(a5)
		break;
40002148:	c81ff06f          	j	40001dc8 <cbvprintf+0x1cc>
		*(intmax_t *)dp = (intmax_t)count;
4000214c:	41fdd713          	srai	a4,s11,0x1f
40002150:	01b7a023          	sw	s11,0(a5)
40002154:	00e7a223          	sw	a4,4(a5)
		break;
40002158:	c71ff06f          	j	40001dc8 <cbvprintf+0x1cc>
		*(ptrdiff_t *)dp = (ptrdiff_t)count;
4000215c:	01b7a023          	sw	s11,0(a5)
		break;
40002160:	c69ff06f          	j	40001dc8 <cbvprintf+0x1cc>
			bps = "(nil)";
40002164:	000b8c93          	mv	s9,s7
			bpe = bps + 5;
40002168:	000c0d13          	mv	s10,s8
4000216c:	ee5ff06f          	j	40002050 <cbvprintf+0x454>
		} else if (conv->altform_0) {
40002170:	00877693          	andi	a3,a4,8
40002174:	e4068ee3          	beqz	a3,40001fd0 <cbvprintf+0x3d4>
			nj_len += 1U;
40002178:	00178793          	addi	a5,a5,1
4000217c:	e55ff06f          	j	40001fd0 <cbvprintf+0x3d4>
					OUTC(pad);
40002180:	00078513          	mv	a0,a5
40002184:	00098593          	mv	a1,s3
40002188:	00f12623          	sw	a5,12(sp)
4000218c:	000900e7          	jalr	s2
40002190:	00c12783          	lw	a5,12(sp)
40002194:	dc0542e3          	bltz	a0,40001f58 <cbvprintf+0x35c>
40002198:	00048713          	mv	a4,s1
4000219c:	409a8db3          	sub	s11,s5,s1
				while (width-- > 0) {
400021a0:	fff48493          	addi	s1,s1,-1
400021a4:	fce04ee3          	bgtz	a4,40002180 <cbvprintf+0x584>
		if (sign != 0) {
400021a8:	000b0c63          	beqz	s6,400021c0 <cbvprintf+0x5c4>
			OUTC(sign);
400021ac:	00098593          	mv	a1,s3
400021b0:	000b0513          	mv	a0,s6
400021b4:	000900e7          	jalr	s2
400021b8:	da0540e3          	bltz	a0,40001f58 <cbvprintf+0x35c>
400021bc:	001d8d93          	addi	s11,s11,1
			if (conv->altform_0c | conv->altform_0) {
400021c0:	04012783          	lw	a5,64(sp)
400021c4:	0147d713          	srli	a4,a5,0x14
400021c8:	00177713          	andi	a4,a4,1
400021cc:	00071863          	bnez	a4,400021dc <cbvprintf+0x5e0>
400021d0:	0137d793          	srli	a5,a5,0x13
400021d4:	0017f793          	andi	a5,a5,1
400021d8:	00078c63          	beqz	a5,400021f0 <cbvprintf+0x5f4>
				OUTC('0');
400021dc:	00098593          	mv	a1,s3
400021e0:	03000513          	li	a0,48
400021e4:	000900e7          	jalr	s2
400021e8:	d60548e3          	bltz	a0,40001f58 <cbvprintf+0x35c>
400021ec:	001d8d93          	addi	s11,s11,1
			if (conv->altform_0c) {
400021f0:	04214783          	lbu	a5,66(sp)
400021f4:	0107f793          	andi	a5,a5,16
400021f8:	00078c63          	beqz	a5,40002210 <cbvprintf+0x614>
				OUTC(conv->specifier);
400021fc:	04314503          	lbu	a0,67(sp)
40002200:	00098593          	mv	a1,s3
40002204:	000900e7          	jalr	s2
40002208:	d40548e3          	bltz	a0,40001f58 <cbvprintf+0x35c>
4000220c:	001d8d93          	addi	s11,s11,1
			while (pad_len-- > 0) {
40002210:	04412783          	lw	a5,68(sp)
40002214:	01b78ab3          	add	s5,a5,s11
40002218:	41ba8733          	sub	a4,s5,s11
4000221c:	04e04a63          	bgtz	a4,40002270 <cbvprintf+0x674>
			OUTS(bps, bpe);
40002220:	000d0693          	mv	a3,s10
40002224:	000c8613          	mv	a2,s9
40002228:	00098593          	mv	a1,s3
4000222c:	00090513          	mv	a0,s2
40002230:	d54ff0ef          	jal	ra,40001784 <outs>
40002234:	d20542e3          	bltz	a0,40001f58 <cbvprintf+0x35c>
40002238:	01b50db3          	add	s11,a0,s11
		while (width > 0) {
4000223c:	01b484b3          	add	s1,s1,s11
40002240:	41b487b3          	sub	a5,s1,s11
40002244:	b8f052e3          	blez	a5,40001dc8 <cbvprintf+0x1cc>
			OUTC(' ');
40002248:	00098593          	mv	a1,s3
4000224c:	02000513          	li	a0,32
40002250:	000900e7          	jalr	s2
40002254:	d00542e3          	bltz	a0,40001f58 <cbvprintf+0x35c>
40002258:	001d8d93          	addi	s11,s11,1
			--width;
4000225c:	fe5ff06f          	j	40002240 <cbvprintf+0x644>
				char pad = ' ';
40002260:	02000793          	li	a5,32
40002264:	dc9ff06f          	j	4000202c <cbvprintf+0x430>
					pad = '0';
40002268:	03000793          	li	a5,48
4000226c:	dc1ff06f          	j	4000202c <cbvprintf+0x430>
				OUTC('0');
40002270:	00098593          	mv	a1,s3
40002274:	03000513          	li	a0,48
40002278:	000900e7          	jalr	s2
4000227c:	cc054ee3          	bltz	a0,40001f58 <cbvprintf+0x35c>
40002280:	001d8d93          	addi	s11,s11,1
40002284:	f95ff06f          	j	40002218 <cbvprintf+0x61c>

40002288 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
40002288:	00008067          	ret

4000228c <__do_init_array_aux>:
 * @brief Execute initialization routines referenced in .init_array section
 *
 * @return N/A
 */
void __do_init_array_aux(void)
{
4000228c:	ff010113          	addi	sp,sp,-16
40002290:	00812423          	sw	s0,8(sp)
40002294:	00912223          	sw	s1,4(sp)
	for (func_ptr *func = __init_array_start;
40002298:	40004437          	lui	s0,0x40004
4000229c:	400044b7          	lui	s1,0x40004
{
400022a0:	00112623          	sw	ra,12(sp)
	for (func_ptr *func = __init_array_start;
400022a4:	29c40413          	addi	s0,s0,668 # 4000429c <__CTOR_END__>
400022a8:	2a048493          	addi	s1,s1,672 # 400042a0 <_k_neg_eagain>
400022ac:	00946c63          	bltu	s0,s1,400022c4 <__do_init_array_aux+0x38>
		func < __init_array_end;
		func++) {
		(*func)();
	}
}
400022b0:	00c12083          	lw	ra,12(sp)
400022b4:	00812403          	lw	s0,8(sp)
400022b8:	00412483          	lw	s1,4(sp)
400022bc:	01010113          	addi	sp,sp,16
400022c0:	00008067          	ret
		(*func)();
400022c4:	00042783          	lw	a5,0(s0)
		func++) {
400022c8:	00440413          	addi	s0,s0,4
		(*func)();
400022cc:	000780e7          	jalr	a5
		func++) {
400022d0:	fddff06f          	j	400022ac <__do_init_array_aux+0x20>

400022d4 <__do_global_ctors_aux>:
 *
 * This routine is invoked by the kernel prior to the execution of the
 * application's main().
 */
void __do_global_ctors_aux(void)
{
400022d4:	ff010113          	addi	sp,sp,-16
400022d8:	00812423          	sw	s0,8(sp)
	unsigned int nCtors;

	nCtors = (unsigned long)__CTOR_LIST__[0];
400022dc:	40004437          	lui	s0,0x40004
400022e0:	29440793          	addi	a5,s0,660 # 40004294 <__CTOR_LIST__>
{
400022e4:	00912223          	sw	s1,4(sp)
	nCtors = (unsigned long)__CTOR_LIST__[0];
400022e8:	0007a483          	lw	s1,0(a5)
{
400022ec:	00112623          	sw	ra,12(sp)
400022f0:	00249413          	slli	s0,s1,0x2
400022f4:	00f40433          	add	s0,s0,a5

	while (nCtors >= 1U) {
400022f8:	00049c63          	bnez	s1,40002310 <__do_global_ctors_aux+0x3c>
		__CTOR_LIST__[nCtors--]();
	}
}
400022fc:	00c12083          	lw	ra,12(sp)
40002300:	00812403          	lw	s0,8(sp)
40002304:	00412483          	lw	s1,4(sp)
40002308:	01010113          	addi	sp,sp,16
4000230c:	00008067          	ret
		__CTOR_LIST__[nCtors--]();
40002310:	00042783          	lw	a5,0(s0)
40002314:	fff48493          	addi	s1,s1,-1
40002318:	ffc40413          	addi	s0,s0,-4
4000231c:	000780e7          	jalr	a5
40002320:	fd9ff06f          	j	400022f8 <__do_global_ctors_aux+0x24>

40002324 <__cxa_atexit>:
{
	ARG_UNUSED(destructor);
	ARG_UNUSED(objptr);
	ARG_UNUSED(dso);
	return 0;
}
40002324:	00000513          	li	a0,0
40002328:	00008067          	ret

4000232c <_ZdlPv>:
	return malloc(size);
}

void operator delete(void* ptr) NOEXCEPT
{
	free(ptr);
4000232c:	4a80006f          	j	400027d4 <free>

40002330 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(const struct device *arg)
{
40002330:	ff010113          	addi	sp,sp,-16
40002334:	00112623          	sw	ra,12(sp)
40002338:	00812423          	sw	s0,8(sp)
	if (z_syscall_trap()) {
		return (const struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
4000233c:	40004537          	lui	a0,0x40004
40002340:	50c50513          	addi	a0,a0,1292 # 4000450c <_ZTV13cpp_semaphore+0x120>
40002344:	6fc000ef          	jal	ra,40002a40 <z_impl_device_get_binding>

	ARG_UNUSED(arg);

	/* Claim console device */
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
40002348:	400047b7          	lui	a5,0x40004
	__stdout_hook_install(console_out);
4000234c:	40002437          	lui	s0,0x40002
	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
40002350:	5aa7aa23          	sw	a0,1460(a5) # 400045b4 <uart_console_dev>
	__stdout_hook_install(console_out);
40002354:	37840513          	addi	a0,s0,888 # 40002378 <console_out>
40002358:	584000ef          	jal	ra,400028dc <__stdout_hook_install>
	__printk_hook_install(console_out);
4000235c:	37840513          	addi	a0,s0,888
40002360:	b85fe0ef          	jal	ra,40000ee4 <__printk_hook_install>

	uart_console_hook_install();

	return 0;
}
40002364:	00c12083          	lw	ra,12(sp)
40002368:	00812403          	lw	s0,8(sp)
4000236c:	00000513          	li	a0,0
40002370:	01010113          	addi	sp,sp,16
40002374:	00008067          	ret

40002378 <console_out>:
{
40002378:	ff010113          	addi	sp,sp,-16
4000237c:	00812423          	sw	s0,8(sp)
40002380:	00912223          	sw	s1,4(sp)
40002384:	00112623          	sw	ra,12(sp)
40002388:	400044b7          	lui	s1,0x40004
	if ('\n' == c) {
4000238c:	00a00793          	li	a5,10
{
40002390:	00050413          	mv	s0,a0
40002394:	5b448493          	addi	s1,s1,1460 # 400045b4 <uart_console_dev>
	if ('\n' == c) {
40002398:	00f51c63          	bne	a0,a5,400023b0 <console_out+0x38>
		uart_poll_out(uart_console_dev, '\r');
4000239c:	0004a503          	lw	a0,0(s1)
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->api;

	api->poll_out(dev, out_char);
400023a0:	00852783          	lw	a5,8(a0)
400023a4:	00d00593          	li	a1,13
400023a8:	0047a783          	lw	a5,4(a5)
400023ac:	000780e7          	jalr	a5
	uart_poll_out(uart_console_dev, c);
400023b0:	0004a503          	lw	a0,0(s1)
400023b4:	00852783          	lw	a5,8(a0)
400023b8:	0ff47593          	andi	a1,s0,255
400023bc:	0047a783          	lw	a5,4(a5)
400023c0:	000780e7          	jalr	a5
}
400023c4:	00c12083          	lw	ra,12(sp)
400023c8:	00040513          	mv	a0,s0
400023cc:	00812403          	lw	s0,8(sp)
400023d0:	00412483          	lw	s1,4(sp)
400023d4:	01010113          	addi	sp,sp,16
400023d8:	00008067          	ret

400023dc <vexriscv_litex_irq_init>:
}

static int vexriscv_litex_irq_init(const struct device *dev)
{
	ARG_UNUSED(dev);
	__asm__ volatile ("csrrs x0, mie, %0"
400023dc:	000017b7          	lui	a5,0x1
400023e0:	88078793          	addi	a5,a5,-1920 # 880 <CONFIG_ISR_STACK_SIZE+0x80>
400023e4:	3047a073          	csrs	mie,a5
		__asm__ volatile ("csrrs x0, mstatus, %0"
400023e8:	00800793          	li	a5,8
400023ec:	3007a073          	csrs	mstatus,a5
	vexriscv_litex_irq_setie(1);
	IRQ_CONNECT(RISCV_MACHINE_EXT_IRQ, 0, vexriscv_litex_irq_handler,
			NULL, 0);

	return 0;
}
400023f0:	00000513          	li	a0,0
400023f4:	00008067          	ret

400023f8 <vexriscv_litex_irq_handler>:
	__asm__ volatile ("csrr %0, %1" : "=r"(pending) : "i"(IRQ_PENDING));
400023f8:	fc002773          	csrr	a4,0xfc0
	__asm__ volatile ("csrr %0, %1" : "=r"(mask) : "i"(IRQ_MASK));
400023fc:	bc0027f3          	csrr	a5,0xbc0
	irqs = pending & mask;
40002400:	00e7f7b3          	and	a5,a5,a4
	if (irqs & (1 << TIMER0_IRQ)) {
40002404:	0807f793          	andi	a5,a5,128
40002408:	00078c63          	beqz	a5,40002420 <vexriscv_litex_irq_handler+0x28>
		ite->isr(ite->arg);
4000240c:	400047b7          	lui	a5,0x40004
40002410:	23478793          	addi	a5,a5,564 # 40004234 <_sw_isr_table>
40002414:	03c7a703          	lw	a4,60(a5)
40002418:	0387a503          	lw	a0,56(a5)
4000241c:	00070067          	jr	a4
}
40002420:	00008067          	ret

40002424 <arch_irq_enable>:
	__asm__ volatile ("csrr %0, %1" : "=r"(mask) : "i"(IRQ_MASK));
40002424:	bc002773          	csrr	a4,0xbc0
	vexriscv_litex_irq_setmask(vexriscv_litex_irq_getmask() | (1 << irq));
40002428:	00100793          	li	a5,1
4000242c:	00a79533          	sll	a0,a5,a0
40002430:	00e56533          	or	a0,a0,a4
	__asm__ volatile ("csrw %0, %1" :: "i"(IRQ_MASK), "r"(mask));
40002434:	bc051073          	csrw	0xbc0,a0
}
40002438:	00008067          	ret

4000243c <mtime>:
	volatile uint32_t *r = (uint32_t *)RISCV_MTIME_BASE;
	uint32_t lo, hi;

#ifdef RISCV_MTIME_LATCH
	volatile uint32_t *latch = (uint32_t *)RISCV_MTIME_LATCH;
	*latch = 1;
4000243c:	f00017b7          	lui	a5,0xf0001
40002440:	00100713          	li	a4,1
40002444:	80e7a023          	sw	a4,-2048(a5) # f0000800 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0000801>
#endif
	/* Likewise, must guard against rollover when reading */
	do {
		hi = r[1];
40002448:	8087a703          	lw	a4,-2040(a5)
		lo = r[0];
4000244c:	8047a503          	lw	a0,-2044(a5)
	} while (r[1] != hi);
40002450:	8087a583          	lw	a1,-2040(a5)
40002454:	fee59ae3          	bne	a1,a4,40002448 <mtime+0xc>
#ifdef RISCV_MTIME_LATCH
	*latch = 0;
40002458:	8007a023          	sw	zero,-2048(a5)
#endif

	return (((uint64_t)hi) << 32) | lo;
#endif
}
4000245c:	00008067          	ret

40002460 <litex_timer_irq_handler>:

static void litex_timer_irq_handler(const void *device)
{
40002460:	fe010113          	addi	sp,sp,-32
40002464:	00812c23          	sw	s0,24(sp)
40002468:	00112e23          	sw	ra,28(sp)
4000246c:	00912a23          	sw	s1,20(sp)
40002470:	01212823          	sw	s2,16(sp)
40002474:	01312623          	sw	s3,12(sp)
static ALWAYS_INLINE unsigned int arch_irq_lock(void)
{
	unsigned int key;
	ulong_t mstatus;

	__asm__ volatile ("csrrc %0, mstatus, %1"
40002478:	00800413          	li	s0,8
4000247c:	30043473          	csrrc	s0,mstatus,s0
	return *(volatile uint8_t *)addr;
}

static ALWAYS_INLINE void sys_write8(uint8_t data, mem_addr_t addr)
{
	*(volatile uint8_t *)addr = data;
40002480:	f00037b7          	lui	a5,0xf0003
40002484:	00100713          	li	a4,1
	int key = irq_lock();

	sys_write8(TIMER_EV, TIMER_EV_PENDING_ADDR);

	uint64_t now = mtime();
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);
40002488:	400044b7          	lui	s1,0x40004
4000248c:	5a048493          	addi	s1,s1,1440 # 400045a0 <last_count>
40002490:	80e78c23          	sb	a4,-2024(a5) # f0002818 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0002819>
	uint64_t now = mtime();
40002494:	fa9ff0ef          	jal	ra,4000243c <mtime>
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);
40002498:	0004a903          	lw	s2,0(s1)
4000249c:	0044a983          	lw	s3,4(s1)
	uint64_t now = mtime();
400024a0:	00050713          	mv	a4,a0
	uint32_t dticks = (uint32_t)((now - last_count) / CYC_PER_TICK);
400024a4:	41250533          	sub	a0,a0,s2
400024a8:	00a73733          	sltu	a4,a4,a0
400024ac:	413585b3          	sub	a1,a1,s3
400024b0:	00018637          	lui	a2,0x18
400024b4:	6a060613          	addi	a2,a2,1696 # 186a0 <__kernel_ram_size+0x16e00>
400024b8:	00000693          	li	a3,0
400024bc:	40e585b3          	sub	a1,a1,a4
400024c0:	e9dfd0ef          	jal	ra,4000035c <__udivdi3>

	last_count += dticks * CYC_PER_TICK;
400024c4:	000187b7          	lui	a5,0x18
400024c8:	6a078793          	addi	a5,a5,1696 # 186a0 <__kernel_ram_size+0x16e00>
400024cc:	02a787b3          	mul	a5,a5,a0
			  : "=r" (mstatus)
			  : "r" (MSTATUS_IEN)
			  : "memory");

	key = (mstatus & MSTATUS_IEN);
400024d0:	00847413          	andi	s0,s0,8
400024d4:	01278933          	add	s2,a5,s2
400024d8:	00f937b3          	sltu	a5,s2,a5
400024dc:	013787b3          	add	a5,a5,s3
400024e0:	0124a023          	sw	s2,0(s1)
400024e4:	00f4a223          	sw	a5,4(s1)
 */
static ALWAYS_INLINE void arch_irq_unlock(unsigned int key)
{
	ulong_t mstatus;

	__asm__ volatile ("csrrs %0, mstatus, %1"
400024e8:	30042473          	csrrs	s0,mstatus,s0
		set_mtimecmp(next);
	}

	irq_unlock(key);
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
}
400024ec:	01812403          	lw	s0,24(sp)
400024f0:	01c12083          	lw	ra,28(sp)
400024f4:	01412483          	lw	s1,20(sp)
400024f8:	01012903          	lw	s2,16(sp)
400024fc:	00c12983          	lw	s3,12(sp)
40002500:	02010113          	addi	sp,sp,32
	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
40002504:	0b90106f          	j	40003dbc <z_clock_announce>

40002508 <z_clock_driver_init>:

	return timer_total;
}

int z_clock_driver_init(const struct device *device)
{
40002508:	ff010113          	addi	sp,sp,-16
4000250c:	00112623          	sw	ra,12(sp)
40002510:	00812423          	sw	s0,8(sp)
	ARG_UNUSED(device);
	IRQ_CONNECT(TIMER_IRQ, DT_INST_IRQ(0, priority),
			litex_timer_irq_handler, NULL, 0);
	last_count = mtime();
40002514:	f29ff0ef          	jal	ra,4000243c <mtime>
40002518:	400047b7          	lui	a5,0x40004
4000251c:	5a078793          	addi	a5,a5,1440 # 400045a0 <last_count>
40002520:	00a7a023          	sw	a0,0(a5)
40002524:	00b7a223          	sw	a1,4(a5)
	set_mtimecmp(last_count + CYC_PER_TICK);
40002528:	000187b7          	lui	a5,0x18
4000252c:	6a078793          	addi	a5,a5,1696 # 186a0 <__kernel_ram_size+0x16e00>
	*latch = 0;
40002530:	f0001737          	lui	a4,0xf0001
	set_mtimecmp(last_count + CYC_PER_TICK);
40002534:	00f507b3          	add	a5,a0,a5
	*latch = 0;
40002538:	80072023          	sw	zero,-2048(a4) # f0000800 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0000801>
	set_mtimecmp(last_count + CYC_PER_TICK);
4000253c:	00a7b533          	sltu	a0,a5,a0
	r[0] = (uint32_t)time;
40002540:	80f72623          	sw	a5,-2036(a4)
	set_mtimecmp(last_count + CYC_PER_TICK);
40002544:	00b50533          	add	a0,a0,a1
	*latch = 1;
40002548:	00100413          	li	s0,1
	r[1] = (uint32_t)(time >> 32);
4000254c:	80a72823          	sw	a0,-2032(a4)
	*latch = 1;
40002550:	80872023          	sw	s0,-2048(a4)
	irq_enable(TIMER_IRQ);
40002554:	00700513          	li	a0,7
40002558:	ecdff0ef          	jal	ra,40002424 <arch_irq_enable>
4000255c:	f00037b7          	lui	a5,0xf0003
40002560:	80078423          	sb	zero,-2040(a5) # f0002808 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0002809>
40002564:	80078223          	sb	zero,-2044(a5)
40002568:	80078023          	sb	zero,-2048(a5)
4000256c:	80878423          	sb	s0,-2040(a5)
40002570:	80878223          	sb	s0,-2044(a5)
40002574:	f8600713          	li	a4,-122
40002578:	80e78623          	sb	a4,-2036(a5)
4000257c:	80e78423          	sb	a4,-2040(a5)
40002580:	fa000713          	li	a4,-96
40002584:	80e78823          	sb	a4,-2032(a5)
40002588:	80e78623          	sb	a4,-2036(a5)
4000258c:	80878423          	sb	s0,-2040(a5)
	return *(volatile uint8_t *)addr;
40002590:	8187c703          	lbu	a4,-2024(a5)
	sys_write8(TIMER_ENABLE, TIMER_EN_ADDR);
	sys_write8(sys_read8(TIMER_EV_PENDING_ADDR), TIMER_EV_PENDING_ADDR);
	sys_write8(TIMER_EV, TIMER_EV_ENABLE_ADDR);

	return 0;
}
40002594:	00000513          	li	a0,0
40002598:	0ff77713          	andi	a4,a4,255
	*(volatile uint8_t *)addr = data;
4000259c:	80e78c23          	sb	a4,-2024(a5)
400025a0:	80878e23          	sb	s0,-2020(a5)
400025a4:	00c12083          	lw	ra,12(sp)
400025a8:	00812403          	lw	s0,8(sp)
400025ac:	01010113          	addi	sp,sp,16
400025b0:	00008067          	ret

400025b4 <z_clock_set_timeout>:
	 * logic below to reset the comparator, we'll always bump it
	 * forward to the "next tick" due to MIN_DELAY handling and
	 * the interrupt will never fire!  Just rely on the fact that
	 * the OS gave us the proper timeout already.
	 */
	if (idle) {
400025b4:	0e059463          	bnez	a1,4000269c <z_clock_set_timeout+0xe8>
{
400025b8:	ff010113          	addi	sp,sp,-16
400025bc:	00112623          	sw	ra,12(sp)
400025c0:	00812423          	sw	s0,8(sp)
400025c4:	00912223          	sw	s1,4(sp)
		return;
	}

	ticks = ticks == K_TICKS_FOREVER ? MAX_TICKS : ticks;
400025c8:	fff00793          	li	a5,-1
400025cc:	0af51c63          	bne	a0,a5,40002684 <z_clock_set_timeout+0xd0>
400025d0:	0000a437          	lui	s0,0xa
400025d4:	7c340413          	addi	s0,s0,1987 # a7c3 <__kernel_ram_size+0x8f23>
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
400025d8:	0000a7b7          	lui	a5,0xa
400025dc:	7c378713          	addi	a4,a5,1987 # a7c3 <__kernel_ram_size+0x8f23>
400025e0:	0a874a63          	blt	a4,s0,40002694 <z_clock_set_timeout+0xe0>
	__asm__ volatile ("csrrc %0, mstatus, %1"
400025e4:	00800493          	li	s1,8
400025e8:	3004b4f3          	csrrc	s1,mstatus,s1

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint64_t now = mtime();
400025ec:	e51ff0ef          	jal	ra,4000243c <mtime>
	uint32_t adj, cyc = ticks * CYC_PER_TICK;
400025f0:	00018737          	lui	a4,0x18
400025f4:	6a070613          	addi	a2,a4,1696 # 186a0 <__kernel_ram_size+0x16e00>
400025f8:	02c40433          	mul	s0,s0,a2

	/* Round up to next tick boundary. */
	adj = (uint32_t)(now - last_count) + (CYC_PER_TICK - 1);
400025fc:	400047b7          	lui	a5,0x40004
40002600:	5a078793          	addi	a5,a5,1440 # 400045a0 <last_count>
40002604:	0007a683          	lw	a3,0(a5)
40002608:	69f70713          	addi	a4,a4,1695
4000260c:	0047a583          	lw	a1,4(a5)
40002610:	40d70733          	sub	a4,a4,a3
40002614:	00a70733          	add	a4,a4,a0
	if (cyc <= MAX_CYC - adj) {
40002618:	fff74813          	not	a6,a4
	key = (mstatus & MSTATUS_IEN);
4000261c:	0084f493          	andi	s1,s1,8
		cyc += adj;
	} else {
		cyc = MAX_CYC;
40002620:	fff00793          	li	a5,-1
	if (cyc <= MAX_CYC - adj) {
40002624:	00886463          	bltu	a6,s0,4000262c <z_clock_set_timeout+0x78>
		cyc += adj;
40002628:	00e407b3          	add	a5,s0,a4
	}
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
4000262c:	02c7d7b3          	divu	a5,a5,a2

	if ((int32_t)(cyc + last_count - now) < MIN_DELAY) {
40002630:	40a68533          	sub	a0,a3,a0
40002634:	3e700713          	li	a4,999
	cyc = (cyc / CYC_PER_TICK) * CYC_PER_TICK;
40002638:	02c787b3          	mul	a5,a5,a2
	if ((int32_t)(cyc + last_count - now) < MIN_DELAY) {
4000263c:	00f50533          	add	a0,a0,a5
40002640:	00a74463          	blt	a4,a0,40002648 <z_clock_set_timeout+0x94>
		cyc += CYC_PER_TICK;
40002644:	00c787b3          	add	a5,a5,a2
	*latch = 0;
40002648:	f0001737          	lui	a4,0xf0001
	}

	set_mtimecmp(cyc + last_count);
4000264c:	00d786b3          	add	a3,a5,a3
	*latch = 0;
40002650:	80072023          	sw	zero,-2048(a4) # f0000800 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0000801>
	set_mtimecmp(cyc + last_count);
40002654:	00f6b7b3          	sltu	a5,a3,a5
40002658:	00b787b3          	add	a5,a5,a1
	r[0] = (uint32_t)time;
4000265c:	80d72623          	sw	a3,-2036(a4)
	r[1] = (uint32_t)(time >> 32);
40002660:	80f72823          	sw	a5,-2032(a4)
	*latch = 1;
40002664:	00100793          	li	a5,1
40002668:	80f72023          	sw	a5,-2048(a4)
	__asm__ volatile ("csrrs %0, mstatus, %1"
4000266c:	3004a4f3          	csrrs	s1,mstatus,s1
	k_spin_unlock(&lock, key);
#endif
}
40002670:	00c12083          	lw	ra,12(sp)
40002674:	00812403          	lw	s0,8(sp)
40002678:	00412483          	lw	s1,4(sp)
4000267c:	01010113          	addi	sp,sp,16
40002680:	00008067          	ret
	ticks = CLAMP(ticks - 1, 0, (int32_t)MAX_TICKS);
40002684:	fff50413          	addi	s0,a0,-1
40002688:	f48048e3          	bgtz	s0,400025d8 <z_clock_set_timeout+0x24>
4000268c:	00000413          	li	s0,0
40002690:	f55ff06f          	j	400025e4 <z_clock_set_timeout+0x30>
40002694:	7c478413          	addi	s0,a5,1988
40002698:	f4dff06f          	j	400025e4 <z_clock_set_timeout+0x30>
4000269c:	00008067          	ret

400026a0 <z_clock_elapsed>:

uint32_t z_clock_elapsed(void)
{
400026a0:	ff010113          	addi	sp,sp,-16
400026a4:	00812423          	sw	s0,8(sp)
400026a8:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
400026ac:	00800413          	li	s0,8
400026b0:	30043473          	csrrc	s0,mstatus,s0
	if (!TICKLESS) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t ret = ((uint32_t)mtime() - (uint32_t)last_count) / CYC_PER_TICK;
400026b4:	d89ff0ef          	jal	ra,4000243c <mtime>
400026b8:	400047b7          	lui	a5,0x40004
400026bc:	5a07a783          	lw	a5,1440(a5) # 400045a0 <last_count>
	key = (mstatus & MSTATUS_IEN);
400026c0:	00847413          	andi	s0,s0,8
400026c4:	40f50533          	sub	a0,a0,a5
400026c8:	000187b7          	lui	a5,0x18
400026cc:	6a078793          	addi	a5,a5,1696 # 186a0 <__kernel_ram_size+0x16e00>
400026d0:	02f55533          	divu	a0,a0,a5
	__asm__ volatile ("csrrs %0, mstatus, %1"
400026d4:	30042473          	csrrs	s0,mstatus,s0

	k_spin_unlock(&lock, key);
	return ret;
}
400026d8:	00c12083          	lw	ra,12(sp)
400026dc:	00812403          	lw	s0,8(sp)
400026e0:	01010113          	addi	sp,sp,16
400026e4:	00008067          	ret

400026e8 <arch_cpu_idle>:
400026e8:	00800793          	li	a5,8
400026ec:	3007a7f3          	csrrs	a5,mstatus,a5
 */

void __weak arch_cpu_idle(void)
{
	irq_unlock(MSTATUS_IEN);
}
400026f0:	00008067          	ret

400026f4 <z_riscv_fatal_error>:
};
#endif /* CONFIG_USERSPACE */

FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf)
{
400026f4:	ff010113          	addi	sp,sp,-16
400026f8:	00112623          	sw	ra,12(sp)
			esf->a2, esf->a3, esf->a4, esf->a5);
		LOG_ERR("  a6: 0x%08lx  a7: 0x%08lx\n",
			esf->a6, esf->a7);
	}

	z_fatal_error(reason, esf);
400026fc:	400000ef          	jal	ra,40002afc <z_fatal_error>

40002700 <_Fault>:
		return "unknown";
	}
}

void _Fault(z_arch_esf_t *esf)
{
40002700:	ff010113          	addi	sp,sp,-16
40002704:	00112623          	sw	ra,12(sp)
40002708:	00050593          	mv	a1,a0
		}
	}
#endif /* CONFIG_USERSPACE */
	ulong_t mcause;

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
4000270c:	342027f3          	csrr	a5,mcause
	z_fatal_error(reason, esf);
40002710:	00000513          	li	a0,0
40002714:	3e8000ef          	jal	ra,40002afc <z_fatal_error>

40002718 <z_irq_spurious>:
#include <kernel_internal.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_irq_spurious(const void *unused)
{
40002718:	ff010113          	addi	sp,sp,-16
4000271c:	00112623          	sw	ra,12(sp)
	ulong_t mcause;

	ARG_UNUSED(unused);

	__asm__ volatile("csrr %0, mcause" : "=r" (mcause));
40002720:	342027f3          	csrr	a5,mcause
	if (mcause == RISCV_MACHINE_EXT_IRQ) {
		LOG_ERR("PLIC interrupt line causing the IRQ: %d",
			riscv_plic_get_irq());
	}
#endif
	z_riscv_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
40002724:	00000593          	li	a1,0
40002728:	00100513          	li	a0,1
4000272c:	fc9ff0ef          	jal	ra,400026f4 <z_riscv_fatal_error>

40002730 <_PrepC>:
 *
 * @return N/A
 */

void _PrepC(void)
{
40002730:	ff010113          	addi	sp,sp,-16
40002734:	00112623          	sw	ra,12(sp)
	z_bss_zero();
40002738:	420000ef          	jal	ra,40002b58 <z_bss_zero>
	soc_interrupt_init();
#endif
#ifdef CONFIG_PMP_STACK_GUARD
	z_riscv_configure_interrupt_stack_guard();
#endif
	z_cstart();
4000273c:	494000ef          	jal	ra,40002bd0 <z_cstart>

40002740 <__initialize>:
SECTION_FUNC(TEXT, __initialize)
	/*
	 * This will boot master core, just halt other cores.
	 * Note: need to be updated for complete SMP support
	 */
	csrr a0, mhartid
40002740:	f1402573          	csrr	a0,mhartid
	beqz a0, boot_master_core
40002744:	00050663          	beqz	a0,40002750 <boot_master_core>

40002748 <loop_slave_core>:

loop_slave_core:
	wfi
40002748:	10500073          	wfi
	j loop_slave_core
4000274c:	ffdff06f          	j	40002748 <loop_slave_core>

40002750 <boot_master_core>:

	/*
	 * Initially, setup stack pointer to
	 * z_interrupt_stacks + CONFIG_ISR_STACK_SIZE
	 */
	la sp, z_interrupt_stacks
40002750:	00003117          	auipc	sp,0x3
40002754:	e3010113          	addi	sp,sp,-464 # 40005580 <z_interrupt_stacks>
	li t0, CONFIG_ISR_STACK_SIZE
40002758:	000012b7          	lui	t0,0x1
4000275c:	80028293          	addi	t0,t0,-2048 # 800 <CONFIG_ISR_STACK_SIZE>
	add sp, sp, t0
40002760:	00510133          	add	sp,sp,t0

	csrw mscratch, sp
40002764:	34011073          	csrw	mscratch,sp

	/*
	 * Jump into C domain. _PrepC zeroes BSS, copies rw data into RAM,
	 * and then enters kernel z_cstart
	 */
	call _PrepC
40002768:	fc9ff0ef          	jal	ra,40002730 <_PrepC>

4000276c <z_thread_entry_wrapper>:
	 * in registers a0, a1, a2 and a3. These registers are used as arguments
	 * to function z_thread_entry. Hence, just call z_thread_entry with
	 * return address set to 0 to indicate a non-returning function call.
	 */

	jal x0, z_thread_entry
4000276c:	ff0fe06f          	j	40000f5c <z_thread_entry>

40002770 <arch_new_thread>:
	stack_init = Z_STACK_PTR_TO_FRAME(struct __esf, stack_ptr);

	/* Setup the initial stack frame */
	stack_init->a0 = (ulong_t)entry;
	stack_init->a1 = (ulong_t)p1;
	stack_init->a2 = (ulong_t)p2;
40002770:	fef62023          	sw	a5,-32(a2)
	 *    restored following the MSTATUS value set within the thread stack;
	 * 2) the core will jump to z_thread_entry_wrapper, as the program
	 *    counter will be restored following the MEPC value set within the
	 *    thread stack.
	 */
	stack_init->mstatus = MSTATUS_DEF_RESTORE;
40002774:	000027b7          	lui	a5,0x2
40002778:	88078793          	addi	a5,a5,-1920 # 1880 <CONFIG_HEAP_MEM_POOL_SIZE+0x880>
4000277c:	fef62e23          	sw	a5,-4(a2)
		stack_init->mstatus |= MSTATUS_FS_INIT;
	}
	stack_init->fp_state = 0;
#endif

	stack_init->mepc = (ulong_t)z_thread_entry_wrapper;
40002780:	400027b7          	lui	a5,0x40002
40002784:	76c78793          	addi	a5,a5,1900 # 4000276c <z_thread_entry_wrapper>
	stack_init->a0 = (ulong_t)entry;
40002788:	fcd62c23          	sw	a3,-40(a2)
	stack_init->a1 = (ulong_t)p1;
4000278c:	fce62e23          	sw	a4,-36(a2)
	stack_init->a3 = (ulong_t)p3;
40002790:	ff062223          	sw	a6,-28(a2)
	stack_init->mepc = (ulong_t)z_thread_entry_wrapper;
40002794:	fef62c23          	sw	a5,-8(a2)
	stack_init = Z_STACK_PTR_TO_FRAME(struct __esf, stack_ptr);
40002798:	fb060613          	addi	a2,a2,-80

#ifdef CONFIG_RISCV_SOC_CONTEXT_SAVE
	stack_init->soc_context = soc_esf_init;
#endif

	thread->callee_saved.sp = (ulong_t)stack_init;
4000279c:	02c52c23          	sw	a2,56(a0)
}
400027a0:	00008067          	ret

400027a4 <malloc_prepare>:

static int malloc_prepare(const struct device *unused)
{
	ARG_UNUSED(unused);

	sys_heap_init(&z_malloc_heap, z_malloc_heap_mem, HEAP_BYTES);
400027a4:	400065b7          	lui	a1,0x40006
400027a8:	d8058513          	addi	a0,a1,-640 # 40005d80 <z_malloc_heap_mem>
{
400027ac:	ff010113          	addi	sp,sp,-16
	sys_heap_init(&z_malloc_heap, z_malloc_heap_mem, HEAP_BYTES);
400027b0:	08050513          	addi	a0,a0,128
400027b4:	08000613          	li	a2,128
400027b8:	d8058593          	addi	a1,a1,-640
{
400027bc:	00112623          	sw	ra,12(sp)
	sys_heap_init(&z_malloc_heap, z_malloc_heap_mem, HEAP_BYTES);
400027c0:	d31fe0ef          	jal	ra,400014f0 <sys_heap_init>

	return 0;
}
400027c4:	00c12083          	lw	ra,12(sp)
400027c8:	00000513          	li	a0,0
400027cc:	01010113          	addi	sp,sp,16
400027d0:	00008067          	ret

400027d4 <free>:

	return ret == NULL ? ptr : ret;
}

void free(void *ptr)
{
400027d4:	00050593          	mv	a1,a0
	sys_heap_free(&z_malloc_heap, ptr);
400027d8:	40006537          	lui	a0,0x40006
400027dc:	e0050513          	addi	a0,a0,-512 # 40005e00 <z_malloc_heap>
400027e0:	cb9fe06f          	j	40001498 <sys_heap_free>

400027e4 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
400027e4:	00050793          	mv	a5,a0
	size_t n = 0;
400027e8:	00000513          	li	a0,0

	while (*s != '\0') {
400027ec:	00a78733          	add	a4,a5,a0
400027f0:	00074703          	lbu	a4,0(a4)
400027f4:	00071463          	bnez	a4,400027fc <strlen+0x18>
		s++;
		n++;
	}

	return n;
}
400027f8:	00008067          	ret
		n++;
400027fc:	00150513          	addi	a0,a0,1
40002800:	fedff06f          	j	400027ec <strlen+0x8>

40002804 <strnlen>:
 *
 * @return number of bytes in fixed-size string <s>
 */

size_t strnlen(const char *s, size_t maxlen)
{
40002804:	00050793          	mv	a5,a0
	size_t n = 0;
40002808:	00000513          	li	a0,0

	while (*s != '\0' && n < maxlen) {
4000280c:	00a78733          	add	a4,a5,a0
40002810:	00074703          	lbu	a4,0(a4)
40002814:	00070463          	beqz	a4,4000281c <strnlen+0x18>
40002818:	00b51463          	bne	a0,a1,40002820 <strnlen+0x1c>
		s++;
		n++;
	}

	return n;
}
4000281c:	00008067          	ret
		n++;
40002820:	00150513          	addi	a0,a0,1
40002824:	fe9ff06f          	j	4000280c <strnlen+0x8>

40002828 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
40002828:	00054783          	lbu	a5,0(a0)
4000282c:	0005c703          	lbu	a4,0(a1)
40002830:	00e79463          	bne	a5,a4,40002838 <strcmp+0x10>
40002834:	00079663          	bnez	a5,40002840 <strcmp+0x18>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
40002838:	40e78533          	sub	a0,a5,a4
4000283c:	00008067          	ret
		s1++;
40002840:	00150513          	addi	a0,a0,1
		s2++;
40002844:	00158593          	addi	a1,a1,1
40002848:	fe1ff06f          	j	40002828 <strcmp>

4000284c <memset>:
void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
	unsigned char c_byte = (unsigned char)c;
4000284c:	0ff5f693          	andi	a3,a1,255
	unsigned char *d_byte = (unsigned char *)buf;
40002850:	00050793          	mv	a5,a0

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
40002854:	0037f713          	andi	a4,a5,3
40002858:	04071863          	bnez	a4,400028a8 <memset+0x5c>
	};

	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;
4000285c:	0ff5f593          	andi	a1,a1,255

	c_word |= c_word << 8;
40002860:	00859713          	slli	a4,a1,0x8
40002864:	00b765b3          	or	a1,a4,a1
	c_word |= c_word << 16;
40002868:	01059713          	slli	a4,a1,0x10
4000286c:	00b765b3          	or	a1,a4,a1
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
40002870:	00c78333          	add	t1,a5,a2
40002874:	00078713          	mv	a4,a5
40002878:	00300813          	li	a6,3
4000287c:	40e308b3          	sub	a7,t1,a4
40002880:	03186e63          	bltu	a6,a7,400028bc <memset+0x70>
40002884:	ffc67593          	andi	a1,a2,-4
40002888:	00265713          	srli	a4,a2,0x2
4000288c:	00b787b3          	add	a5,a5,a1
40002890:	ffc00593          	li	a1,-4
40002894:	02b70733          	mul	a4,a4,a1
40002898:	00c70633          	add	a2,a4,a2
4000289c:	00c78633          	add	a2,a5,a2

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
400028a0:	02c79463          	bne	a5,a2,400028c8 <memset+0x7c>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
400028a4:	00008067          	ret
		if (n == 0) {
400028a8:	fe060ee3          	beqz	a2,400028a4 <memset+0x58>
		*(d_byte++) = c_byte;
400028ac:	00178793          	addi	a5,a5,1
		n--;
400028b0:	fff60613          	addi	a2,a2,-1
		*(d_byte++) = c_byte;
400028b4:	fed78fa3          	sb	a3,-1(a5)
		n--;
400028b8:	f9dff06f          	j	40002854 <memset+0x8>
		*(d_word++) = c_word;
400028bc:	00470713          	addi	a4,a4,4
400028c0:	feb72e23          	sw	a1,-4(a4)
		n -= sizeof(mem_word_t);
400028c4:	fb9ff06f          	j	4000287c <memset+0x30>
		*(d_byte++) = c_byte;
400028c8:	00178793          	addi	a5,a5,1
400028cc:	fed78fa3          	sb	a3,-1(a5)
		n--;
400028d0:	fd1ff06f          	j	400028a0 <memset+0x54>

400028d4 <_stdout_hook_default>:
static int _stdout_hook_default(int c)
{
	(void)(c);  /* Prevent warning about unused argument */

	return EOF;
}
400028d4:	fff00513          	li	a0,-1
400028d8:	00008067          	ret

400028dc <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
400028dc:	400067b7          	lui	a5,0x40006
400028e0:	e0a7a823          	sw	a0,-496(a5) # 40005e10 <_stdout_hook>
}
400028e4:	00008067          	ret

400028e8 <uart_liteuart_poll_out>:
	return *(volatile uint8_t *)addr;
400028e8:	f0002737          	lui	a4,0xf0002
400028ec:	00474783          	lbu	a5,4(a4) # f0002004 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0002005>
400028f0:	0ff7f793          	andi	a5,a5,255
 * @param c Character to send
 */
static void uart_liteuart_poll_out(const struct device *dev, unsigned char c)
{
	/* wait for space */
	while (sys_read8(UART_TXFULL)) {
400028f4:	fe079ce3          	bnez	a5,400028ec <uart_liteuart_poll_out+0x4>
	*(volatile uint8_t *)addr = data;
400028f8:	00b70023          	sb	a1,0(a4)
	}

	sys_write8(c, UART_RXTX);
}
400028fc:	00008067          	ret

40002900 <uart_liteuart_poll_in>:
	return *(volatile uint8_t *)addr;
40002900:	f00027b7          	lui	a5,0xf0002
40002904:	0087c703          	lbu	a4,8(a5) # f0002008 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0002009>
		 * to UART_EV_PENDING
		 */
		sys_write8(UART_EV_RX, UART_EV_PENDING);
		return 0;
	} else {
		return -1;
40002908:	fff00513          	li	a0,-1
4000290c:	0ff77713          	andi	a4,a4,255
	if (!sys_read8(UART_RXEMPTY)) {
40002910:	00071c63          	bnez	a4,40002928 <uart_liteuart_poll_in+0x28>
40002914:	0007c703          	lbu	a4,0(a5)
		return 0;
40002918:	00000513          	li	a0,0
		*c = sys_read8(UART_RXTX);
4000291c:	00e58023          	sb	a4,0(a1)
	*(volatile uint8_t *)addr = data;
40002920:	00200713          	li	a4,2
40002924:	00e78823          	sb	a4,16(a5)
	}
}
40002928:	00008067          	ret

4000292c <uart_liteuart_init>:
4000292c:	f00027b7          	lui	a5,0xf0002
40002930:	00300713          	li	a4,3
40002934:	00e78823          	sb	a4,16(a5) # f0002010 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0xf0002011>
			0);
	irq_enable(UART_IRQ);
#endif

	return 0;
}
40002938:	00000513          	li	a0,0
4000293c:	00008067          	ret

40002940 <z_sys_init_run_level>:
		/* End marker */
		__init_end,
	};
	const struct init_entry *entry;

	for (entry = levels[level]; entry < levels[level+1]; entry++) {
40002940:	00251713          	slli	a4,a0,0x2
40002944:	400047b7          	lui	a5,0x40004
40002948:	00150513          	addi	a0,a0,1
4000294c:	54078793          	addi	a5,a5,1344 # 40004540 <levels.0>
40002950:	00251513          	slli	a0,a0,0x2
{
40002954:	fe010113          	addi	sp,sp,-32
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
40002958:	00e78733          	add	a4,a5,a4
4000295c:	00a78533          	add	a0,a5,a0
{
40002960:	00912a23          	sw	s1,20(sp)
40002964:	01412423          	sw	s4,8(sp)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
40002968:	00072483          	lw	s1,0(a4)
4000296c:	00052a03          	lw	s4,0(a0)
{
40002970:	01212823          	sw	s2,16(sp)
40002974:	01312623          	sw	s3,12(sp)
			/* Initialization failed.
			 * Set the init status bit so device is not declared ready.
			 */
			sys_bitfield_set_bit(
				(mem_addr_t) __device_init_status_start,
				(dev - __device_start));
40002978:	40006937          	lui	s2,0x40006
	void sys_bitfield_set_bit(mem_addr_t addr, unsigned int bit)
{
	/* Doing memory offsets in terms of 32-bit values to prevent
	 * alignment issues
	 */
	sys_set_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
4000297c:	400069b7          	lui	s3,0x40006
{
40002980:	01512223          	sw	s5,4(sp)
40002984:	00112e23          	sw	ra,28(sp)
40002988:	00812c23          	sw	s0,24(sp)
				(dev - __device_start));
4000298c:	e1c90913          	addi	s2,s2,-484 # 40005e1c <__device_DT_N_S_soc_S_serial_f0002000>
40002990:	e3c98993          	addi	s3,s3,-452 # 40005e3c <__device_APPLICATION_start>
	*(volatile uint32_t *)addr = temp | (1 << bit);
40002994:	00100a93          	li	s5,1
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
40002998:	0344e463          	bltu	s1,s4,400029c0 <z_sys_init_run_level+0x80>
		}
	}
}
4000299c:	01c12083          	lw	ra,28(sp)
400029a0:	01812403          	lw	s0,24(sp)
400029a4:	01412483          	lw	s1,20(sp)
400029a8:	01012903          	lw	s2,16(sp)
400029ac:	00c12983          	lw	s3,12(sp)
400029b0:	00812a03          	lw	s4,8(sp)
400029b4:	00412a83          	lw	s5,4(sp)
400029b8:	02010113          	addi	sp,sp,32
400029bc:	00008067          	ret
		const struct device *dev = entry->dev;
400029c0:	0044a403          	lw	s0,4(s1)
		if ((entry->init(dev) != 0) && (dev != NULL)) {
400029c4:	0004a783          	lw	a5,0(s1)
400029c8:	00040513          	mv	a0,s0
400029cc:	000780e7          	jalr	a5
400029d0:	02050663          	beqz	a0,400029fc <z_sys_init_run_level+0xbc>
400029d4:	02040463          	beqz	s0,400029fc <z_sys_init_run_level+0xbc>
				(dev - __device_start));
400029d8:	41240433          	sub	s0,s0,s2
400029dc:	40445413          	srai	s0,s0,0x4
	sys_set_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
400029e0:	00545793          	srli	a5,s0,0x5
400029e4:	00279793          	slli	a5,a5,0x2
400029e8:	013787b3          	add	a5,a5,s3
	uint32_t temp = *(volatile uint32_t *)addr;
400029ec:	0007a703          	lw	a4,0(a5)
	*(volatile uint32_t *)addr = temp | (1 << bit);
400029f0:	008a9433          	sll	s0,s5,s0
400029f4:	00e46433          	or	s0,s0,a4
400029f8:	0087a023          	sw	s0,0(a5)
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
400029fc:	00848493          	addi	s1,s1,8
40002a00:	f99ff06f          	j	40002998 <z_sys_init_run_level+0x58>

40002a04 <z_device_ready>:

bool z_device_ready(const struct device *dev)
{
	/* Set bit indicates device failed initialization */
	return !(sys_bitfield_test_bit((mem_addr_t)__device_init_status_start,
					(dev - __device_start)));
40002a04:	400067b7          	lui	a5,0x40006
40002a08:	e1c78793          	addi	a5,a5,-484 # 40005e1c <__device_DT_N_S_soc_S_serial_f0002000>
40002a0c:	40f50533          	sub	a0,a0,a5
40002a10:	40455513          	srai	a0,a0,0x4
}

static ALWAYS_INLINE
	int sys_bitfield_test_bit(mem_addr_t addr, unsigned int bit)
{
	return sys_test_bit(addr + ((bit >> 5) << 2), bit & 0x1F);
40002a14:	00555793          	srli	a5,a0,0x5
40002a18:	40006737          	lui	a4,0x40006
40002a1c:	e3c70713          	addi	a4,a4,-452 # 40005e3c <__device_APPLICATION_start>
40002a20:	00279793          	slli	a5,a5,0x2
40002a24:	00e787b3          	add	a5,a5,a4
	uint32_t temp = *(volatile uint32_t *)addr;
40002a28:	0007a703          	lw	a4,0(a5)
	return temp & (1 << bit);
40002a2c:	00100793          	li	a5,1
40002a30:	00a79533          	sll	a0,a5,a0
40002a34:	00e57533          	and	a0,a0,a4
}
40002a38:	00153513          	seqz	a0,a0
40002a3c:	00008067          	ret

40002a40 <z_impl_device_get_binding>:
{
40002a40:	fe010113          	addi	sp,sp,-32
	for (dev = __device_start; dev != __device_end; dev++) {
40002a44:	400067b7          	lui	a5,0x40006
{
40002a48:	00912a23          	sw	s1,20(sp)
	for (dev = __device_start; dev != __device_end; dev++) {
40002a4c:	400064b7          	lui	s1,0x40006
{
40002a50:	00812c23          	sw	s0,24(sp)
40002a54:	01212823          	sw	s2,16(sp)
40002a58:	01312623          	sw	s3,12(sp)
40002a5c:	00112e23          	sw	ra,28(sp)
40002a60:	00050913          	mv	s2,a0
	for (dev = __device_start; dev != __device_end; dev++) {
40002a64:	e1c78413          	addi	s0,a5,-484 # 40005e1c <__device_DT_N_S_soc_S_serial_f0002000>
40002a68:	e1c78993          	addi	s3,a5,-484
40002a6c:	e3c48493          	addi	s1,s1,-452 # 40005e3c <__device_APPLICATION_start>
40002a70:	00941a63          	bne	s0,s1,40002a84 <z_impl_device_get_binding+0x44>
	for (dev = __device_start; dev != __device_end; dev++) {
40002a74:	00098413          	mv	s0,s3
40002a78:	02941463          	bne	s0,s1,40002aa0 <z_impl_device_get_binding+0x60>
	return NULL;
40002a7c:	00000413          	li	s0,0
40002a80:	0440006f          	j	40002ac4 <z_impl_device_get_binding+0x84>
		if (z_device_ready(dev) && (dev->name == name)) {
40002a84:	00040513          	mv	a0,s0
40002a88:	f7dff0ef          	jal	ra,40002a04 <z_device_ready>
40002a8c:	00050663          	beqz	a0,40002a98 <z_impl_device_get_binding+0x58>
40002a90:	00042783          	lw	a5,0(s0)
40002a94:	03278863          	beq	a5,s2,40002ac4 <z_impl_device_get_binding+0x84>
	for (dev = __device_start; dev != __device_end; dev++) {
40002a98:	01040413          	addi	s0,s0,16
40002a9c:	fd5ff06f          	j	40002a70 <z_impl_device_get_binding+0x30>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
40002aa0:	00040513          	mv	a0,s0
40002aa4:	f61ff0ef          	jal	ra,40002a04 <z_device_ready>
40002aa8:	00051663          	bnez	a0,40002ab4 <z_impl_device_get_binding+0x74>
	for (dev = __device_start; dev != __device_end; dev++) {
40002aac:	01040413          	addi	s0,s0,16
40002ab0:	fc9ff06f          	j	40002a78 <z_impl_device_get_binding+0x38>
		if (z_device_ready(dev) && (strcmp(name, dev->name) == 0)) {
40002ab4:	00042583          	lw	a1,0(s0)
40002ab8:	00090513          	mv	a0,s2
40002abc:	d6dff0ef          	jal	ra,40002828 <strcmp>
40002ac0:	fe0516e3          	bnez	a0,40002aac <z_impl_device_get_binding+0x6c>
}
40002ac4:	01c12083          	lw	ra,28(sp)
40002ac8:	00040513          	mv	a0,s0
40002acc:	01812403          	lw	s0,24(sp)
40002ad0:	01412483          	lw	s1,20(sp)
40002ad4:	01012903          	lw	s2,16(sp)
40002ad8:	00c12983          	lw	s3,12(sp)
40002adc:	02010113          	addi	sp,sp,32
40002ae0:	00008067          	ret

40002ae4 <arch_system_halt>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
40002ae4:	00800793          	li	a5,8
40002ae8:	3007b7f3          	csrrc	a5,mstatus,a5
	/* TODO: What's the best way to totally halt the system if SMP
	 * is enabled?
	 */

	(void)arch_irq_lock();
	for (;;) {
40002aec:	0000006f          	j	40002aec <arch_system_halt+0x8>

40002af0 <k_sys_fatal_error_handler>:
/* LCOV_EXCL_STOP */

/* LCOV_EXCL_START */
__weak void k_sys_fatal_error_handler(unsigned int reason,
				      const z_arch_esf_t *esf)
{
40002af0:	ff010113          	addi	sp,sp,-16
40002af4:	00112623          	sw	ra,12(sp)
	ARG_UNUSED(esf);

	LOG_PANIC();
	LOG_ERR("Halting system");
	arch_system_halt(reason);
40002af8:	fedff0ef          	jal	ra,40002ae4 <arch_system_halt>

40002afc <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
40002afc:	fe010113          	addi	sp,sp,-32
40002b00:	00812c23          	sw	s0,24(sp)
40002b04:	01212823          	sw	s2,16(sp)
40002b08:	00112e23          	sw	ra,28(sp)
40002b0c:	00912a23          	sw	s1,20(sp)
40002b10:	00050913          	mv	s2,a0
40002b14:	00b12623          	sw	a1,12(sp)
40002b18:	00800413          	li	s0,8
40002b1c:	30043473          	csrrc	s0,mstatus,s0
	return z_impl_k_current_get();
40002b20:	385000ef          	jal	ra,400036a4 <z_impl_k_current_get>
	LOG_ERR("Current thread: %p (%s)", thread,
		log_strdup(thread_name_get(thread)));

	z_coredump(reason, esf, thread);

	k_sys_fatal_error_handler(reason, esf);
40002b24:	00c12583          	lw	a1,12(sp)
40002b28:	00050493          	mv	s1,a0
40002b2c:	00090513          	mv	a0,s2
40002b30:	fc1ff0ef          	jal	ra,40002af0 <k_sys_fatal_error_handler>
	key = (mstatus & MSTATUS_IEN);
40002b34:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
40002b38:	30042473          	csrrs	s0,mstatus,s0
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	arch_irq_unlock(key);
	k_thread_abort(thread);
}
40002b3c:	01812403          	lw	s0,24(sp)
40002b40:	01c12083          	lw	ra,28(sp)
40002b44:	01012903          	lw	s2,16(sp)
	z_impl_k_thread_abort(thread);
40002b48:	00048513          	mv	a0,s1
40002b4c:	01412483          	lw	s1,20(sp)
40002b50:	02010113          	addi	sp,sp,32
40002b54:	6550006f          	j	400039a8 <z_impl_k_thread_abort>

40002b58 <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
40002b58:	40004537          	lui	a0,0x40004
40002b5c:	400047b7          	lui	a5,0x40004
40002b60:	5a050613          	addi	a2,a0,1440 # 400045a0 <last_count>
40002b64:	7a878793          	addi	a5,a5,1960 # 400047a8 <__bss_end>
40002b68:	40c78633          	sub	a2,a5,a2
40002b6c:	00000593          	li	a1,0
40002b70:	5a050513          	addi	a0,a0,1440
40002b74:	cd9ff06f          	j	4000284c <memset>

40002b78 <bg_thread_main>:
 * init functions, then invokes application's main() routine.
 *
 * @return N/A
 */
static void bg_thread_main(void *unused1, void *unused2, void *unused3)
{
40002b78:	ff010113          	addi	sp,sp,-16
	ARG_UNUSED(unused1);
	ARG_UNUSED(unused2);
	ARG_UNUSED(unused3);

	z_sys_post_kernel = true;
40002b7c:	400047b7          	lui	a5,0x40004
40002b80:	00100713          	li	a4,1

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
40002b84:	00200513          	li	a0,2
{
40002b88:	00112623          	sw	ra,12(sp)
	z_sys_post_kernel = true;
40002b8c:	5ce786a3          	sb	a4,1485(a5) # 400045cd <z_sys_post_kernel>
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
40002b90:	db1ff0ef          	jal	ra,40002940 <z_sys_init_run_level>
#if CONFIG_STACK_POINTER_RANDOM
	z_stack_adjust_initialized = 1;
#endif
	boot_banner();
40002b94:	679000ef          	jal	ra,40003a0c <boot_banner>

#ifdef CONFIG_CPLUSPLUS
	/* Process the .ctors and .init_array sections */
	extern void __do_global_ctors_aux(void);
	extern void __do_init_array_aux(void);
	__do_global_ctors_aux();
40002b98:	f3cff0ef          	jal	ra,400022d4 <__do_global_ctors_aux>
	__do_init_array_aux();
40002b9c:	ef0ff0ef          	jal	ra,4000228c <__do_init_array_aux>
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
40002ba0:	00300513          	li	a0,3
40002ba4:	d9dff0ef          	jal	ra,40002940 <z_sys_init_run_level>

	z_init_static_threads();
40002ba8:	4fd000ef          	jal	ra,400038a4 <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
40002bac:	9d4fe0ef          	jal	ra,40000d80 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
40002bb0:	400047b7          	lui	a5,0x40004
40002bb4:	6d078793          	addi	a5,a5,1744 # 400046d0 <z_main_thread>
40002bb8:	00c7c703          	lbu	a4,12(a5)
40002bbc:	ffe77713          	andi	a4,a4,-2
40002bc0:	00e78623          	sb	a4,12(a5)

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
40002bc4:	00c12083          	lw	ra,12(sp)
40002bc8:	01010113          	addi	sp,sp,16
40002bcc:	00008067          	ret

40002bd0 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
40002bd0:	f5010113          	addi	sp,sp,-176
40002bd4:	09312e23          	sw	s3,156(sp)
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
40002bd8:	10100793          	li	a5,257
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = &k_mem_domain_default;
#endif

	_current_cpu->current = dummy_thread;
40002bdc:	400049b7          	lui	s3,0x40004
40002be0:	0a812423          	sw	s0,168(sp)
	dummy_thread->base.user_options = K_ESSENTIAL;
40002be4:	00f11e23          	sh	a5,28(sp)
	_current_cpu->current = dummy_thread;
40002be8:	77898413          	addi	s0,s3,1912 # 40004778 <_kernel>
40002bec:	01010793          	addi	a5,sp,16

	z_dummy_thread_init(&dummy_thread);
#endif

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
40002bf0:	00000513          	li	a0,0
{
40002bf4:	0a112623          	sw	ra,172(sp)
40002bf8:	00f42423          	sw	a5,8(s0)
40002bfc:	0a912223          	sw	s1,164(sp)
40002c00:	0b212023          	sw	s2,160(sp)
40002c04:	09412c23          	sw	s4,152(sp)
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
40002c08:	d39ff0ef          	jal	ra,40002940 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
40002c0c:	00100513          	li	a0,1
40002c10:	d31ff0ef          	jal	ra,40002940 <z_sys_init_run_level>
	z_sched_init();
40002c14:	271000ef          	jal	ra,40003684 <z_sched_init>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
40002c18:	400047b7          	lui	a5,0x40004
	_kernel.ready_q.cache = &z_main_thread;
40002c1c:	400044b7          	lui	s1,0x40004
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
40002c20:	00100a13          	li	s4,1
40002c24:	3e478793          	addi	a5,a5,996 # 400043e4 <__clz_tab+0x140>
40002c28:	400036b7          	lui	a3,0x40003
40002c2c:	400055b7          	lui	a1,0x40005
	_kernel.ready_q.cache = &z_main_thread;
40002c30:	6d048913          	addi	s2,s1,1744 # 400046d0 <z_main_thread>
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
40002c34:	00f12223          	sw	a5,4(sp)
40002c38:	00000893          	li	a7,0
40002c3c:	00000813          	li	a6,0
40002c40:	00000713          	li	a4,0
40002c44:	b7868693          	addi	a3,a3,-1160 # 40002b78 <bg_thread_main>
40002c48:	40000613          	li	a2,1024
40002c4c:	f8058593          	addi	a1,a1,-128 # 40004f80 <z_main_stack>
40002c50:	01412023          	sw	s4,0(sp)
40002c54:	00000793          	li	a5,0
40002c58:	6d048513          	addi	a0,s1,1744
	_kernel.ready_q.cache = &z_main_thread;
40002c5c:	03242223          	sw	s2,36(s0)
	stack_ptr = z_setup_new_thread(&z_main_thread, z_main_stack,
40002c60:	33d000ef          	jal	ra,4000379c <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
40002c64:	00d94783          	lbu	a5,13(s2)
	z_ready_thread(&z_main_thread);
40002c68:	6d048513          	addi	a0,s1,1744
40002c6c:	ffb7f793          	andi	a5,a5,-5
40002c70:	00f906a3          	sb	a5,13(s2)
40002c74:	3d0000ef          	jal	ra,40003044 <z_ready_thread>
	z_setup_new_thread(thread, stack,
40002c78:	40004537          	lui	a0,0x40004
40002c7c:	400046b7          	lui	a3,0x40004
40002c80:	400055b7          	lui	a1,0x40005
40002c84:	65050493          	addi	s1,a0,1616 # 40004650 <z_idle_threads>
40002c88:	00012223          	sw	zero,4(sp)
40002c8c:	01412023          	sw	s4,0(sp)
40002c90:	00f00893          	li	a7,15
40002c94:	00000813          	li	a6,0
40002c98:	00000793          	li	a5,0
40002c9c:	77898713          	addi	a4,s3,1912
40002ca0:	13c68693          	addi	a3,a3,316 # 4000413c <idle>
40002ca4:	20000613          	li	a2,512
40002ca8:	38058593          	addi	a1,a1,896 # 40005380 <z_idle_stacks>
40002cac:	65050513          	addi	a0,a0,1616
40002cb0:	2ed000ef          	jal	ra,4000379c <z_setup_new_thread>
40002cb4:	00d4c783          	lbu	a5,13(s1)
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
40002cb8:	00942623          	sw	s1,12(s0)
		_kernel.cpus[i].id = i;
40002cbc:	00040c23          	sb	zero,24(s0)
40002cc0:	ffb7f793          	andi	a5,a5,-5
40002cc4:	00f486a3          	sb	a5,13(s1)
		_kernel.cpus[i].irq_stack =
40002cc8:	400067b7          	lui	a5,0x40006
40002ccc:	d8078793          	addi	a5,a5,-640 # 40005d80 <z_malloc_heap_mem>
40002cd0:	00f42223          	sw	a5,4(s0)
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
40002cd4:	400047b7          	lui	a5,0x40004
40002cd8:	79478793          	addi	a5,a5,1940 # 40004794 <_kernel+0x1c>
40002cdc:	00f42e23          	sw	a5,28(s0)
	list->tail = (sys_dnode_t *)list;
40002ce0:	02f42023          	sw	a5,32(s0)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40002ce4:	00800513          	li	a0,8
40002ce8:	30053573          	csrrc	a0,mstatus,a0
	ret = arch_swap(key);
40002cec:	00857513          	andi	a0,a0,8
40002cf0:	db4fd0ef          	jal	ra,400002a4 <arch_swap>

40002cf4 <sys_dlist_remove>:
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
40002cf4:	00452703          	lw	a4,4(a0)
40002cf8:	00052783          	lw	a5,0(a0)
40002cfc:	00f72023          	sw	a5,0(a4)
	node->next->prev = node->prev;
40002d00:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
40002d04:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
40002d08:	00052223          	sw	zero,4(a0)
	sys_dnode_init(node);
}
40002d0c:	00008067          	ret

40002d10 <unpend_thread_no_timeout>:

	return ret;
}

static inline void unpend_thread_no_timeout(struct k_thread *thread)
{
40002d10:	ff010113          	addi	sp,sp,-16
40002d14:	00812423          	sw	s0,8(sp)
40002d18:	00112623          	sw	ra,12(sp)
40002d1c:	00050413          	mv	s0,a0
	}
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
40002d20:	fd5ff0ef          	jal	ra,40002cf4 <sys_dlist_remove>
	thread->base.thread_state |= _THREAD_PENDING;
}

static inline void z_mark_thread_as_not_pending(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PENDING;
40002d24:	00d44783          	lbu	a5,13(s0)
}
40002d28:	00c12083          	lw	ra,12(sp)
	thread->base.pended_on = NULL;
40002d2c:	00042423          	sw	zero,8(s0)
40002d30:	ffd7f793          	andi	a5,a5,-3
40002d34:	00f406a3          	sb	a5,13(s0)
}
40002d38:	00812403          	lw	s0,8(sp)
40002d3c:	01010113          	addi	sp,sp,16
40002d40:	00008067          	ret

40002d44 <z_reset_time_slice>:
{
40002d44:	ff010113          	addi	sp,sp,-16
40002d48:	00812423          	sw	s0,8(sp)
	if (slice_time != 0) {
40002d4c:	40004437          	lui	s0,0x40004
40002d50:	5c040413          	addi	s0,s0,1472 # 400045c0 <slice_time>
40002d54:	00042783          	lw	a5,0(s0)
{
40002d58:	00112623          	sw	ra,12(sp)
	if (slice_time != 0) {
40002d5c:	02078863          	beqz	a5,40002d8c <z_reset_time_slice+0x48>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
40002d60:	941ff0ef          	jal	ra,400026a0 <z_clock_elapsed>
40002d64:	00050793          	mv	a5,a0
40002d68:	00042503          	lw	a0,0(s0)
}
40002d6c:	00812403          	lw	s0,8(sp)
40002d70:	00c12083          	lw	ra,12(sp)
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
40002d74:	00f507b3          	add	a5,a0,a5
40002d78:	40004737          	lui	a4,0x40004
40002d7c:	78f72623          	sw	a5,1932(a4) # 4000478c <_kernel+0x14>
		z_set_timeout_expiry(slice_time, false);
40002d80:	00000593          	li	a1,0
}
40002d84:	01010113          	addi	sp,sp,16
		z_set_timeout_expiry(slice_time, false);
40002d88:	7dd0006f          	j	40003d64 <z_set_timeout_expiry>
}
40002d8c:	00c12083          	lw	ra,12(sp)
40002d90:	00812403          	lw	s0,8(sp)
40002d94:	01010113          	addi	sp,sp,16
40002d98:	00008067          	ret

40002d9c <k_sched_time_slice_set>:
{
40002d9c:	ff010113          	addi	sp,sp,-16
40002da0:	00112623          	sw	ra,12(sp)
40002da4:	00812423          	sw	s0,8(sp)
40002da8:	00800793          	li	a5,8
40002dac:	3007b473          	csrrc	s0,mstatus,a5
		_current_cpu->slice_ticks = 0;
40002db0:	400047b7          	lui	a5,0x40004
40002db4:	7807a623          	sw	zero,1932(a5) # 4000478c <_kernel+0x14>
		slice_time = k_ms_to_ticks_ceil32(slice);
40002db8:	400047b7          	lui	a5,0x40004
40002dbc:	5ca7a023          	sw	a0,1472(a5) # 400045c0 <slice_time>
		slice_max_prio = prio;
40002dc0:	400047b7          	lui	a5,0x40004
40002dc4:	5ab7ae23          	sw	a1,1468(a5) # 400045bc <slice_max_prio>
		z_reset_time_slice();
40002dc8:	f7dff0ef          	jal	ra,40002d44 <z_reset_time_slice>
	key = (mstatus & MSTATUS_IEN);
40002dcc:	00847793          	andi	a5,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
40002dd0:	3007a7f3          	csrrs	a5,mstatus,a5
}
40002dd4:	00c12083          	lw	ra,12(sp)
40002dd8:	00812403          	lw	s0,8(sp)
40002ddc:	01010113          	addi	sp,sp,16
40002de0:	00008067          	ret

40002de4 <z_unpend_thread_no_timeout>:
{
40002de4:	ff010113          	addi	sp,sp,-16
40002de8:	00812423          	sw	s0,8(sp)
40002dec:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40002df0:	00800413          	li	s0,8
40002df4:	30043473          	csrrc	s0,mstatus,s0
		unpend_thread_no_timeout(thread);
40002df8:	f19ff0ef          	jal	ra,40002d10 <unpend_thread_no_timeout>
	key = (mstatus & MSTATUS_IEN);
40002dfc:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
40002e00:	30042473          	csrrs	s0,mstatus,s0
}
40002e04:	00c12083          	lw	ra,12(sp)
40002e08:	00812403          	lw	s0,8(sp)
40002e0c:	01010113          	addi	sp,sp,16
40002e10:	00008067          	ret

40002e14 <z_reschedule>:
	 * have the single bit set).  But there is a mask applied to
	 * the argument in arch_irq_unlock() that has me worried
	 * that something elseswhere might try to set a bit?  Do it
	 * the safe way for now.
	 */
	return (key & MSTATUS_IEN) == MSTATUS_IEN;
40002e14:	0085f713          	andi	a4,a1,8
{
40002e18:	00058513          	mv	a0,a1
	return arch_irq_unlocked(key) && !arch_is_in_isr();
40002e1c:	02070263          	beqz	a4,40002e40 <z_reschedule+0x2c>
FUNC_NORETURN void z_riscv_fatal_error(unsigned int reason,
				       const z_arch_esf_t *esf);

static inline bool arch_is_in_isr(void)
{
	return _kernel.cpus[0].nested != 0U;
40002e20:	400047b7          	lui	a5,0x40004
40002e24:	77878793          	addi	a5,a5,1912 # 40004778 <_kernel>
40002e28:	0007a683          	lw	a3,0(a5)
40002e2c:	00069a63          	bnez	a3,40002e40 <z_reschedule+0x2c>
	if (resched(key.key) && need_swap()) {
40002e30:	0247a683          	lw	a3,36(a5)
40002e34:	0087a783          	lw	a5,8(a5)
40002e38:	00f68463          	beq	a3,a5,40002e40 <z_reschedule+0x2c>
40002e3c:	c68fd06f          	j	400002a4 <arch_swap>
	__asm__ volatile ("csrrs %0, mstatus, %1"
40002e40:	30072773          	csrrs	a4,mstatus,a4
}
40002e44:	00008067          	ret

40002e48 <z_reschedule_irqlock>:
	return (key & MSTATUS_IEN) == MSTATUS_IEN;
40002e48:	00857793          	andi	a5,a0,8
	return arch_irq_unlocked(key) && !arch_is_in_isr();
40002e4c:	00078a63          	beqz	a5,40002e60 <z_reschedule_irqlock+0x18>
40002e50:	40004737          	lui	a4,0x40004
40002e54:	77872703          	lw	a4,1912(a4) # 40004778 <_kernel>
40002e58:	00071463          	bnez	a4,40002e60 <z_reschedule_irqlock+0x18>
40002e5c:	c48fd06f          	j	400002a4 <arch_swap>
	__asm__ volatile ("csrrs %0, mstatus, %1"
40002e60:	3007a7f3          	csrrs	a5,mstatus,a5
}
40002e64:	00008067          	ret

40002e68 <z_reschedule_unlocked>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
40002e68:	00800513          	li	a0,8
40002e6c:	30053573          	csrrc	a0,mstatus,a0
	(void) z_reschedule_irqlock(arch_irq_lock());
40002e70:	00857513          	andi	a0,a0,8
40002e74:	fd5ff06f          	j	40002e48 <z_reschedule_irqlock>

40002e78 <k_sched_lock>:
40002e78:	00800793          	li	a5,8
40002e7c:	3007b7f3          	csrrc	a5,mstatus,a5
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
40002e80:	40004737          	lui	a4,0x40004
40002e84:	78072683          	lw	a3,1920(a4) # 40004780 <_kernel+0x8>
40002e88:	00f6c703          	lbu	a4,15(a3)
40002e8c:	fff70713          	addi	a4,a4,-1
40002e90:	00e687a3          	sb	a4,15(a3)
	key = (mstatus & MSTATUS_IEN);
40002e94:	0087f793          	andi	a5,a5,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
40002e98:	3007a7f3          	csrrs	a5,mstatus,a5
}
40002e9c:	00008067          	ret

40002ea0 <z_priq_dumb_best>:
}

struct k_thread *z_priq_dumb_best(sys_dlist_t *pq)
{
40002ea0:	00050793          	mv	a5,a0
	return list->head == list;
40002ea4:	00052503          	lw	a0,0(a0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40002ea8:	00a79463          	bne	a5,a0,40002eb0 <z_priq_dumb_best+0x10>
	struct k_thread *thread = NULL;
40002eac:	00000513          	li	a0,0

	if (n != NULL) {
		thread = CONTAINER_OF(n, struct k_thread, base.qnode_dlist);
	}
	return thread;
}
40002eb0:	00008067          	ret

40002eb4 <update_cache>:
{
40002eb4:	fe010113          	addi	sp,sp,-32
40002eb8:	00812c23          	sw	s0,24(sp)
	if (_current->base.thread_state & _THREAD_ABORTING) {
40002ebc:	40004437          	lui	s0,0x40004
40002ec0:	77840793          	addi	a5,s0,1912 # 40004778 <_kernel>
{
40002ec4:	01212823          	sw	s2,16(sp)
	if (_current->base.thread_state & _THREAD_ABORTING) {
40002ec8:	0087a903          	lw	s2,8(a5)
	if (_current_cpu->pending_abort != NULL) {
40002ecc:	0107a783          	lw	a5,16(a5)
{
40002ed0:	01312623          	sw	s3,12(sp)
40002ed4:	00112e23          	sw	ra,28(sp)
40002ed8:	00912a23          	sw	s1,20(sp)
40002edc:	00050993          	mv	s3,a0
40002ee0:	77840413          	addi	s0,s0,1912
	if (_current_cpu->pending_abort != NULL) {
40002ee4:	00078663          	beqz	a5,40002ef0 <update_cache+0x3c>
	return thread ? thread : _current_cpu->idle_thread;
40002ee8:	00c42483          	lw	s1,12(s0)
40002eec:	0280006f          	j	40002f14 <update_cache+0x60>
	thread = _priq_run_best(&_kernel.ready_q.runq);
40002ef0:	02840513          	addi	a0,s0,40
40002ef4:	fadff0ef          	jal	ra,40002ea0 <z_priq_dumb_best>
	if (_current->base.thread_state & _THREAD_ABORTING) {
40002ef8:	00d94783          	lbu	a5,13(s2)
	thread = _priq_run_best(&_kernel.ready_q.runq);
40002efc:	00050493          	mv	s1,a0
	if (_current->base.thread_state & _THREAD_ABORTING) {
40002f00:	0207f713          	andi	a4,a5,32
40002f04:	00070663          	beqz	a4,40002f10 <update_cache+0x5c>
		_current->base.thread_state |= _THREAD_DEAD;
40002f08:	0087e793          	ori	a5,a5,8
40002f0c:	00f906a3          	sb	a5,13(s2)
	return thread ? thread : _current_cpu->idle_thread;
40002f10:	fc048ce3          	beqz	s1,40002ee8 <update_cache+0x34>
	if (preempt_ok != 0) {
40002f14:	02099e63          	bnez	s3,40002f50 <update_cache+0x9c>
	if (z_is_thread_prevented_from_running(_current)) {
40002f18:	00d94783          	lbu	a5,13(s2)
40002f1c:	01f7f793          	andi	a5,a5,31
40002f20:	02079863          	bnez	a5,40002f50 <update_cache+0x9c>
	if (is_preempt(_current) || is_metairq(thread)) {
40002f24:	00e95703          	lhu	a4,14(s2)
40002f28:	07f00793          	li	a5,127
40002f2c:	02e7f263          	bgeu	a5,a4,40002f50 <update_cache+0x9c>
		_kernel.ready_q.cache = _current;
40002f30:	03242223          	sw	s2,36(s0)
}
40002f34:	01c12083          	lw	ra,28(sp)
40002f38:	01812403          	lw	s0,24(sp)
40002f3c:	01412483          	lw	s1,20(sp)
40002f40:	01012903          	lw	s2,16(sp)
40002f44:	00c12983          	lw	s3,12(sp)
40002f48:	02010113          	addi	sp,sp,32
40002f4c:	00008067          	ret
		if (thread != _current) {
40002f50:	01248463          	beq	s1,s2,40002f58 <update_cache+0xa4>
			z_reset_time_slice();
40002f54:	df1ff0ef          	jal	ra,40002d44 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
40002f58:	02942223          	sw	s1,36(s0)
}
40002f5c:	fd9ff06f          	j	40002f34 <update_cache+0x80>

40002f60 <k_sched_unlock>:
{
40002f60:	ff010113          	addi	sp,sp,-16
40002f64:	00812423          	sw	s0,8(sp)
40002f68:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40002f6c:	00800413          	li	s0,8
40002f70:	30043473          	csrrc	s0,mstatus,s0
		++_current->base.sched_locked;
40002f74:	400047b7          	lui	a5,0x40004
40002f78:	7807a703          	lw	a4,1920(a5) # 40004780 <_kernel+0x8>
		update_cache(0);
40002f7c:	00000513          	li	a0,0
	key = (mstatus & MSTATUS_IEN);
40002f80:	00847413          	andi	s0,s0,8
		++_current->base.sched_locked;
40002f84:	00f74783          	lbu	a5,15(a4)
40002f88:	00178793          	addi	a5,a5,1
40002f8c:	00f707a3          	sb	a5,15(a4)
		update_cache(0);
40002f90:	f25ff0ef          	jal	ra,40002eb4 <update_cache>
	__asm__ volatile ("csrrs %0, mstatus, %1"
40002f94:	30042473          	csrrs	s0,mstatus,s0
}
40002f98:	00812403          	lw	s0,8(sp)
40002f9c:	00c12083          	lw	ra,12(sp)
40002fa0:	01010113          	addi	sp,sp,16
	z_reschedule_unlocked();
40002fa4:	ec5ff06f          	j	40002e68 <z_reschedule_unlocked>

40002fa8 <ready_thread>:
	return (thread->base.thread_state & state) != 0U;
40002fa8:	00d54703          	lbu	a4,13(a0)
	if (!z_is_thread_queued(thread) && z_is_thread_ready(thread)) {
40002fac:	01871793          	slli	a5,a4,0x18
40002fb0:	4187d793          	srai	a5,a5,0x18
40002fb4:	0807c663          	bltz	a5,40003040 <ready_thread+0x98>
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
40002fb8:	01f77793          	andi	a5,a4,31
40002fbc:	08079263          	bnez	a5,40003040 <ready_thread+0x98>
40002fc0:	01852783          	lw	a5,24(a0)
40002fc4:	06079e63          	bnez	a5,40003040 <ready_thread+0x98>
	return list->head == list;
40002fc8:	400046b7          	lui	a3,0x40004
40002fcc:	77868613          	addi	a2,a3,1912 # 40004778 <_kernel>
40002fd0:	02862783          	lw	a5,40(a2)
	return (node == list->tail) ? NULL : node->next;
40002fd4:	02c62583          	lw	a1,44(a2)
40002fd8:	40004637          	lui	a2,0x40004
40002fdc:	7a060613          	addi	a2,a2,1952 # 400047a0 <_kernel+0x28>
40002fe0:	77868693          	addi	a3,a3,1912
	return sys_dlist_is_empty(list) ? NULL : list->head;
40002fe4:	04c78263          	beq	a5,a2,40003028 <ready_thread+0x80>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40002fe8:	04078063          	beqz	a5,40003028 <ready_thread+0x80>
	if (thread_1->base.prio < thread_2->base.prio) {
40002fec:	00e50803          	lb	a6,14(a0)
40002ff0:	00e78883          	lb	a7,14(a5)
40002ff4:	03185463          	bge	a6,a7,4000301c <ready_thread+0x74>
	node->prev = successor->prev;
40002ff8:	0047a683          	lw	a3,4(a5)
	node->next = successor;
40002ffc:	00f52023          	sw	a5,0(a0)
	node->prev = successor->prev;
40003000:	00d52223          	sw	a3,4(a0)
	successor->prev->next = node;
40003004:	00a6a023          	sw	a0,0(a3)
	successor->prev = node;
40003008:	00a7a223          	sw	a0,4(a5)
	thread->base.thread_state |= states;
4000300c:	f8076713          	ori	a4,a4,-128
40003010:	00e506a3          	sb	a4,13(a0)
		update_cache(0);
40003014:	00000513          	li	a0,0
40003018:	e9dff06f          	j	40002eb4 <update_cache>
	return (node == list->tail) ? NULL : node->next;
4000301c:	00b78663          	beq	a5,a1,40003028 <ready_thread+0x80>
40003020:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40003024:	fc0796e3          	bnez	a5,40002ff0 <ready_thread+0x48>
	node->prev = list->tail;
40003028:	00b52223          	sw	a1,4(a0)
	list->tail->next = node;
4000302c:	02c6a783          	lw	a5,44(a3)
	node->next = list;
40003030:	00c52023          	sw	a2,0(a0)
	list->tail->next = node;
40003034:	00a7a023          	sw	a0,0(a5)
	list->tail = node;
40003038:	02a6a623          	sw	a0,44(a3)
}
4000303c:	fd1ff06f          	j	4000300c <ready_thread+0x64>
}
40003040:	00008067          	ret

40003044 <z_ready_thread>:
{
40003044:	ff010113          	addi	sp,sp,-16
40003048:	00812423          	sw	s0,8(sp)
4000304c:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003050:	00800413          	li	s0,8
40003054:	30043473          	csrrc	s0,mstatus,s0
		ready_thread(thread);
40003058:	f51ff0ef          	jal	ra,40002fa8 <ready_thread>
	key = (mstatus & MSTATUS_IEN);
4000305c:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
40003060:	30042473          	csrrs	s0,mstatus,s0
}
40003064:	00c12083          	lw	ra,12(sp)
40003068:	00812403          	lw	s0,8(sp)
4000306c:	01010113          	addi	sp,sp,16
40003070:	00008067          	ret

40003074 <z_sched_start>:
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003074:	00800593          	li	a1,8
40003078:	3005b5f3          	csrrc	a1,mstatus,a1
	return (thread->base.thread_state & _THREAD_PRESTART) == 0U;
4000307c:	00d54703          	lbu	a4,13(a0)
	key = (mstatus & MSTATUS_IEN);
40003080:	0085f593          	andi	a1,a1,8
	if (z_has_thread_started(thread)) {
40003084:	00477693          	andi	a3,a4,4
40003088:	00069663          	bnez	a3,40003094 <z_sched_start+0x20>
	__asm__ volatile ("csrrs %0, mstatus, %1"
4000308c:	3005a5f3          	csrrs	a1,mstatus,a1
		return;
40003090:	00008067          	ret
{
40003094:	fe010113          	addi	sp,sp,-32
40003098:	00112e23          	sw	ra,28(sp)
	thread->base.thread_state &= ~_THREAD_PRESTART;
4000309c:	ffb77713          	andi	a4,a4,-5
400030a0:	00e506a3          	sb	a4,13(a0)
400030a4:	00b12623          	sw	a1,12(sp)
	ready_thread(thread);
400030a8:	f01ff0ef          	jal	ra,40002fa8 <ready_thread>
	z_reschedule(&sched_spinlock, key);
400030ac:	00c12583          	lw	a1,12(sp)
}
400030b0:	01c12083          	lw	ra,28(sp)
	z_reschedule(&sched_spinlock, key);
400030b4:	40004537          	lui	a0,0x40004
400030b8:	5b850513          	addi	a0,a0,1464 # 400045b8 <sched_spinlock>
}
400030bc:	02010113          	addi	sp,sp,32
	z_reschedule(&sched_spinlock, key);
400030c0:	d55ff06f          	j	40002e14 <z_reschedule>

400030c4 <z_thread_timeout>:
{
400030c4:	fe010113          	addi	sp,sp,-32
400030c8:	00812c23          	sw	s0,24(sp)
400030cc:	00912a23          	sw	s1,20(sp)
400030d0:	00112e23          	sw	ra,28(sp)
400030d4:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
400030d8:	00800413          	li	s0,8
400030dc:	30043473          	csrrc	s0,mstatus,s0
		if (thread->base.pended_on != NULL) {
400030e0:	ff04a783          	lw	a5,-16(s1)
	key = (mstatus & MSTATUS_IEN);
400030e4:	00847413          	andi	s0,s0,8
		struct k_thread *thread = CONTAINER_OF(timeout,
400030e8:	fe850513          	addi	a0,a0,-24
		if (thread->base.pended_on != NULL) {
400030ec:	00078863          	beqz	a5,400030fc <z_thread_timeout+0x38>
			unpend_thread_no_timeout(thread);
400030f0:	00a12623          	sw	a0,12(sp)
400030f4:	c1dff0ef          	jal	ra,40002d10 <unpend_thread_no_timeout>
400030f8:	00c12503          	lw	a0,12(sp)
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
400030fc:	ff54c783          	lbu	a5,-11(s1)
40003100:	feb7f793          	andi	a5,a5,-21
40003104:	fef48aa3          	sb	a5,-11(s1)
		ready_thread(thread);
40003108:	ea1ff0ef          	jal	ra,40002fa8 <ready_thread>
	__asm__ volatile ("csrrs %0, mstatus, %1"
4000310c:	30042473          	csrrs	s0,mstatus,s0
}
40003110:	01c12083          	lw	ra,28(sp)
40003114:	01812403          	lw	s0,24(sp)
40003118:	01412483          	lw	s1,20(sp)
4000311c:	02010113          	addi	sp,sp,32
40003120:	00008067          	ret

40003124 <move_thread_to_end_of_prio_q>:
{
40003124:	ff010113          	addi	sp,sp,-16
40003128:	00812423          	sw	s0,8(sp)
4000312c:	00112623          	sw	ra,12(sp)
	if (z_is_thread_queued(thread)) {
40003130:	00d50783          	lb	a5,13(a0)
{
40003134:	00050413          	mv	s0,a0
	if (z_is_thread_queued(thread)) {
40003138:	0007d463          	bgez	a5,40003140 <move_thread_to_end_of_prio_q+0x1c>
	sys_dlist_remove(&thread->base.qnode_dlist);
4000313c:	bb9ff0ef          	jal	ra,40002cf4 <sys_dlist_remove>
	return list->head == list;
40003140:	40004737          	lui	a4,0x40004
40003144:	77870693          	addi	a3,a4,1912 # 40004778 <_kernel>
40003148:	0286a783          	lw	a5,40(a3)
	return (node == list->tail) ? NULL : node->next;
4000314c:	02c6a603          	lw	a2,44(a3)
40003150:	400046b7          	lui	a3,0x40004
40003154:	7a068693          	addi	a3,a3,1952 # 400047a0 <_kernel+0x28>
40003158:	77870713          	addi	a4,a4,1912
	return sys_dlist_is_empty(list) ? NULL : list->head;
4000315c:	04d78e63          	beq	a5,a3,400031b8 <move_thread_to_end_of_prio_q+0x94>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40003160:	04078c63          	beqz	a5,400031b8 <move_thread_to_end_of_prio_q+0x94>
	if (thread_1->base.prio < thread_2->base.prio) {
40003164:	00e40583          	lb	a1,14(s0)
40003168:	00e78503          	lb	a0,14(a5)
4000316c:	04a5d063          	bge	a1,a0,400031ac <move_thread_to_end_of_prio_q+0x88>
	node->prev = successor->prev;
40003170:	0047a683          	lw	a3,4(a5)
	node->next = successor;
40003174:	00f42023          	sw	a5,0(s0)
	node->prev = successor->prev;
40003178:	00d42223          	sw	a3,4(s0)
	successor->prev->next = node;
4000317c:	0086a023          	sw	s0,0(a3)
	successor->prev = node;
40003180:	0087a223          	sw	s0,4(a5)
	thread->base.thread_state |= states;
40003184:	00d44783          	lbu	a5,13(s0)
	update_cache(thread == _current);
40003188:	00872503          	lw	a0,8(a4)
}
4000318c:	00c12083          	lw	ra,12(sp)
40003190:	f807e793          	ori	a5,a5,-128
40003194:	00f406a3          	sb	a5,13(s0)
	update_cache(thread == _current);
40003198:	40850533          	sub	a0,a0,s0
}
4000319c:	00812403          	lw	s0,8(sp)
	update_cache(thread == _current);
400031a0:	00153513          	seqz	a0,a0
}
400031a4:	01010113          	addi	sp,sp,16
	update_cache(thread == _current);
400031a8:	d0dff06f          	j	40002eb4 <update_cache>
	return (node == list->tail) ? NULL : node->next;
400031ac:	00f60663          	beq	a2,a5,400031b8 <move_thread_to_end_of_prio_q+0x94>
400031b0:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
400031b4:	fa079ae3          	bnez	a5,40003168 <move_thread_to_end_of_prio_q+0x44>
	node->prev = list->tail;
400031b8:	00c42223          	sw	a2,4(s0)
	list->tail->next = node;
400031bc:	02c72783          	lw	a5,44(a4)
	node->next = list;
400031c0:	00d42023          	sw	a3,0(s0)
	list->tail->next = node;
400031c4:	0087a023          	sw	s0,0(a5)
	list->tail = node;
400031c8:	02872623          	sw	s0,44(a4)
}
400031cc:	fb9ff06f          	j	40003184 <move_thread_to_end_of_prio_q+0x60>

400031d0 <z_time_slice>:
{
400031d0:	ff010113          	addi	sp,sp,-16
400031d4:	00812423          	sw	s0,8(sp)
400031d8:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
400031dc:	00800413          	li	s0,8
400031e0:	30043473          	csrrc	s0,mstatus,s0
	if (slice_time && sliceable(_current)) {
400031e4:	400047b7          	lui	a5,0x40004
400031e8:	5c07a703          	lw	a4,1472(a5) # 400045c0 <slice_time>
400031ec:	400047b7          	lui	a5,0x40004
	key = (mstatus & MSTATUS_IEN);
400031f0:	00847413          	andi	s0,s0,8
400031f4:	77878793          	addi	a5,a5,1912 # 40004778 <_kernel>
400031f8:	06070863          	beqz	a4,40003268 <z_time_slice+0x98>
400031fc:	00050693          	mv	a3,a0
40003200:	0087a503          	lw	a0,8(a5)
		&& !z_is_idle_thread_object(thread);
40003204:	07f00713          	li	a4,127
40003208:	00e55603          	lhu	a2,14(a0)
4000320c:	04c76e63          	bltu	a4,a2,40003268 <z_time_slice+0x98>
		&& !z_is_thread_prevented_from_running(thread)
40003210:	00d54703          	lbu	a4,13(a0)
40003214:	01f77713          	andi	a4,a4,31
40003218:	04071863          	bnez	a4,40003268 <z_time_slice+0x98>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
4000321c:	40004737          	lui	a4,0x40004
40003220:	00e50603          	lb	a2,14(a0)
40003224:	5bc72703          	lw	a4,1468(a4) # 400045bc <slice_max_prio>
40003228:	04e64063          	blt	a2,a4,40003268 <z_time_slice+0x98>
		&& !z_is_idle_thread_object(thread);
4000322c:	40004737          	lui	a4,0x40004
40003230:	65070713          	addi	a4,a4,1616 # 40004650 <z_idle_threads>
40003234:	02e50a63          	beq	a0,a4,40003268 <z_time_slice+0x98>
		if (ticks >= _current_cpu->slice_ticks) {
40003238:	0147a703          	lw	a4,20(a5)
4000323c:	02e6c063          	blt	a3,a4,4000325c <z_time_slice+0x8c>
			move_thread_to_end_of_prio_q(_current);
40003240:	ee5ff0ef          	jal	ra,40003124 <move_thread_to_end_of_prio_q>
			z_reset_time_slice();
40003244:	b01ff0ef          	jal	ra,40002d44 <z_reset_time_slice>
	__asm__ volatile ("csrrs %0, mstatus, %1"
40003248:	30042473          	csrrs	s0,mstatus,s0
}
4000324c:	00c12083          	lw	ra,12(sp)
40003250:	00812403          	lw	s0,8(sp)
40003254:	01010113          	addi	sp,sp,16
40003258:	00008067          	ret
			_current_cpu->slice_ticks -= ticks;
4000325c:	40d70733          	sub	a4,a4,a3
40003260:	00e7aa23          	sw	a4,20(a5)
40003264:	fe5ff06f          	j	40003248 <z_time_slice+0x78>
		_current_cpu->slice_ticks = 0;
40003268:	0007aa23          	sw	zero,20(a5)
4000326c:	fddff06f          	j	40003248 <z_time_slice+0x78>

40003270 <z_impl_k_thread_suspend>:
{
40003270:	ff010113          	addi	sp,sp,-16
40003274:	00812423          	sw	s0,8(sp)
40003278:	00050413          	mv	s0,a0
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
4000327c:	01850513          	addi	a0,a0,24
40003280:	00912223          	sw	s1,4(sp)
40003284:	00112623          	sw	ra,12(sp)
40003288:	01212023          	sw	s2,0(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
4000328c:	00800493          	li	s1,8
40003290:	261000ef          	jal	ra,40003cf0 <z_abort_timeout>
40003294:	3004b4f3          	csrrc	s1,mstatus,s1
		if (z_is_thread_queued(thread)) {
40003298:	00d40783          	lb	a5,13(s0)
	key = (mstatus & MSTATUS_IEN);
4000329c:	0084f493          	andi	s1,s1,8
400032a0:	0007dc63          	bgez	a5,400032b8 <z_impl_k_thread_suspend+0x48>
	sys_dlist_remove(&thread->base.qnode_dlist);
400032a4:	00040513          	mv	a0,s0
400032a8:	a4dff0ef          	jal	ra,40002cf4 <sys_dlist_remove>
	thread->base.thread_state &= ~states;
400032ac:	00d44783          	lbu	a5,13(s0)
400032b0:	07f7f793          	andi	a5,a5,127
400032b4:	00f406a3          	sb	a5,13(s0)
		update_cache(thread == _current);
400032b8:	40004937          	lui	s2,0x40004
400032bc:	77890913          	addi	s2,s2,1912 # 40004778 <_kernel>
	thread->base.thread_state |= _THREAD_SUSPENDED;
400032c0:	00d44783          	lbu	a5,13(s0)
400032c4:	00892503          	lw	a0,8(s2)
400032c8:	0107e793          	ori	a5,a5,16
400032cc:	40850533          	sub	a0,a0,s0
400032d0:	00f406a3          	sb	a5,13(s0)
400032d4:	00153513          	seqz	a0,a0
400032d8:	bddff0ef          	jal	ra,40002eb4 <update_cache>
	__asm__ volatile ("csrrs %0, mstatus, %1"
400032dc:	3004a4f3          	csrrs	s1,mstatus,s1
	if (thread == _current) {
400032e0:	00892783          	lw	a5,8(s2)
400032e4:	00879e63          	bne	a5,s0,40003300 <z_impl_k_thread_suspend+0x90>
}
400032e8:	00812403          	lw	s0,8(sp)
400032ec:	00c12083          	lw	ra,12(sp)
400032f0:	00412483          	lw	s1,4(sp)
400032f4:	00012903          	lw	s2,0(sp)
400032f8:	01010113          	addi	sp,sp,16
		z_reschedule_unlocked();
400032fc:	b6dff06f          	j	40002e68 <z_reschedule_unlocked>
}
40003300:	00c12083          	lw	ra,12(sp)
40003304:	00812403          	lw	s0,8(sp)
40003308:	00412483          	lw	s1,4(sp)
4000330c:	00012903          	lw	s2,0(sp)
40003310:	01010113          	addi	sp,sp,16
40003314:	00008067          	ret

40003318 <z_thread_single_abort>:
{
40003318:	fe010113          	addi	sp,sp,-32
4000331c:	00912a23          	sw	s1,20(sp)
40003320:	00112e23          	sw	ra,28(sp)
40003324:	00812c23          	sw	s0,24(sp)
40003328:	01212823          	sw	s2,16(sp)
4000332c:	01312623          	sw	s3,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003330:	00800493          	li	s1,8
40003334:	3004b7f3          	csrrc	a5,mstatus,s1
	if ((thread->base.thread_state &
40003338:	00d54703          	lbu	a4,13(a0)
	key = (mstatus & MSTATUS_IEN);
4000333c:	0087f793          	andi	a5,a5,8
40003340:	02877693          	andi	a3,a4,40
40003344:	02068263          	beqz	a3,40003368 <z_thread_single_abort+0x50>
	__asm__ volatile ("csrrs %0, mstatus, %1"
40003348:	3007a7f3          	csrrs	a5,mstatus,a5
}
4000334c:	01c12083          	lw	ra,28(sp)
40003350:	01812403          	lw	s0,24(sp)
40003354:	01412483          	lw	s1,20(sp)
40003358:	01012903          	lw	s2,16(sp)
4000335c:	00c12983          	lw	s3,12(sp)
40003360:	02010113          	addi	sp,sp,32
40003364:	00008067          	ret
	thread->base.thread_state |= _THREAD_ABORTING;
40003368:	02076713          	ori	a4,a4,32
4000336c:	00050413          	mv	s0,a0
40003370:	00e506a3          	sb	a4,13(a0)
40003374:	3007a7f3          	csrrs	a5,mstatus,a5
40003378:	01850513          	addi	a0,a0,24
4000337c:	175000ef          	jal	ra,40003cf0 <z_abort_timeout>
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003380:	3004b4f3          	csrrc	s1,mstatus,s1
	uint8_t state = thread->base.thread_state;
40003384:	00d44783          	lbu	a5,13(s0)
	key = (mstatus & MSTATUS_IEN);
40003388:	0084f913          	andi	s2,s1,8
	return !((z_is_thread_prevented_from_running(thread)) != 0U ||
4000338c:	01f7f713          	andi	a4,a5,31
40003390:	04071463          	bnez	a4,400033d8 <z_thread_single_abort+0xc0>
		if (z_is_thread_ready(thread)) {
40003394:	01842703          	lw	a4,24(s0)
40003398:	04071063          	bnez	a4,400033d8 <z_thread_single_abort+0xc0>
			if (z_is_thread_queued(thread)) {
4000339c:	01879793          	slli	a5,a5,0x18
400033a0:	4187d793          	srai	a5,a5,0x18
400033a4:	0007dc63          	bgez	a5,400033bc <z_thread_single_abort+0xa4>
	sys_dlist_remove(&thread->base.qnode_dlist);
400033a8:	00040513          	mv	a0,s0
400033ac:	949ff0ef          	jal	ra,40002cf4 <sys_dlist_remove>
	thread->base.thread_state &= ~states;
400033b0:	00d44783          	lbu	a5,13(s0)
400033b4:	07f7f793          	andi	a5,a5,127
400033b8:	00f406a3          	sb	a5,13(s0)
			update_cache(thread == _current);
400033bc:	400047b7          	lui	a5,0x40004
400033c0:	7807a503          	lw	a0,1920(a5) # 40004780 <_kernel+0x8>
400033c4:	40850533          	sub	a0,a0,s0
400033c8:	00153513          	seqz	a0,a0
400033cc:	ae9ff0ef          	jal	ra,40002eb4 <update_cache>
	sys_dlist_init(&w->waitq);
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
400033d0:	03040993          	addi	s3,s0,48
400033d4:	0540006f          	j	40003428 <z_thread_single_abort+0x110>
			if (z_is_thread_pending(thread)) {
400033d8:	0027f793          	andi	a5,a5,2
400033dc:	fe078ae3          	beqz	a5,400033d0 <z_thread_single_abort+0xb8>
	sys_dlist_remove(&thread->base.qnode_dlist);
400033e0:	00040513          	mv	a0,s0
400033e4:	911ff0ef          	jal	ra,40002cf4 <sys_dlist_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
400033e8:	00d44783          	lbu	a5,13(s0)
				thread->base.pended_on = NULL;
400033ec:	00042423          	sw	zero,8(s0)
400033f0:	ffd7f793          	andi	a5,a5,-3
400033f4:	00f406a3          	sb	a5,13(s0)
400033f8:	fd9ff06f          	j	400033d0 <z_thread_single_abort+0xb8>
400033fc:	01848513          	addi	a0,s1,24
40003400:	0f1000ef          	jal	ra,40003cf0 <z_abort_timeout>
	sys_dlist_remove(&thread->base.qnode_dlist);
40003404:	00048513          	mv	a0,s1
40003408:	8edff0ef          	jal	ra,40002cf4 <sys_dlist_remove>
4000340c:	00d4c783          	lbu	a5,13(s1)
			waiter->base.pended_on = NULL;
40003410:	0004a423          	sw	zero,8(s1)
	thread->arch.swap_return_value = value;
40003414:	0604ae23          	sw	zero,124(s1)
40003418:	ffd7f793          	andi	a5,a5,-3
4000341c:	00f486a3          	sb	a5,13(s1)
			ready_thread(waiter);
40003420:	00048513          	mv	a0,s1
40003424:	b85ff0ef          	jal	ra,40002fa8 <ready_thread>
	return list->head == list;
40003428:	03042483          	lw	s1,48(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
4000342c:	01348463          	beq	s1,s3,40003434 <z_thread_single_abort+0x11c>
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
40003430:	fc0496e3          	bnez	s1,400033fc <z_thread_single_abort+0xe4>
		if (z_is_idle_thread_object(_current)) {
40003434:	400047b7          	lui	a5,0x40004
40003438:	7807a703          	lw	a4,1920(a5) # 40004780 <_kernel+0x8>
4000343c:	400047b7          	lui	a5,0x40004
40003440:	65078793          	addi	a5,a5,1616 # 40004650 <z_idle_threads>
40003444:	00f71663          	bne	a4,a5,40003450 <z_thread_single_abort+0x138>
			update_cache(1);
40003448:	00100513          	li	a0,1
4000344c:	a69ff0ef          	jal	ra,40002eb4 <update_cache>
		thread->base.thread_state |= _THREAD_DEAD;
40003450:	00d44783          	lbu	a5,13(s0)
40003454:	0087e793          	ori	a5,a5,8
40003458:	00f406a3          	sb	a5,13(s0)
		fn_abort = thread->fn_abort;
4000345c:	07042783          	lw	a5,112(s0)
	__asm__ volatile ("csrrs %0, mstatus, %1"
40003460:	30092973          	csrrs	s2,mstatus,s2
	if (fn_abort != NULL) {
40003464:	ee0784e3          	beqz	a5,4000334c <z_thread_single_abort+0x34>
		fn_abort(thread);
40003468:	00040513          	mv	a0,s0
}
4000346c:	01812403          	lw	s0,24(sp)
40003470:	01c12083          	lw	ra,28(sp)
40003474:	01412483          	lw	s1,20(sp)
40003478:	01012903          	lw	s2,16(sp)
4000347c:	00c12983          	lw	s3,12(sp)
40003480:	02010113          	addi	sp,sp,32
		fn_abort(thread);
40003484:	00078067          	jr	a5

40003488 <unready_thread>:
{
40003488:	ff010113          	addi	sp,sp,-16
4000348c:	00812423          	sw	s0,8(sp)
40003490:	00112623          	sw	ra,12(sp)
	if (z_is_thread_queued(thread)) {
40003494:	00d50783          	lb	a5,13(a0)
{
40003498:	00050413          	mv	s0,a0
	if (z_is_thread_queued(thread)) {
4000349c:	0007da63          	bgez	a5,400034b0 <unready_thread+0x28>
	sys_dlist_remove(&thread->base.qnode_dlist);
400034a0:	855ff0ef          	jal	ra,40002cf4 <sys_dlist_remove>
	thread->base.thread_state &= ~states;
400034a4:	00d44783          	lbu	a5,13(s0)
400034a8:	07f7f793          	andi	a5,a5,127
400034ac:	00f406a3          	sb	a5,13(s0)
	update_cache(thread == _current);
400034b0:	400047b7          	lui	a5,0x40004
400034b4:	7807a503          	lw	a0,1920(a5) # 40004780 <_kernel+0x8>
}
400034b8:	00c12083          	lw	ra,12(sp)
	update_cache(thread == _current);
400034bc:	40850533          	sub	a0,a0,s0
}
400034c0:	00812403          	lw	s0,8(sp)
	update_cache(thread == _current);
400034c4:	00153513          	seqz	a0,a0
}
400034c8:	01010113          	addi	sp,sp,16
	update_cache(thread == _current);
400034cc:	9e9ff06f          	j	40002eb4 <update_cache>

400034d0 <add_to_waitq_locked>:
{
400034d0:	ff010113          	addi	sp,sp,-16
400034d4:	00812423          	sw	s0,8(sp)
400034d8:	00912223          	sw	s1,4(sp)
400034dc:	00050413          	mv	s0,a0
400034e0:	00112623          	sw	ra,12(sp)
400034e4:	00058493          	mv	s1,a1
	unready_thread(thread);
400034e8:	fa1ff0ef          	jal	ra,40003488 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
400034ec:	00d44783          	lbu	a5,13(s0)
400034f0:	0027e793          	ori	a5,a5,2
400034f4:	00f406a3          	sb	a5,13(s0)
	if (wait_q != NULL) {
400034f8:	02048a63          	beqz	s1,4000352c <add_to_waitq_locked+0x5c>
	return list->head == list;
400034fc:	0004a783          	lw	a5,0(s1)
		thread->base.pended_on = wait_q;
40003500:	00942423          	sw	s1,8(s0)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40003504:	04f48663          	beq	s1,a5,40003550 <add_to_waitq_locked+0x80>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
40003508:	04078463          	beqz	a5,40003550 <add_to_waitq_locked+0x80>
	if (thread_1->base.prio < thread_2->base.prio) {
4000350c:	00e40703          	lb	a4,14(s0)
40003510:	00e78683          	lb	a3,14(a5)
40003514:	02d75663          	bge	a4,a3,40003540 <add_to_waitq_locked+0x70>
	node->prev = successor->prev;
40003518:	0047a703          	lw	a4,4(a5)
	node->next = successor;
4000351c:	00f42023          	sw	a5,0(s0)
	node->prev = successor->prev;
40003520:	00e42223          	sw	a4,4(s0)
	successor->prev->next = node;
40003524:	00872023          	sw	s0,0(a4)
	successor->prev = node;
40003528:	0087a223          	sw	s0,4(a5)
}
4000352c:	00c12083          	lw	ra,12(sp)
40003530:	00812403          	lw	s0,8(sp)
40003534:	00412483          	lw	s1,4(sp)
40003538:	01010113          	addi	sp,sp,16
4000353c:	00008067          	ret
	return (node == list->tail) ? NULL : node->next;
40003540:	0044a683          	lw	a3,4(s1)
40003544:	00d78663          	beq	a5,a3,40003550 <add_to_waitq_locked+0x80>
40003548:	0007a783          	lw	a5,0(a5)
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
4000354c:	fc0792e3          	bnez	a5,40003510 <add_to_waitq_locked+0x40>
	node->prev = list->tail;
40003550:	0044a783          	lw	a5,4(s1)
	node->next = list;
40003554:	00942023          	sw	s1,0(s0)
	node->prev = list->tail;
40003558:	00f42223          	sw	a5,4(s0)
	list->tail->next = node;
4000355c:	0044a783          	lw	a5,4(s1)
40003560:	0087a023          	sw	s0,0(a5)
	list->tail = node;
40003564:	0084a223          	sw	s0,4(s1)
}
40003568:	fc5ff06f          	j	4000352c <add_to_waitq_locked+0x5c>

4000356c <pend>:
{
4000356c:	fe010113          	addi	sp,sp,-32
40003570:	00812c23          	sw	s0,24(sp)
40003574:	00912a23          	sw	s1,20(sp)
40003578:	00112e23          	sw	ra,28(sp)
4000357c:	00050493          	mv	s1,a0
40003580:	00c12623          	sw	a2,12(sp)
40003584:	00d12423          	sw	a3,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003588:	00800413          	li	s0,8
4000358c:	30043473          	csrrc	s0,mstatus,s0
		add_to_waitq_locked(thread, wait_q);
40003590:	f41ff0ef          	jal	ra,400034d0 <add_to_waitq_locked>
	key = (mstatus & MSTATUS_IEN);
40003594:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
40003598:	30042473          	csrrs	s0,mstatus,s0
	add_thread_timeout(thread, timeout);
4000359c:	00c12603          	lw	a2,12(sp)
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
400035a0:	fff00593          	li	a1,-1
400035a4:	00812683          	lw	a3,8(sp)
400035a8:	00b61463          	bne	a2,a1,400035b0 <pend+0x44>
400035ac:	02c68263          	beq	a3,a2,400035d0 <pend+0x64>
}
400035b0:	01812403          	lw	s0,24(sp)
400035b4:	01c12083          	lw	ra,28(sp)
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
400035b8:	01848513          	addi	a0,s1,24
400035bc:	01412483          	lw	s1,20(sp)
400035c0:	400035b7          	lui	a1,0x40003
400035c4:	0c458593          	addi	a1,a1,196 # 400030c4 <z_thread_timeout>
400035c8:	02010113          	addi	sp,sp,32
400035cc:	55c0006f          	j	40003b28 <z_add_timeout>
400035d0:	01c12083          	lw	ra,28(sp)
400035d4:	01812403          	lw	s0,24(sp)
400035d8:	01412483          	lw	s1,20(sp)
400035dc:	02010113          	addi	sp,sp,32
400035e0:	00008067          	ret

400035e4 <z_pend_curr>:
	pend(_current, wait_q, timeout);
400035e4:	400047b7          	lui	a5,0x40004
400035e8:	7807a503          	lw	a0,1920(a5) # 40004780 <_kernel+0x8>
{
400035ec:	ff010113          	addi	sp,sp,-16
400035f0:	00812423          	sw	s0,8(sp)
400035f4:	00058413          	mv	s0,a1
400035f8:	00060593          	mv	a1,a2
400035fc:	00068613          	mv	a2,a3
40003600:	00070693          	mv	a3,a4
40003604:	00112623          	sw	ra,12(sp)
	pend(_current, wait_q, timeout);
40003608:	f65ff0ef          	jal	ra,4000356c <pend>
4000360c:	00040513          	mv	a0,s0
}
40003610:	00812403          	lw	s0,8(sp)
40003614:	00c12083          	lw	ra,12(sp)
40003618:	01010113          	addi	sp,sp,16
4000361c:	c89fc06f          	j	400002a4 <arch_swap>

40003620 <z_unpend_first_thread>:
{
40003620:	ff010113          	addi	sp,sp,-16
40003624:	00812423          	sw	s0,8(sp)
40003628:	00112623          	sw	ra,12(sp)
4000362c:	00912223          	sw	s1,4(sp)
40003630:	01212023          	sw	s2,0(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003634:	00800413          	li	s0,8
40003638:	30043973          	csrrc	s2,mstatus,s0
		ret = _priq_wait_best(&wait_q->waitq);
4000363c:	865ff0ef          	jal	ra,40002ea0 <z_priq_dumb_best>
40003640:	00050493          	mv	s1,a0
	key = (mstatus & MSTATUS_IEN);
40003644:	00897913          	andi	s2,s2,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
40003648:	30092973          	csrrs	s2,mstatus,s2

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
4000364c:	00050e63          	beqz	a0,40003668 <z_unpend_first_thread+0x48>
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003650:	30043473          	csrrc	s0,mstatus,s0
		unpend_thread_no_timeout(thread);
40003654:	ebcff0ef          	jal	ra,40002d10 <unpend_thread_no_timeout>
	key = (mstatus & MSTATUS_IEN);
40003658:	00847413          	andi	s0,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
4000365c:	30042473          	csrrs	s0,mstatus,s0
	return z_abort_timeout(&thread->base.timeout);
40003660:	01848513          	addi	a0,s1,24
40003664:	68c000ef          	jal	ra,40003cf0 <z_abort_timeout>
}
40003668:	00c12083          	lw	ra,12(sp)
4000366c:	00812403          	lw	s0,8(sp)
40003670:	00012903          	lw	s2,0(sp)
40003674:	00048513          	mv	a0,s1
40003678:	00412483          	lw	s1,4(sp)
4000367c:	01010113          	addi	sp,sp,16
40003680:	00008067          	ret

40003684 <z_sched_init>:
	list->head = (sys_dnode_t *)list;
40003684:	400047b7          	lui	a5,0x40004
40003688:	77878793          	addi	a5,a5,1912 # 40004778 <_kernel>
4000368c:	02878713          	addi	a4,a5,40
40003690:	02e7a423          	sw	a4,40(a5)
	list->tail = (sys_dnode_t *)list;
40003694:	02e7a623          	sw	a4,44(a5)
		sys_dlist_init(&_kernel.ready_q.runq.queues[i]);
	}
#endif

#ifdef CONFIG_TIMESLICING
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
40003698:	00000593          	li	a1,0
4000369c:	00000513          	li	a0,0
400036a0:	efcff06f          	j	40002d9c <k_sched_time_slice_set>

400036a4 <z_impl_k_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
400036a4:	400047b7          	lui	a5,0x40004
400036a8:	7807a503          	lw	a0,1920(a5) # 40004780 <_kernel+0x8>
400036ac:	00008067          	ret

400036b0 <z_impl_k_sem_init>:

#endif /* CONFIG_OBJECT_TRACING */

int z_impl_k_sem_init(struct k_sem *sem, unsigned int initial_count,
		      unsigned int limit)
{
400036b0:	00050793          	mv	a5,a0
	/*
	 * Limit cannot be zero and count cannot be greater than limit
	 */
	CHECKIF(limit == 0U || initial_count > limit) {
		return -EINVAL;
400036b4:	fea00513          	li	a0,-22
	CHECKIF(limit == 0U || initial_count > limit) {
400036b8:	02060063          	beqz	a2,400036d8 <z_impl_k_sem_init+0x28>
400036bc:	00b66e63          	bltu	a2,a1,400036d8 <z_impl_k_sem_init+0x28>
	}

	sem->count = initial_count;
400036c0:	00b7a423          	sw	a1,8(a5)
	sem->limit = limit;
400036c4:	00c7a623          	sw	a2,12(a5)
	list->head = (sys_dnode_t *)list;
400036c8:	00f7a023          	sw	a5,0(a5)
	list->tail = (sys_dnode_t *)list;
400036cc:	00f7a223          	sw	a5,4(a5)
	SYS_TRACING_OBJ_INIT(k_sem, sem);

	z_object_init(sem);
	sys_trace_end_call(SYS_TRACE_ID_SEMA_INIT);

	return 0;
400036d0:	00000513          	li	a0,0
400036d4:	00008067          	ret
}
400036d8:	00008067          	ret

400036dc <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
400036dc:	ff010113          	addi	sp,sp,-16
400036e0:	00812423          	sw	s0,8(sp)
400036e4:	00912223          	sw	s1,4(sp)
400036e8:	00112623          	sw	ra,12(sp)
400036ec:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
400036f0:	00800413          	li	s0,8
400036f4:	30043473          	csrrc	s0,mstatus,s0
	key = (mstatus & MSTATUS_IEN);
400036f8:	00847413          	andi	s0,s0,8
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread;

	sys_trace_semaphore_give(sem);
	thread = z_unpend_first_thread(&sem->wait_q);
400036fc:	f25ff0ef          	jal	ra,40003620 <z_unpend_first_thread>

	if (thread != NULL) {
40003700:	02050663          	beqz	a0,4000372c <z_impl_k_sem_give+0x50>
40003704:	06052e23          	sw	zero,124(a0)
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
40003708:	93dff0ef          	jal	ra,40003044 <z_ready_thread>
	} else {
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	z_reschedule(&lock, key);
4000370c:	00040593          	mv	a1,s0
	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
}
40003710:	00812403          	lw	s0,8(sp)
40003714:	00c12083          	lw	ra,12(sp)
40003718:	00412483          	lw	s1,4(sp)
	z_reschedule(&lock, key);
4000371c:	40004537          	lui	a0,0x40004
40003720:	5c450513          	addi	a0,a0,1476 # 400045c4 <lock>
}
40003724:	01010113          	addi	sp,sp,16
	z_reschedule(&lock, key);
40003728:	eecff06f          	j	40002e14 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
4000372c:	0084a703          	lw	a4,8(s1)
40003730:	00c4a783          	lw	a5,12(s1)
40003734:	40e787b3          	sub	a5,a5,a4
40003738:	00f037b3          	snez	a5,a5
4000373c:	00e787b3          	add	a5,a5,a4
40003740:	00f4a423          	sw	a5,8(s1)
}
40003744:	fc9ff06f          	j	4000370c <z_impl_k_sem_give+0x30>

40003748 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
40003748:	00058693          	mv	a3,a1
4000374c:	00060713          	mv	a4,a2
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003750:	00800793          	li	a5,8
40003754:	3007b7f3          	csrrc	a5,mstatus,a5
	key = (mstatus & MSTATUS_IEN);
40003758:	0087f593          	andi	a1,a5,8
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	k_spinlock_key_t key = k_spin_lock(&lock);
	sys_trace_semaphore_take(sem);

	if (likely(sem->count > 0U)) {
4000375c:	00852783          	lw	a5,8(a0)
40003760:	00078c63          	beqz	a5,40003778 <z_impl_k_sem_take+0x30>
		sem->count--;
40003764:	fff78793          	addi	a5,a5,-1
40003768:	00f52423          	sw	a5,8(a0)
	__asm__ volatile ("csrrs %0, mstatus, %1"
4000376c:	3005a5f3          	csrrs	a1,mstatus,a1
		k_spin_unlock(&lock, key);
		ret = 0;
40003770:	00000513          	li	a0,0
		goto out;
40003774:	00008067          	ret
	}

	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
40003778:	00c6e7b3          	or	a5,a3,a2
4000377c:	00079863          	bnez	a5,4000378c <z_impl_k_sem_take+0x44>
40003780:	3005a5f3          	csrrs	a1,mstatus,a1
		k_spin_unlock(&lock, key);
		ret = -EBUSY;
40003784:	ff000513          	li	a0,-16
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
40003788:	00008067          	ret
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
4000378c:	00050613          	mv	a2,a0
40003790:	40004537          	lui	a0,0x40004
40003794:	5c450513          	addi	a0,a0,1476 # 400045c4 <lock>
40003798:	e4dff06f          	j	400035e4 <z_pend_curr>

4000379c <z_setup_new_thread>:
char *z_setup_new_thread(struct k_thread *new_thread,
			 k_thread_stack_t *stack, size_t stack_size,
			 k_thread_entry_t entry,
			 void *p1, void *p2, void *p3,
			 int prio, uint32_t options, const char *name)
{
4000379c:	ff010113          	addi	sp,sp,-16
400037a0:	00812423          	sw	s0,8(sp)
400037a4:	00912223          	sw	s1,4(sp)
400037a8:	00112623          	sw	ra,12(sp)
	sys_dlist_init(&w->waitq);
400037ac:	03050313          	addi	t1,a0,48
	list->head = (sys_dnode_t *)list;
400037b0:	02652823          	sw	t1,48(a0)
	list->tail = (sys_dnode_t *)list;
400037b4:	02652a23          	sw	t1,52(a0)
void z_init_thread_base(struct _thread_base *thread_base, int priority,
		       uint32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (uint8_t)options;
400037b8:	01012303          	lw	t1,16(sp)
		stack_obj_size = Z_KERNEL_STACK_SIZE_ADJUST(stack_size);
400037bc:	00f60613          	addi	a2,a2,15
400037c0:	ff067613          	andi	a2,a2,-16
	stack_ptr = (char *)stack + stack_obj_size;
400037c4:	00c584b3          	add	s1,a1,a2
	thread_base->user_options = (uint8_t)options;
400037c8:	00650623          	sb	t1,12(a0)
	thread_base->thread_state = (uint8_t)initial_state;
400037cc:	00400313          	li	t1,4
400037d0:	006506a3          	sb	t1,13(a0)

	thread_base->prio = priority;
400037d4:	01150723          	sb	a7,14(a0)

	thread_base->sched_locked = 0U;
400037d8:	000507a3          	sb	zero,15(a0)
	node->next = NULL;
400037dc:	00052c23          	sw	zero,24(a0)
	node->prev = NULL;
400037e0:	00052e23          	sw	zero,28(a0)
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
400037e4:	00048613          	mv	a2,s1
{
400037e8:	00050413          	mv	s0,a0
	arch_new_thread(new_thread, stack, stack_ptr, entry, p1, p2, p3);
400037ec:	f85fe0ef          	jal	ra,40002770 <arch_new_thread>
	new_thread->resource_pool = _current->resource_pool;
400037f0:	400047b7          	lui	a5,0x40004
400037f4:	7807a783          	lw	a5,1920(a5) # 40004780 <_kernel+0x8>
}
400037f8:	00c12083          	lw	ra,12(sp)
	new_thread->init_data = NULL;
400037fc:	06042623          	sw	zero,108(s0)
	new_thread->resource_pool = _current->resource_pool;
40003800:	0787a783          	lw	a5,120(a5)
	new_thread->fn_abort = NULL;
40003804:	06042823          	sw	zero,112(s0)
}
40003808:	00048513          	mv	a0,s1
	new_thread->resource_pool = _current->resource_pool;
4000380c:	06f42c23          	sw	a5,120(s0)
}
40003810:	00812403          	lw	s0,8(sp)
40003814:	00412483          	lw	s1,4(sp)
40003818:	01010113          	addi	sp,sp,16
4000381c:	00008067          	ret

40003820 <z_impl_k_thread_create>:
{
40003820:	fe010113          	addi	sp,sp,-32
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
40003824:	02012303          	lw	t1,32(sp)
{
40003828:	01212823          	sw	s2,16(sp)
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
4000382c:	00012223          	sw	zero,4(sp)
{
40003830:	02812903          	lw	s2,40(sp)
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
40003834:	00612023          	sw	t1,0(sp)
{
40003838:	00812c23          	sw	s0,24(sp)
4000383c:	00912a23          	sw	s1,20(sp)
40003840:	00112e23          	sw	ra,28(sp)
40003844:	02c12483          	lw	s1,44(sp)
40003848:	00050413          	mv	s0,a0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
4000384c:	f51ff0ef          	jal	ra,4000379c <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
40003850:	fff00693          	li	a3,-1
40003854:	00d91463          	bne	s2,a3,4000385c <z_impl_k_thread_create+0x3c>
40003858:	01248a63          	beq	s1,s2,4000386c <z_impl_k_thread_create+0x4c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
4000385c:	0124e7b3          	or	a5,s1,s2
40003860:	02079463          	bnez	a5,40003888 <z_impl_k_thread_create+0x68>
	z_sched_start(thread);
40003864:	00040513          	mv	a0,s0
40003868:	80dff0ef          	jal	ra,40003074 <z_sched_start>
}
4000386c:	01c12083          	lw	ra,28(sp)
40003870:	00040513          	mv	a0,s0
40003874:	01812403          	lw	s0,24(sp)
40003878:	01412483          	lw	s1,20(sp)
4000387c:	01012903          	lw	s2,16(sp)
40003880:	02010113          	addi	sp,sp,32
40003884:	00008067          	ret
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
40003888:	400035b7          	lui	a1,0x40003
4000388c:	00090613          	mv	a2,s2
40003890:	00048693          	mv	a3,s1
40003894:	0c458593          	addi	a1,a1,196 # 400030c4 <z_thread_timeout>
40003898:	01840513          	addi	a0,s0,24
4000389c:	28c000ef          	jal	ra,40003b28 <z_add_timeout>
400038a0:	fcdff06f          	j	4000386c <z_impl_k_thread_create+0x4c>

400038a4 <z_init_static_threads>:
{
400038a4:	fd010113          	addi	sp,sp,-48
	_FOREACH_STATIC_THREAD(thread_data) {
400038a8:	400067b7          	lui	a5,0x40006
{
400038ac:	03212023          	sw	s2,32(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
400038b0:	40006937          	lui	s2,0x40006
{
400038b4:	02812423          	sw	s0,40(sp)
400038b8:	02912223          	sw	s1,36(sp)
400038bc:	02112623          	sw	ra,44(sp)
400038c0:	01312e23          	sw	s3,28(sp)
	_FOREACH_STATIC_THREAD(thread_data) {
400038c4:	e4078413          	addi	s0,a5,-448 # 40005e40 <__data_ram_end>
400038c8:	e4078493          	addi	s1,a5,-448
400038cc:	e4090913          	addi	s2,s2,-448 # 40005e40 <__data_ram_end>
400038d0:	03246a63          	bltu	s0,s2,40003904 <z_init_static_threads+0x60>
	_FOREACH_STATIC_THREAD(thread_data) {
400038d4:	00048413          	mv	s0,s1
	k_sched_lock();
400038d8:	da0ff0ef          	jal	ra,40002e78 <k_sched_lock>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
400038dc:	fff00493          	li	s1,-1
400038e0:	400039b7          	lui	s3,0x40003
	_FOREACH_STATIC_THREAD(thread_data) {
400038e4:	07246263          	bltu	s0,s2,40003948 <z_init_static_threads+0xa4>
}
400038e8:	02812403          	lw	s0,40(sp)
400038ec:	02c12083          	lw	ra,44(sp)
400038f0:	02412483          	lw	s1,36(sp)
400038f4:	02012903          	lw	s2,32(sp)
400038f8:	01c12983          	lw	s3,28(sp)
400038fc:	03010113          	addi	sp,sp,48
	k_sched_unlock();
40003900:	e60ff06f          	j	40002f60 <k_sched_unlock>
		z_setup_new_thread(
40003904:	02c42783          	lw	a5,44(s0)
40003908:	00f12223          	sw	a5,4(sp)
4000390c:	02042783          	lw	a5,32(s0)
40003910:	00f12023          	sw	a5,0(sp)
40003914:	01442783          	lw	a5,20(s0)
40003918:	01c42883          	lw	a7,28(s0)
4000391c:	01842803          	lw	a6,24(s0)
40003920:	01042703          	lw	a4,16(s0)
40003924:	00c42683          	lw	a3,12(s0)
40003928:	00842603          	lw	a2,8(s0)
4000392c:	00442583          	lw	a1,4(s0)
40003930:	00042503          	lw	a0,0(s0)
40003934:	e69ff0ef          	jal	ra,4000379c <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
40003938:	00042783          	lw	a5,0(s0)
4000393c:	0687a623          	sw	s0,108(a5)
	_FOREACH_STATIC_THREAD(thread_data) {
40003940:	03040413          	addi	s0,s0,48
40003944:	f8dff06f          	j	400038d0 <z_init_static_threads+0x2c>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
40003948:	02442603          	lw	a2,36(s0)
4000394c:	00960863          	beq	a2,s1,4000395c <z_init_static_threads+0xb8>
			schedule_new_thread(thread_data->init_thread,
40003950:	00042503          	lw	a0,0(s0)
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
40003954:	00c04863          	bgtz	a2,40003964 <z_init_static_threads+0xc0>
	z_sched_start(thread);
40003958:	f1cff0ef          	jal	ra,40003074 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
4000395c:	03040413          	addi	s0,s0,48
40003960:	f85ff06f          	j	400038e4 <z_init_static_threads+0x40>
40003964:	41f65693          	srai	a3,a2,0x1f
40003968:	0c498593          	addi	a1,s3,196 # 400030c4 <z_thread_timeout>
4000396c:	01850513          	addi	a0,a0,24
40003970:	1b8000ef          	jal	ra,40003b28 <z_add_timeout>
40003974:	fe9ff06f          	j	4000395c <z_init_static_threads+0xb8>

40003978 <z_self_abort>:
#include <syscall_handler.h>
#include <logging/log.h>
LOG_MODULE_DECLARE(os, CONFIG_KERNEL_LOG_LEVEL);

FUNC_NORETURN void z_self_abort(void)
{
40003978:	ff010113          	addi	sp,sp,-16
4000397c:	00812423          	sw	s0,8(sp)
40003980:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003984:	00800413          	li	s0,8
40003988:	30043473          	csrrc	s0,mstatus,s0
	 * while we set this up
	 */
	key = arch_irq_lock();
	cpu = _current_cpu;
	__ASSERT(cpu->pending_abort == NULL, "already have a thread to abort");
	cpu->pending_abort = _current;
4000398c:	400047b7          	lui	a5,0x40004
40003990:	77878793          	addi	a5,a5,1912 # 40004778 <_kernel>
40003994:	0087a503          	lw	a0,8(a5)
40003998:	00a7a823          	sw	a0,16(a5)
	z_impl_k_thread_suspend(thread);
4000399c:	8d5ff0ef          	jal	ra,40003270 <z_impl_k_thread_suspend>
400039a0:	00847513          	andi	a0,s0,8
400039a4:	901fc0ef          	jal	ra,400002a4 <arch_swap>

400039a8 <z_impl_k_thread_abort>:
}

#if !defined(CONFIG_ARCH_HAS_THREAD_ABORT)
void z_impl_k_thread_abort(k_tid_t thread)
{
	if (thread == _current && !arch_is_in_isr()) {
400039a8:	400047b7          	lui	a5,0x40004
400039ac:	77878713          	addi	a4,a5,1912 # 40004778 <_kernel>
400039b0:	00872683          	lw	a3,8(a4)
{
400039b4:	ff010113          	addi	sp,sp,-16
400039b8:	00812423          	sw	s0,8(sp)
400039bc:	00112623          	sw	ra,12(sp)
400039c0:	77878413          	addi	s0,a5,1912
	if (thread == _current && !arch_is_in_isr()) {
400039c4:	00a69863          	bne	a3,a0,400039d4 <z_impl_k_thread_abort+0x2c>
400039c8:	00072783          	lw	a5,0(a4)
400039cc:	00079463          	bnez	a5,400039d4 <z_impl_k_thread_abort+0x2c>
		/* Thread is self-exiting, idle thread on this CPU will do
		 * the cleanup
		 */
		z_self_abort();
400039d0:	fa9ff0ef          	jal	ra,40003978 <z_self_abort>
	}

	z_thread_single_abort(thread);
400039d4:	945ff0ef          	jal	ra,40003318 <z_thread_single_abort>

	if (!arch_is_in_isr()) {
400039d8:	00042783          	lw	a5,0(s0)
400039dc:	02079063          	bnez	a5,400039fc <z_impl_k_thread_abort+0x54>
400039e0:	00800513          	li	a0,8
400039e4:	30053573          	csrrc	a0,mstatus,a0
		/* Don't need to do this if we're in an ISR */
		z_reschedule_unlocked();
	}
}
400039e8:	00812403          	lw	s0,8(sp)
400039ec:	00c12083          	lw	ra,12(sp)
	(void) z_reschedule_irqlock(arch_irq_lock());
400039f0:	00857513          	andi	a0,a0,8
400039f4:	01010113          	addi	sp,sp,16
400039f8:	c50ff06f          	j	40002e48 <z_reschedule_irqlock>
400039fc:	00c12083          	lw	ra,12(sp)
40003a00:	00812403          	lw	s0,8(sp)
40003a04:	01010113          	addi	sp,sp,16
40003a08:	00008067          	ret

40003a0c <boot_banner>:
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
40003a0c:	40004637          	lui	a2,0x40004
40003a10:	400045b7          	lui	a1,0x40004
40003a14:	40004537          	lui	a0,0x40004
40003a18:	3e060613          	addi	a2,a2,992 # 400043e0 <__clz_tab+0x13c>
40003a1c:	55458593          	addi	a1,a1,1364 # 40004554 <levels.0+0x14>
40003a20:	57850513          	addi	a0,a0,1400 # 40004578 <levels.0+0x38>
40003a24:	cfcfd06f          	j	40000f20 <printk>

40003a28 <elapsed>:
	sys_dlist_remove(&t->node);
}

static int32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0U;
40003a28:	400047b7          	lui	a5,0x40004
40003a2c:	5c87a783          	lw	a5,1480(a5) # 400045c8 <announce_remaining>
40003a30:	00079463          	bnez	a5,40003a38 <elapsed+0x10>
40003a34:	c6dfe06f          	j	400026a0 <z_clock_elapsed>
}
40003a38:	00000513          	li	a0,0
40003a3c:	00008067          	ret

40003a40 <next_timeout>:
	return list->head == list;
40003a40:	400067b7          	lui	a5,0x40006

static int32_t next_timeout(void)
{
40003a44:	ff010113          	addi	sp,sp,-16
40003a48:	e1478793          	addi	a5,a5,-492 # 40005e14 <timeout_list>
40003a4c:	00812423          	sw	s0,8(sp)
40003a50:	0007a403          	lw	s0,0(a5)
40003a54:	00112623          	sw	ra,12(sp)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40003a58:	00f41463          	bne	s0,a5,40003a60 <next_timeout+0x20>
40003a5c:	00000413          	li	s0,0
	struct _timeout *to = first();
	int32_t ticks_elapsed = elapsed();
40003a60:	fc9ff0ef          	jal	ra,40003a28 <elapsed>
	int32_t ret = to == NULL ? MAX_WAIT
40003a64:	02040c63          	beqz	s0,40003a9c <next_timeout+0x5c>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
40003a68:	01042703          	lw	a4,16(s0)
40003a6c:	01442783          	lw	a5,20(s0)
40003a70:	41f55693          	srai	a3,a0,0x1f
40003a74:	40a70533          	sub	a0,a4,a0
40003a78:	00a73733          	sltu	a4,a4,a0
40003a7c:	40d787b3          	sub	a5,a5,a3
40003a80:	40e787b3          	sub	a5,a5,a4
	int32_t ret = to == NULL ? MAX_WAIT
40003a84:	00f04663          	bgtz	a5,40003a90 <next_timeout+0x50>
40003a88:	04079063          	bnez	a5,40003ac8 <next_timeout+0x88>
40003a8c:	02050e63          	beqz	a0,40003ac8 <next_timeout+0x88>
		: CLAMP(to->dticks - ticks_elapsed, 0, MAX_WAIT);
40003a90:	00f04663          	bgtz	a5,40003a9c <next_timeout+0x5c>
40003a94:	00079863          	bnez	a5,40003aa4 <next_timeout+0x64>
40003a98:	00055663          	bgez	a0,40003aa4 <next_timeout+0x64>
	int32_t ret = to == NULL ? MAX_WAIT
40003a9c:	80000537          	lui	a0,0x80000
40003aa0:	fff54513          	not	a0,a0

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
40003aa4:	400047b7          	lui	a5,0x40004
40003aa8:	78c7a783          	lw	a5,1932(a5) # 4000478c <_kernel+0x14>
40003aac:	00078663          	beqz	a5,40003ab8 <next_timeout+0x78>
40003ab0:	00a7d463          	bge	a5,a0,40003ab8 <next_timeout+0x78>
40003ab4:	00078513          	mv	a0,a5
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
40003ab8:	00c12083          	lw	ra,12(sp)
40003abc:	00812403          	lw	s0,8(sp)
40003ac0:	01010113          	addi	sp,sp,16
40003ac4:	00008067          	ret
	int32_t ret = to == NULL ? MAX_WAIT
40003ac8:	00000513          	li	a0,0
40003acc:	fd9ff06f          	j	40003aa4 <next_timeout+0x64>

40003ad0 <remove_timeout>:
	return (node == list->tail) ? NULL : node->next;
40003ad0:	00052783          	lw	a5,0(a0) # 80000000 <CONFIG_SYSTEM_WORKQUEUE_PRIORITY+0x80000001>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
40003ad4:	02050e63          	beqz	a0,40003b10 <remove_timeout+0x40>
	return (node == list->tail) ? NULL : node->next;
40003ad8:	40006737          	lui	a4,0x40006
40003adc:	e1872703          	lw	a4,-488(a4) # 40005e18 <timeout_list+0x4>
40003ae0:	02e50863          	beq	a0,a4,40003b10 <remove_timeout+0x40>
	if (next(t) != NULL) {
40003ae4:	02078663          	beqz	a5,40003b10 <remove_timeout+0x40>
		next(t)->dticks += t->dticks;
40003ae8:	0107a703          	lw	a4,16(a5)
40003aec:	01052683          	lw	a3,16(a0)
40003af0:	01452583          	lw	a1,20(a0)
40003af4:	0147a603          	lw	a2,20(a5)
40003af8:	00d706b3          	add	a3,a4,a3
40003afc:	00e6b733          	sltu	a4,a3,a4
40003b00:	00b60633          	add	a2,a2,a1
40003b04:	00c70733          	add	a4,a4,a2
40003b08:	00d7a823          	sw	a3,16(a5)
40003b0c:	00e7aa23          	sw	a4,20(a5)
	node->prev->next = node->next;
40003b10:	00452703          	lw	a4,4(a0)
40003b14:	00f72023          	sw	a5,0(a4)
	node->next->prev = node->prev;
40003b18:	00e7a223          	sw	a4,4(a5)
	node->next = NULL;
40003b1c:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
40003b20:	00052223          	sw	zero,4(a0)
}
40003b24:	00008067          	ret

40003b28 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
40003b28:	fe010113          	addi	sp,sp,-32
40003b2c:	00912a23          	sw	s1,20(sp)
40003b30:	01412423          	sw	s4,8(sp)
40003b34:	00112e23          	sw	ra,28(sp)
40003b38:	00058a13          	mv	s4,a1
40003b3c:	00812c23          	sw	s0,24(sp)
40003b40:	01212823          	sw	s2,16(sp)
40003b44:	01312623          	sw	s3,12(sp)
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
40003b48:	fff00593          	li	a1,-1
{
40003b4c:	00050493          	mv	s1,a0
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
40003b50:	00b61463          	bne	a2,a1,40003b58 <z_add_timeout+0x30>
40003b54:	14c68c63          	beq	a3,a2,40003cac <z_add_timeout+0x184>
#endif

#ifdef CONFIG_LEGACY_TIMEOUT_API
	k_ticks_t ticks = timeout;
#else
	k_ticks_t ticks = timeout.ticks + 1;
40003b58:	00160793          	addi	a5,a2,1
40003b5c:	00c7b633          	sltu	a2,a5,a2

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
40003b60:	ffe00913          	li	s2,-2
	k_ticks_t ticks = timeout.ticks + 1;
40003b64:	00078993          	mv	s3,a5
40003b68:	00d60433          	add	s0,a2,a3
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
40003b6c:	40f907b3          	sub	a5,s2,a5
40003b70:	00f93733          	sltu	a4,s2,a5
40003b74:	fff44793          	not	a5,s0
40003b78:	40e787b3          	sub	a5,a5,a4
40003b7c:	0407c863          	bltz	a5,40003bcc <z_add_timeout+0xa4>
		ticks = Z_TICK_ABS(ticks) - (curr_tick + elapsed());
40003b80:	ea9ff0ef          	jal	ra,40003a28 <elapsed>
40003b84:	400047b7          	lui	a5,0x40004
40003b88:	5a878793          	addi	a5,a5,1448 # 400045a8 <curr_tick>
40003b8c:	0007a703          	lw	a4,0(a5)
40003b90:	0047a683          	lw	a3,4(a5)
40003b94:	40e90733          	sub	a4,s2,a4
40003b98:	00e93933          	sltu	s2,s2,a4
40003b9c:	fff6c693          	not	a3,a3
40003ba0:	413709b3          	sub	s3,a4,s3
40003ba4:	412686b3          	sub	a3,a3,s2
40003ba8:	01373733          	sltu	a4,a4,s3
40003bac:	40868433          	sub	s0,a3,s0
40003bb0:	40e40433          	sub	s0,s0,a4
40003bb4:	40a987b3          	sub	a5,s3,a0
40003bb8:	41f55713          	srai	a4,a0,0x1f
40003bbc:	00f9b6b3          	sltu	a3,s3,a5
40003bc0:	40e40433          	sub	s0,s0,a4
40003bc4:	00078993          	mv	s3,a5
40003bc8:	40d40433          	sub	s0,s0,a3
	}
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
40003bcc:	0144a423          	sw	s4,8(s1)
40003bd0:	00800913          	li	s2,8
40003bd4:	30093973          	csrrc	s2,mstatus,s2
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
40003bd8:	e51ff0ef          	jal	ra,40003a28 <elapsed>
	key = (mstatus & MSTATUS_IEN);
40003bdc:	00897913          	andi	s2,s2,8
	ticks = MAX(1, ticks);
40003be0:	00098793          	mv	a5,s3
40003be4:	00804a63          	bgtz	s0,40003bf8 <z_add_timeout+0xd0>
40003be8:	00041463          	bnez	s0,40003bf0 <z_add_timeout+0xc8>
40003bec:	00099663          	bnez	s3,40003bf8 <z_add_timeout+0xd0>
40003bf0:	00100793          	li	a5,1
40003bf4:	00000413          	li	s0,0
		to->dticks = ticks + elapsed();
40003bf8:	41f55713          	srai	a4,a0,0x1f
40003bfc:	00a78533          	add	a0,a5,a0
40003c00:	00e40433          	add	s0,s0,a4
40003c04:	00f537b3          	sltu	a5,a0,a5
40003c08:	008787b3          	add	a5,a5,s0
	return list->head == list;
40003c0c:	40006737          	lui	a4,0x40006
40003c10:	00f4aa23          	sw	a5,20(s1)
40003c14:	e1472783          	lw	a5,-492(a4) # 40005e14 <timeout_list>
40003c18:	00a4a823          	sw	a0,16(s1)
40003c1c:	e1470713          	addi	a4,a4,-492
	return sys_dlist_is_empty(list) ? NULL : list->head;
40003c20:	00e78663          	beq	a5,a4,40003c2c <z_add_timeout+0x104>
	return (node == list->tail) ? NULL : node->next;
40003c24:	00472803          	lw	a6,4(a4)
		for (t = first(); t != NULL; t = next(t)) {
40003c28:	02079063          	bnez	a5,40003c48 <z_add_timeout+0x120>
	node->prev = list->tail;
40003c2c:	00472783          	lw	a5,4(a4)
	node->next = list;
40003c30:	00e4a023          	sw	a4,0(s1)
	node->prev = list->tail;
40003c34:	00f4a223          	sw	a5,4(s1)
	list->tail->next = node;
40003c38:	00472783          	lw	a5,4(a4)
40003c3c:	0097a023          	sw	s1,0(a5)
	list->tail = node;
40003c40:	00972223          	sw	s1,4(a4)
}
40003c44:	04c0006f          	j	40003c90 <z_add_timeout+0x168>
			if (t->dticks > to->dticks) {
40003c48:	0147a503          	lw	a0,20(a5)
40003c4c:	0144a583          	lw	a1,20(s1)
40003c50:	0107a683          	lw	a3,16(a5)
40003c54:	0104a603          	lw	a2,16(s1)
40003c58:	00a5c663          	blt	a1,a0,40003c64 <z_add_timeout+0x13c>
40003c5c:	06b51863          	bne	a0,a1,40003ccc <z_add_timeout+0x1a4>
40003c60:	06d67663          	bgeu	a2,a3,40003ccc <z_add_timeout+0x1a4>
				t->dticks -= to->dticks;
40003c64:	40c68633          	sub	a2,a3,a2
40003c68:	00c6b6b3          	sltu	a3,a3,a2
40003c6c:	40b505b3          	sub	a1,a0,a1
40003c70:	40d586b3          	sub	a3,a1,a3
40003c74:	00d7aa23          	sw	a3,20(a5)
	node->prev = successor->prev;
40003c78:	0047a683          	lw	a3,4(a5)
40003c7c:	00c7a823          	sw	a2,16(a5)
	node->next = successor;
40003c80:	00f4a023          	sw	a5,0(s1)
	node->prev = successor->prev;
40003c84:	00d4a223          	sw	a3,4(s1)
	successor->prev->next = node;
40003c88:	0096a023          	sw	s1,0(a3)
	successor->prev = node;
40003c8c:	0097a223          	sw	s1,4(a5)
	return list->head == list;
40003c90:	00072783          	lw	a5,0(a4)
	return sys_dlist_is_empty(list) ? NULL : list->head;
40003c94:	00e78a63          	beq	a5,a4,40003ca8 <z_add_timeout+0x180>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
40003c98:	00f49863          	bne	s1,a5,40003ca8 <z_add_timeout+0x180>
			z_clock_set_timeout(next_timeout(), false);
40003c9c:	da5ff0ef          	jal	ra,40003a40 <next_timeout>
40003ca0:	00000593          	li	a1,0
40003ca4:	911fe0ef          	jal	ra,400025b4 <z_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
40003ca8:	30092973          	csrrs	s2,mstatus,s2
		}
	}
}
40003cac:	01c12083          	lw	ra,28(sp)
40003cb0:	01812403          	lw	s0,24(sp)
40003cb4:	01412483          	lw	s1,20(sp)
40003cb8:	01012903          	lw	s2,16(sp)
40003cbc:	00c12983          	lw	s3,12(sp)
40003cc0:	00812a03          	lw	s4,8(sp)
40003cc4:	02010113          	addi	sp,sp,32
40003cc8:	00008067          	ret
			to->dticks -= t->dticks;
40003ccc:	40d606b3          	sub	a3,a2,a3
40003cd0:	00d63633          	sltu	a2,a2,a3
40003cd4:	40a585b3          	sub	a1,a1,a0
40003cd8:	40c58633          	sub	a2,a1,a2
40003cdc:	00d4a823          	sw	a3,16(s1)
40003ce0:	00c4aa23          	sw	a2,20(s1)
	return (node == list->tail) ? NULL : node->next;
40003ce4:	f50784e3          	beq	a5,a6,40003c2c <z_add_timeout+0x104>
40003ce8:	0007a783          	lw	a5,0(a5)
40003cec:	f3dff06f          	j	40003c28 <z_add_timeout+0x100>

40003cf0 <z_abort_timeout>:

int z_abort_timeout(struct _timeout *to)
{
40003cf0:	ff010113          	addi	sp,sp,-16
40003cf4:	00812423          	sw	s0,8(sp)
40003cf8:	00112623          	sw	ra,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003cfc:	00800413          	li	s0,8
40003d00:	30043473          	csrrc	s0,mstatus,s0
	int ret = -EINVAL;

	LOCKED(&timeout_lock) {
		if (sys_dnode_is_linked(&to->node)) {
40003d04:	00052783          	lw	a5,0(a0)
	key = (mstatus & MSTATUS_IEN);
40003d08:	00847413          	andi	s0,s0,8
40003d0c:	02078063          	beqz	a5,40003d2c <z_abort_timeout+0x3c>
			remove_timeout(to);
40003d10:	dc1ff0ef          	jal	ra,40003ad0 <remove_timeout>
			ret = 0;
40003d14:	00000513          	li	a0,0
	__asm__ volatile ("csrrs %0, mstatus, %1"
40003d18:	30042473          	csrrs	s0,mstatus,s0
		}
	}

	return ret;
}
40003d1c:	00c12083          	lw	ra,12(sp)
40003d20:	00812403          	lw	s0,8(sp)
40003d24:	01010113          	addi	sp,sp,16
40003d28:	00008067          	ret
	int ret = -EINVAL;
40003d2c:	fea00513          	li	a0,-22
40003d30:	fe9ff06f          	j	40003d18 <z_abort_timeout+0x28>

40003d34 <z_get_next_timeout_expiry>:

	return ticks;
}

int32_t z_get_next_timeout_expiry(void)
{
40003d34:	ff010113          	addi	sp,sp,-16
40003d38:	00112623          	sw	ra,12(sp)
40003d3c:	00812423          	sw	s0,8(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003d40:	00800793          	li	a5,8
40003d44:	3007b473          	csrrc	s0,mstatus,a5
	int32_t ret = (int32_t) K_TICKS_FOREVER;

	LOCKED(&timeout_lock) {
		ret = next_timeout();
40003d48:	cf9ff0ef          	jal	ra,40003a40 <next_timeout>
	key = (mstatus & MSTATUS_IEN);
40003d4c:	00847793          	andi	a5,s0,8
	__asm__ volatile ("csrrs %0, mstatus, %1"
40003d50:	3007a7f3          	csrrs	a5,mstatus,a5
	}
	return ret;
}
40003d54:	00c12083          	lw	ra,12(sp)
40003d58:	00812403          	lw	s0,8(sp)
40003d5c:	01010113          	addi	sp,sp,16
40003d60:	00008067          	ret

40003d64 <z_set_timeout_expiry>:

void z_set_timeout_expiry(int32_t ticks, bool is_idle)
{
40003d64:	fe010113          	addi	sp,sp,-32
40003d68:	00812c23          	sw	s0,24(sp)
40003d6c:	00912a23          	sw	s1,20(sp)
40003d70:	00112e23          	sw	ra,28(sp)
40003d74:	00050493          	mv	s1,a0
40003d78:	00b12623          	sw	a1,12(sp)
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003d7c:	00800413          	li	s0,8
40003d80:	30043473          	csrrc	s0,mstatus,s0
	LOCKED(&timeout_lock) {
		int next_to = next_timeout();
40003d84:	cbdff0ef          	jal	ra,40003a40 <next_timeout>
		 * SMP can't use this optimization though: we don't
		 * know when context switches happen until interrupt
		 * exit and so can't get the timeslicing clamp folded
		 * in.
		 */
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
40003d88:	00100793          	li	a5,1
	key = (mstatus & MSTATUS_IEN);
40003d8c:	00847413          	andi	s0,s0,8
40003d90:	00a7da63          	bge	a5,a0,40003da4 <z_set_timeout_expiry+0x40>
40003d94:	00c12583          	lw	a1,12(sp)
40003d98:	00a4d663          	bge	s1,a0,40003da4 <z_set_timeout_expiry+0x40>
			z_clock_set_timeout(ticks, is_idle);
40003d9c:	00048513          	mv	a0,s1
40003da0:	815fe0ef          	jal	ra,400025b4 <z_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
40003da4:	30042473          	csrrs	s0,mstatus,s0
		}
	}
}
40003da8:	01c12083          	lw	ra,28(sp)
40003dac:	01812403          	lw	s0,24(sp)
40003db0:	01412483          	lw	s1,20(sp)
40003db4:	02010113          	addi	sp,sp,32
40003db8:	00008067          	ret

40003dbc <z_clock_announce>:

void z_clock_announce(int32_t ticks)
{
40003dbc:	fd010113          	addi	sp,sp,-48
40003dc0:	02812423          	sw	s0,40(sp)
40003dc4:	02912223          	sw	s1,36(sp)
40003dc8:	02112623          	sw	ra,44(sp)
40003dcc:	03212023          	sw	s2,32(sp)
40003dd0:	01312e23          	sw	s3,28(sp)
40003dd4:	01412c23          	sw	s4,24(sp)
40003dd8:	00050493          	mv	s1,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003ddc:	00800413          	li	s0,8
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
40003de0:	bf0ff0ef          	jal	ra,400031d0 <z_time_slice>
40003de4:	30043473          	csrrc	s0,mstatus,s0
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
40003de8:	40004937          	lui	s2,0x40004
40003dec:	5c992423          	sw	s1,1480(s2) # 400045c8 <announce_remaining>
	return list->head == list;
40003df0:	400069b7          	lui	s3,0x40006

	while (first() != NULL && first()->dticks <= announce_remaining) {
		struct _timeout *t = first();
		int dt = t->dticks;

		curr_tick += dt;
40003df4:	400044b7          	lui	s1,0x40004
	key = (mstatus & MSTATUS_IEN);
40003df8:	00847413          	andi	s0,s0,8
	while (first() != NULL && first()->dticks <= announce_remaining) {
40003dfc:	5c890913          	addi	s2,s2,1480
40003e00:	e1498993          	addi	s3,s3,-492 # 40005e14 <timeout_list>
		curr_tick += dt;
40003e04:	5a848493          	addi	s1,s1,1448 # 400045a8 <curr_tick>
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003e08:	00800a13          	li	s4,8
	while (first() != NULL && first()->dticks <= announce_remaining) {
40003e0c:	00092783          	lw	a5,0(s2)
40003e10:	0009a503          	lw	a0,0(s3)
		curr_tick += dt;
40003e14:	0004a683          	lw	a3,0(s1)
40003e18:	0044a883          	lw	a7,4(s1)
40003e1c:	41f7d593          	srai	a1,a5,0x1f
	return sys_dlist_is_empty(list) ? NULL : list->head;
40003e20:	03350a63          	beq	a0,s3,40003e54 <z_clock_announce+0x98>
	while (first() != NULL && first()->dticks <= announce_remaining) {
40003e24:	02050863          	beqz	a0,40003e54 <z_clock_announce+0x98>
40003e28:	01452603          	lw	a2,20(a0)
40003e2c:	01052703          	lw	a4,16(a0)
40003e30:	00c5c663          	blt	a1,a2,40003e3c <z_clock_announce+0x80>
40003e34:	06b61663          	bne	a2,a1,40003ea0 <z_clock_announce+0xe4>
40003e38:	06e7f463          	bgeu	a5,a4,40003ea0 <z_clock_announce+0xe4>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
40003e3c:	40f70833          	sub	a6,a4,a5
40003e40:	01073733          	sltu	a4,a4,a6
40003e44:	40b60633          	sub	a2,a2,a1
40003e48:	40e60733          	sub	a4,a2,a4
40003e4c:	01052823          	sw	a6,16(a0)
40003e50:	00e52a23          	sw	a4,20(a0)
	}

	curr_tick += announce_remaining;
40003e54:	00d786b3          	add	a3,a5,a3
40003e58:	011585b3          	add	a1,a1,a7
40003e5c:	00f6b7b3          	sltu	a5,a3,a5
40003e60:	00b787b3          	add	a5,a5,a1
40003e64:	00d4a023          	sw	a3,0(s1)
40003e68:	00f4a223          	sw	a5,4(s1)
	announce_remaining = 0;
40003e6c:	00092023          	sw	zero,0(s2)

	z_clock_set_timeout(next_timeout(), false);
40003e70:	bd1ff0ef          	jal	ra,40003a40 <next_timeout>
40003e74:	00000593          	li	a1,0
40003e78:	f3cfe0ef          	jal	ra,400025b4 <z_clock_set_timeout>
	__asm__ volatile ("csrrs %0, mstatus, %1"
40003e7c:	30042473          	csrrs	s0,mstatus,s0

	k_spin_unlock(&timeout_lock, key);
}
40003e80:	02c12083          	lw	ra,44(sp)
40003e84:	02812403          	lw	s0,40(sp)
40003e88:	02412483          	lw	s1,36(sp)
40003e8c:	02012903          	lw	s2,32(sp)
40003e90:	01c12983          	lw	s3,28(sp)
40003e94:	01812a03          	lw	s4,24(sp)
40003e98:	03010113          	addi	sp,sp,48
40003e9c:	00008067          	ret
		curr_tick += dt;
40003ea0:	00d706b3          	add	a3,a4,a3
		announce_remaining -= dt;
40003ea4:	40e787b3          	sub	a5,a5,a4
		curr_tick += dt;
40003ea8:	41f75593          	srai	a1,a4,0x1f
40003eac:	00e6b633          	sltu	a2,a3,a4
40003eb0:	011585b3          	add	a1,a1,a7
		announce_remaining -= dt;
40003eb4:	00f92023          	sw	a5,0(s2)
		t->dticks = 0;
40003eb8:	00000813          	li	a6,0
40003ebc:	00000793          	li	a5,0
		curr_tick += dt;
40003ec0:	00b605b3          	add	a1,a2,a1
		t->dticks = 0;
40003ec4:	00f52823          	sw	a5,16(a0)
40003ec8:	01052a23          	sw	a6,20(a0)
		curr_tick += dt;
40003ecc:	00d4a023          	sw	a3,0(s1)
40003ed0:	00b4a223          	sw	a1,4(s1)
		remove_timeout(t);
40003ed4:	00a12623          	sw	a0,12(sp)
40003ed8:	bf9ff0ef          	jal	ra,40003ad0 <remove_timeout>
40003edc:	30042473          	csrrs	s0,mstatus,s0
		t->fn(t);
40003ee0:	00c12503          	lw	a0,12(sp)
40003ee4:	00852783          	lw	a5,8(a0)
40003ee8:	000780e7          	jalr	a5
	__asm__ volatile ("csrrc %0, mstatus, %1"
40003eec:	300a3473          	csrrc	s0,mstatus,s4
	key = (mstatus & MSTATUS_IEN);
40003ef0:	00847413          	andi	s0,s0,8
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
40003ef4:	f19ff06f          	j	40003e0c <z_clock_announce+0x50>

40003ef8 <z_timer_expiration_handler>:

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
40003ef8:	02852783          	lw	a5,40(a0)
40003efc:	02c52603          	lw	a2,44(a0)
{
40003f00:	ff010113          	addi	sp,sp,-16
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
40003f04:	00178713          	addi	a4,a5,1
40003f08:	00f737b3          	sltu	a5,a4,a5
{
40003f0c:	00812423          	sw	s0,8(sp)
40003f10:	00112623          	sw	ra,12(sp)
40003f14:	00912223          	sw	s1,4(sp)
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
40003f18:	00c787b3          	add	a5,a5,a2
{
40003f1c:	00050413          	mv	s0,a0
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
40003f20:	00079663          	bnez	a5,40003f2c <z_timer_expiration_handler+0x34>
40003f24:	00100693          	li	a3,1
40003f28:	00e6fe63          	bgeu	a3,a4,40003f44 <z_timer_expiration_handler+0x4c>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
40003f2c:	02842603          	lw	a2,40(s0)
40003f30:	02c42683          	lw	a3,44(s0)
40003f34:	400045b7          	lui	a1,0x40004
40003f38:	ef858593          	addi	a1,a1,-264 # 40003ef8 <z_timer_expiration_handler>
40003f3c:	00040513          	mv	a0,s0
40003f40:	be9ff0ef          	jal	ra,40003b28 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
40003f44:	03042783          	lw	a5,48(s0)
40003f48:	00178793          	addi	a5,a5,1
40003f4c:	02f42823          	sw	a5,48(s0)

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
40003f50:	02042783          	lw	a5,32(s0)
40003f54:	00078663          	beqz	a5,40003f60 <z_timer_expiration_handler+0x68>
		timer->expiry_fn(timer);
40003f58:	00040513          	mv	a0,s0
40003f5c:	000780e7          	jalr	a5
	return list->head == list;
40003f60:	01842483          	lw	s1,24(s0)
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
40003f64:	01840413          	addi	s0,s0,24
	return sys_dlist_is_empty(list) ? NULL : list->head;
40003f68:	00848e63          	beq	s1,s0,40003f84 <z_timer_expiration_handler+0x8c>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
40003f6c:	00048c63          	beqz	s1,40003f84 <z_timer_expiration_handler+0x8c>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
40003f70:	00048513          	mv	a0,s1
40003f74:	e71fe0ef          	jal	ra,40002de4 <z_unpend_thread_no_timeout>

	z_ready_thread(thread);
40003f78:	00048513          	mv	a0,s1
40003f7c:	8c8ff0ef          	jal	ra,40003044 <z_ready_thread>
40003f80:	0604ae23          	sw	zero,124(s1)

	arch_thread_return_value_set(thread, 0);
}
40003f84:	00c12083          	lw	ra,12(sp)
40003f88:	00812403          	lw	s0,8(sp)
40003f8c:	00412483          	lw	s1,4(sp)
40003f90:	01010113          	addi	sp,sp,16
40003f94:	00008067          	ret

40003f98 <k_timer_init>:
	sys_dlist_init(&w->waitq);
40003f98:	01850793          	addi	a5,a0,24

void k_timer_init(struct k_timer *timer,
			 k_timer_expiry_t expiry_fn,
			 k_timer_stop_t stop_fn)
{
	timer->expiry_fn = expiry_fn;
40003f9c:	02b52023          	sw	a1,32(a0)
	timer->stop_fn = stop_fn;
40003fa0:	02c52223          	sw	a2,36(a0)
	timer->status = 0U;
40003fa4:	02052823          	sw	zero,48(a0)
	list->head = (sys_dnode_t *)list;
40003fa8:	00f52c23          	sw	a5,24(a0)
	list->tail = (sys_dnode_t *)list;
40003fac:	00f52e23          	sw	a5,28(a0)
	node->next = NULL;
40003fb0:	00052023          	sw	zero,0(a0)
	node->prev = NULL;
40003fb4:	00052223          	sw	zero,4(a0)

	z_waitq_init(&timer->wait_q);
	z_init_timeout(&timer->timeout);
	SYS_TRACING_OBJ_INIT(k_timer, timer);

	timer->user_data = NULL;
40003fb8:	02052a23          	sw	zero,52(a0)

	z_object_init(timer);
}
40003fbc:	00008067          	ret

40003fc0 <z_impl_k_timer_start>:


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
40003fc0:	fe010113          	addi	sp,sp,-32
40003fc4:	00812c23          	sw	s0,24(sp)
40003fc8:	00112e23          	sw	ra,28(sp)
40003fcc:	00050413          	mv	s0,a0
40003fd0:	00912a23          	sw	s1,20(sp)
40003fd4:	00060513          	mv	a0,a2
40003fd8:	01212823          	sw	s2,16(sp)
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
40003fdc:	fff00813          	li	a6,-1
{
40003fe0:	00068793          	mv	a5,a3
40003fe4:	00058613          	mv	a2,a1
40003fe8:	00050693          	mv	a3,a0
	if (K_TIMEOUT_EQ(duration, K_FOREVER)) {
40003fec:	01059463          	bne	a1,a6,40003ff4 <z_impl_k_timer_start+0x34>
40003ff0:	0cb50263          	beq	a0,a1,400040b4 <z_impl_k_timer_start+0xf4>
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (period.ticks != 0 && Z_TICK_ABS(period.ticks) < 0) {
40003ff4:	00f76833          	or	a6,a4,a5
40003ff8:	00078913          	mv	s2,a5
40003ffc:	00070493          	mv	s1,a4
40004000:	02080e63          	beqz	a6,4000403c <z_impl_k_timer_start+0x7c>
40004004:	ffe00893          	li	a7,-2
40004008:	40f88833          	sub	a6,a7,a5
4000400c:	0108b8b3          	sltu	a7,a7,a6
40004010:	fff74813          	not	a6,a4
40004014:	41180833          	sub	a6,a6,a7
40004018:	02085263          	bgez	a6,4000403c <z_impl_k_timer_start+0x7c>
		period.ticks = MAX(period.ticks - 1, 1);
4000401c:	0017b493          	seqz	s1,a5
40004020:	409704b3          	sub	s1,a4,s1
40004024:	fff78913          	addi	s2,a5,-1
40004028:	00904a63          	bgtz	s1,4000403c <z_impl_k_timer_start+0x7c>
4000402c:	00049463          	bnez	s1,40004034 <z_impl_k_timer_start+0x74>
40004030:	00091663          	bnez	s2,4000403c <z_impl_k_timer_start+0x7c>
40004034:	00100913          	li	s2,1
40004038:	00000493          	li	s1,0
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
4000403c:	ffe00713          	li	a4,-2
40004040:	40b707b3          	sub	a5,a4,a1
40004044:	00f73733          	sltu	a4,a4,a5
40004048:	fff54793          	not	a5,a0
4000404c:	40e787b3          	sub	a5,a5,a4
40004050:	0007de63          	bgez	a5,4000406c <z_impl_k_timer_start+0xac>
		duration.ticks = MAX(duration.ticks - 1, 0);
40004054:	0015b693          	seqz	a3,a1
40004058:	40d506b3          	sub	a3,a0,a3
4000405c:	fff58613          	addi	a2,a1,-1
40004060:	0006d663          	bgez	a3,4000406c <z_impl_k_timer_start+0xac>
40004064:	00000613          	li	a2,0
40004068:	00000693          	li	a3,0
	}
#endif

	(void)z_abort_timeout(&timer->timeout);
4000406c:	00040513          	mv	a0,s0
40004070:	00d12623          	sw	a3,12(sp)
40004074:	00c12423          	sw	a2,8(sp)
40004078:	c79ff0ef          	jal	ra,40003cf0 <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
4000407c:	00040513          	mv	a0,s0
	timer->period = period;
40004080:	03242423          	sw	s2,40(s0)
40004084:	02942623          	sw	s1,44(s0)
	timer->status = 0U;
40004088:	02042823          	sw	zero,48(s0)
		     duration);
}
4000408c:	01812403          	lw	s0,24(sp)
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
40004090:	00812603          	lw	a2,8(sp)
40004094:	00c12683          	lw	a3,12(sp)
}
40004098:	01c12083          	lw	ra,28(sp)
4000409c:	01412483          	lw	s1,20(sp)
400040a0:	01012903          	lw	s2,16(sp)
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
400040a4:	400045b7          	lui	a1,0x40004
400040a8:	ef858593          	addi	a1,a1,-264 # 40003ef8 <z_timer_expiration_handler>
}
400040ac:	02010113          	addi	sp,sp,32
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
400040b0:	a79ff06f          	j	40003b28 <z_add_timeout>
}
400040b4:	01c12083          	lw	ra,28(sp)
400040b8:	01812403          	lw	s0,24(sp)
400040bc:	01412483          	lw	s1,20(sp)
400040c0:	01012903          	lw	s2,16(sp)
400040c4:	02010113          	addi	sp,sp,32
400040c8:	00008067          	ret

400040cc <z_impl_k_timer_status_sync>:
}
#include <syscalls/k_timer_status_get_mrsh.c>
#endif

uint32_t z_impl_k_timer_status_sync(struct k_timer *timer)
{
400040cc:	ff010113          	addi	sp,sp,-16
400040d0:	00812423          	sw	s0,8(sp)
400040d4:	00912223          	sw	s1,4(sp)
400040d8:	00112623          	sw	ra,12(sp)
400040dc:	00050413          	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
400040e0:	00800493          	li	s1,8
400040e4:	3004b5f3          	csrrc	a1,mstatus,s1
	__ASSERT(!arch_is_in_isr(), "");

	k_spinlock_key_t key = k_spin_lock(&lock);
	uint32_t result = timer->status;
400040e8:	03052503          	lw	a0,48(a0)
	key = (mstatus & MSTATUS_IEN);
400040ec:	0085f593          	andi	a1,a1,8

	if (result == 0U) {
400040f0:	02051863          	bnez	a0,40004120 <z_impl_k_timer_status_sync+0x54>
		if (!z_is_inactive_timeout(&timer->timeout)) {
400040f4:	00042783          	lw	a5,0(s0)
400040f8:	02078463          	beqz	a5,40004120 <z_impl_k_timer_status_sync+0x54>
			/* wait for timer to expire or stop */
			(void)z_pend_curr(&lock, key, &timer->wait_q, K_FOREVER);
400040fc:	40004537          	lui	a0,0x40004
40004100:	fff00693          	li	a3,-1
40004104:	fff00713          	li	a4,-1
40004108:	01840613          	addi	a2,s0,24
4000410c:	5cc50513          	addi	a0,a0,1484 # 400045cc <lock>
40004110:	cd4ff0ef          	jal	ra,400035e4 <z_pend_curr>
	__asm__ volatile ("csrrc %0, mstatus, %1"
40004114:	3004b5f3          	csrrc	a1,mstatus,s1

			/* get updated timer status */
			key = k_spin_lock(&lock);
			result = timer->status;
40004118:	03042503          	lw	a0,48(s0)
	key = (mstatus & MSTATUS_IEN);
4000411c:	0085f593          	andi	a1,a1,8
		}
	} else {
		/* timer has already expired at least once */
	}

	timer->status = 0U;
40004120:	02042823          	sw	zero,48(s0)
	__asm__ volatile ("csrrs %0, mstatus, %1"
40004124:	3005a5f3          	csrrs	a1,mstatus,a1
	k_spin_unlock(&lock, key);

	return result;
}
40004128:	00c12083          	lw	ra,12(sp)
4000412c:	00812403          	lw	s0,8(sp)
40004130:	00412483          	lw	s1,4(sp)
40004134:	01010113          	addi	sp,sp,16
40004138:	00008067          	ret

4000413c <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *p1, void *unused2, void *unused3)
{
4000413c:	ff010113          	addi	sp,sp,-16
40004140:	00812423          	sw	s0,8(sp)
40004144:	00912223          	sw	s1,4(sp)
40004148:	00112623          	sw	ra,12(sp)
4000414c:	00050413          	mv	s0,a0
	__asm__ volatile ("csrrc %0, mstatus, %1"
40004150:	00800493          	li	s1,8
40004154:	3004b7f3          	csrrc	a5,mstatus,s1
	while (true) {
		/* Lock interrupts to atomically check if to_abort is non-NULL,
		 * and if so clear it
		 */
		int key = arch_irq_lock();
		struct k_thread *to_abort = cpu->pending_abort;
40004158:	01042503          	lw	a0,16(s0)
	key = (mstatus & MSTATUS_IEN);
4000415c:	0087f793          	andi	a5,a5,8

		if (to_abort) {
40004160:	02050063          	beqz	a0,40004180 <idle+0x44>
			cpu->pending_abort = NULL;
40004164:	00042823          	sw	zero,16(s0)
	__asm__ volatile ("csrrs %0, mstatus, %1"
40004168:	3007a7f3          	csrrs	a5,mstatus,a5
			 * is continued below.
			 */
			LOG_DBG("idle %p aborting thread %p",
				_current, to_abort);

			z_thread_single_abort(to_abort);
4000416c:	9acff0ef          	jal	ra,40003318 <z_thread_single_abort>
	__asm__ volatile ("csrrc %0, mstatus, %1"
40004170:	3004b573          	csrrc	a0,mstatus,s1
40004174:	00857513          	andi	a0,a0,8
40004178:	cd1fe0ef          	jal	ra,40002e48 <z_reschedule_irqlock>
			 * in order to abort the thread, and we now need to
			 * figure out what to do next, it's not necessarily
			 * the case that there are no other runnable threads.
			 */
			z_reschedule_unlocked();
			continue;
4000417c:	fd9ff06f          	j	40004154 <idle+0x18>
		k_busy_wait(100);
		k_yield();
#else

#ifdef CONFIG_SYS_CLOCK_EXISTS
		int32_t ticks = z_get_next_timeout_expiry();
40004180:	bb5ff0ef          	jal	ra,40003d34 <z_get_next_timeout_expiry>
		 * that the system should not enter a tickless idle for
		 * periods less than that.  This seems... silly, given that it
		 * saves no power and does not improve latency.  But it's an
		 * API we need to honor...
		 */
		z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
40004184:	00a04463          	bgtz	a0,4000418c <idle+0x50>
40004188:	00100513          	li	a0,1
4000418c:	00100593          	li	a1,1
40004190:	bd5ff0ef          	jal	ra,40003d64 <z_set_timeout_expiry>
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
40004194:	d54fe0ef          	jal	ra,400026e8 <arch_cpu_idle>
}
40004198:	fbdff06f          	j	40004154 <idle+0x18>

4000419c <k_heap_init>:
4000419c:	00c50713          	addi	a4,a0,12
	list->head = (sys_dnode_t *)list;
400041a0:	00e52623          	sw	a4,12(a0)
	list->tail = (sys_dnode_t *)list;
400041a4:	00e52823          	sw	a4,16(a0)
#include <init.h>

void k_heap_init(struct k_heap *h, void *mem, size_t bytes)
{
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
400041a8:	b48fd06f          	j	400014f0 <sys_heap_init>

400041ac <statics_init>:
}

static int statics_init(const struct device *unused)
{
400041ac:	ff010113          	addi	sp,sp,-16
400041b0:	00812423          	sw	s0,8(sp)
400041b4:	00912223          	sw	s1,4(sp)
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
400041b8:	40006437          	lui	s0,0x40006
400041bc:	400064b7          	lui	s1,0x40006
{
400041c0:	00112623          	sw	ra,12(sp)
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
400041c4:	e4040413          	addi	s0,s0,-448 # 40005e40 <__data_ram_end>
400041c8:	e4048493          	addi	s1,s1,-448 # 40005e40 <__data_ram_end>
400041cc:	00946e63          	bltu	s0,s1,400041e8 <statics_init+0x3c>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
	}
	return 0;
}
400041d0:	00c12083          	lw	ra,12(sp)
400041d4:	00812403          	lw	s0,8(sp)
400041d8:	00412483          	lw	s1,4(sp)
400041dc:	00000513          	li	a0,0
400041e0:	01010113          	addi	sp,sp,16
400041e4:	00008067          	ret
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
400041e8:	00842603          	lw	a2,8(s0)
400041ec:	00442583          	lw	a1,4(s0)
400041f0:	00040513          	mv	a0,s0
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
400041f4:	01840413          	addi	s0,s0,24
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
400041f8:	fa5ff0ef          	jal	ra,4000419c <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
400041fc:	fd1ff06f          	j	400041cc <statics_init+0x20>

40004200 <_OffsetAbsSyms>:
 * point regs
 */
GEN_ABSOLUTE_SYM(_K_THREAD_NO_FLOAT_SIZEOF,
		 STACK_ROUND_UP(sizeof(struct k_thread)));

GEN_ABS_SYM_END
40004200:	00008067          	ret
